#include <bits/stdc++.h>
#include <initializer_list>
#include <unordered_map>
#include <bits/stdc++.h>
#include <stdexcept>
#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <fstream>
#include <sstream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <vector>
#include <memory>
#include <string>
#include <ctime>
#include <cmath>
#include <deque>
#include <list>
#include <map>
#include <cctype>

using namespace std;

/*
B2001 入门测试题目

题目背景

强烈推荐新用户必读贴
题目描述

求两个整数的和。
输入格式

一行，两个用空格隔开的整数。
输出格式

两个整数的和。
输入输出样例
输入 #1

1 2

输出 #1

3

输入 #2

10230 21312

输出 #2

31542

说明/提示

对于 100%100\%100% 的数据，输入的整数在 [1,4×1018][1, 4 \times {10}^{18}][1,4×1018] 内。

code:
int main(){
    long long n,m;
    cin>>n>>m;
    cout<<n+m;
    return 0;
}

*/

/*
B2002 Hello,World!

题目背景

强烈推荐新用户必读贴
题目描述

编写一个能够输出 Hello,World! 的程序，这个程序常常作为一个初学者接触一门新的编程语言所写的第一个程序，也经常用来测试开发、编译环境是否能够正常工作。
输入格式

无
输出格式

无
输入输出样例
输入 #1

无

输出 #1

Hello,World!

说明/提示

    使用英文标点符号；
    Hello,World! 逗号后面没有空格。

code:
int main(){
    cout<<"Hello,World!";
    return 0;
}

*/

/*
B2003 输出第二个整数

题目描述

输入三个整数，整数之间由一个空格分隔。把第二个输入的整数输出。
输入格式

只有一行，共三个整数，整数之间由一个空格分隔。
输出格式

只有一行，一个整数，即输入的第二个整数。
输入输出样例
输入 #1

123 456 789

输出 #1

456

说明/提示

对于 100%100\%100% 的数据，输入的整数在 [1,109][1, {10}^9][1,109] 内。

code:
int main(){
    long long n,m;
    cin>>n>>m>>n;
    cout<<m;
    return 0;
}

*/

/*
B2004 对齐输出

题目描述

读入三个整数，按每个整数占 888 个字符的宽度，右对齐输出它们，按照格式要求依次输出三个整数，之间以一个空格分开。
输入格式

只有一行，包含三个整数 a,b,ca,b,ca,b,c。整数之间以一个空格分开。
输出格式

只有一行，按照格式要求依次输出三个整数，之间以一个空格分开。
输入输出样例
输入 #1

123456789 0 -1

输出 #1

123456789        0       -1

说明/提示

对于 100%100 \%100% 的数据，?231≤a,b,c<231-2^{31} \le a, b, c < 2^{31}?231≤a,b,c<231。

code:
int main(){
    long long n,m,p;
    cin>>n>>m>>p;
    printf("%8d %8d %8d",n,m,p);//cout<<setw()
    return 0;
}

*/

/*
B2005 字符三角形

题目描述

给定一个字符，用它构造一个底边长 555 个字符，高 333 个字符的等腰字符三角形。
输入格式

输入只有一行，包含一个字符。
输出格式

该字符构成的等腰三角形，底边长 555 个字符，高 333 个字符。
输入输出样例
输入 #1

*

输出 #1

  *
 ***
*****

说明/提示

对于 100%100 \%100% 的数据，输入的字符是 ASCII 中的可见字符。

code:
int main(){
    char c;
    cin>>c;
    cout<<"  "<<c<<endl<<" "<<c<<c<<c<<endl<<c<<c<<c<<c<<c;
    return 0;
}

*/

/*
B2006 地球人口承载力估计

题目描述

假设地球上的新生资源按恒定速度增长。照此测算，地球上现有资源加上新生资源可供 xxx 亿人生活 aaa 年，或供 yyy 亿人生活 bbb 年。

为了能够实现可持续发展，避免资源枯竭，地球最多能够养活多少亿人？
输入格式

一行，包括四个正整数 x,a,y,bx, a, y, bx,a,y,b，两个整数之间用单个空格隔开。
输出格式

一个实数 zzz，表示地球最多养活 zzz 亿人，舍入到小数点后两位。
输入输出样例
输入 #1

110 90 90 210

输出 #1

75.00

说明/提示

对于 100%100 \%100% 的数据，1≤x,a,y,b≤1041 \le x, a, y, b \le {10}^41≤x,a,y,b≤104，x>yx > yx>y，a<ba < ba<b，ax<bya x < b yax<by。

code:
int main(){//牛吃草问题 公式
    double a,b,x,y;
    cin>>x>>a>>y>>b;
    printf("%.2lf\n",1.0*(( x*a-y*b )/(a-b)));
    return 0;
}

*/

/*
B2007 A + B 问题

题目描述

在大部分的在线题库中，都会将 A + B 问题作为第一题，以帮助新手熟悉平台的使用方法。

A + B 问题的题目描述如下：给定两个整数 AAA 和 BBB，输出 A+BA + BA+B 的值。保证 A,BA, BA,B 及结果均在 323232 位整型范围内。

现在请你解决这一问题。
输入格式

一行，包含两个整数 A,BA, BA,B，中间用单个空格隔开。AAA 和 BBB 均在 323232 位整型范围内。
输出格式

一个整数，即 A+BA + BA+B 的值。保证结果在 323232 位整型范围内。
输入输出样例
输入 #1

1 2

输出 #1

3

说明/提示

对于 100%100 \%100% 的数据，A,B,A+BA, B, A + BA,B,A+B 均在 323232 位整型范围内。

code:
int main(){
    long long n,m;
    cin>>n>>m;
    cout<<n+m;
    return 0;
}

*/

/*
B2008 计算 (a+b)×c 的值

题目描述

给定 333 个整数 a,b,ca,b,ca,b,c，计算表达式 (a+b)×c(a+b) \times c(a+b)×c 的值。
输入格式

输入仅一行，包括三个整数 a,b,ca,b,ca,b,c，数与数之间以一个空格分开。
输出格式

输出一行，即表达式的值。
输入输出样例
输入 #1

2 3 5

输出 #1

25

说明/提示

对于 100%100 \%100% 的数据，?104<a,b,c<104-{10}^4 < a, b, c < {10}^4?104<a,b,c<104。

code:
int main(){
    long long n,m,p;
    cin>>n>>m>>p;
    cout<<(n+m)*p;
    return 0;
}

*/

/*
B2009 计算 (a+b)/c 的值

题目描述

给定 333 个整数 a,b,ca,b,ca,b,c，计算表达式 (a+b)/c(a+b)/c(a+b)/c 的值，/ 是整除运算。
输入格式

输入仅一行，包括三个整数 a,b,ca,b,ca,b,c，数与数之间以一个空格分开。
输出格式

输出一行，即表达式的值。
输入输出样例
输入 #1

1 1 3

输出 #1

0

说明/提示

对于 100%100 \%100% 的数据，?104<a,b,c<104-{10}^4 < a, b, c < {10}^4?104<a,b,c<104，c≠0c \ne 0c=0。

code:
int main(){
    long long n,m,p;
    cin>>n>>m>>p;
    cout<<(n+m)/p;
    return 0;
}

*/

/*
B2010 带余除法

题目描述

给定被除数和除数，求整数商及余数。此题中请使用默认的整除和取余运算，无需对结果进行任何特殊处理。
输入格式

一行，包含两个整数，依次为被除数和除数（除数非零），中间用一个空格隔开。
输出格式

一行，包含两个整数，依次为整数商和余数，中间用一个空格隔开。
输入输出样例
输入 #1

10 3

输出 #1

3 1

输入 #2

20 4

输出 #2

5 0

说明/提示

对于 100%100 \%100% 的数据，0≤a≤1000 \le a \le 1000≤a≤100，1≤b≤1001 \le b \le 1001≤b≤100。

code:
int main(){
    long long n,m;
    cin>>n>>m;
    cout<<n/m<<" "<<n%m;
    return 0;
}

*/

/*
B2011 计算分数的浮点数值

题目描述

两个整数 aaa 和 bbb 分别作为分子和分母，既分数 a/ba/ba/b，求它的浮点数值（双精度浮点数，保留小数点后 999 位）。
输入格式

输入仅一行，包括两个整数 aaa 和 bbb。
输出格式

输出也仅一行，分数 a/ba/ba/b 的浮点数值（双精度浮点数，保留小数点后 999 位）。
输入输出样例
输入 #1

5 7

输出 #1

0.714285714

说明/提示

对于 100%100 \%100% 的数据，1≤a,b≤1091 \le a, b \le {10}^91≤a,b≤109。

code:
int main(){
    double n,m;
    cin>>n>>m;
    printf("%.9f",1.0*n/m);
    return 0;
}

*/

/*
B2012 甲流疫情死亡率

题目描述

甲流并不可怕，在中国，它的死亡率并不是很高。请根据截止 200920092009 年 121212 月 222222 日各省报告的甲流确诊数 aaa 和死亡数 bbb，计算甲流在各省的死亡率。
输入格式

输入共两行，第一行一个整数为确诊数 aaa，第二行一个整数为死亡数 bbb。
输出格式

输出仅一行，甲流死亡率，以百分数形式输出，精确到小数点后 333 位。
输入输出样例
输入 #1

10433
60

输出 #1

0.575%

说明/提示
数据规模与约定

对于全部的测试点，保证 1≤a,b≤1041 \leq a, b \leq 10^41≤a,b≤104。
提示

在 C 风格输入输出中，百分号 % 可以这样输出：printf("%%");。

code:
int main(){
    double n,m;
    cin>>n>>m;
    printf("%.3f%%",m/n*100);
    return 0;
}

*/

/*
B2013 温度表达转化

题目描述

利用公式 C=5×(F?32)/9C=5 \times (F ? 32)/9C=5×(F?32)/9 ( 其中 CCC 表示摄氏温度，FFF 表示华氏温度）进行计算转化，输入华氏温度 FFF，输出摄氏温度 CCC，要求精确到小数点后 555 位。
输入格式

输入一行，包含一个实数 FFF，表示华氏温度。（F≥?459.67F \ge - 459.67F≥?459.67）
输出格式

输出一行，包含一个实数，表示对应的摄氏温度，要求精确到小数点后 555 位。
输入输出样例
输入 #1

41

输出 #1

5.00000

说明/提示

（F≥?459.67F \ge - 459.67F≥?459.67）

code:
int main(){
    double n;
    cin>>n;
    printf("%.5f",5.0*(n-32)/9);
    return 0;
}

*/

/*
B2014 与圆相关的计算

题目描述

给出圆的半径，求圆的直径、周长和面积。输入圆的半径实数 rrr，输出圆的直径、周长、面积，每个数保留小数点后 444 位。圆周率取值为 3.141593.141593.14159。
输入格式

输入包含一个实数 rrr（0<r≤100000<r \le 100000<r≤10000），表示圆的半径。
输出格式

输出一行，包含三个数，分别表示圆的直径、周长、面积，数与数之间以一个空格分开，每个数保留小数点后 444 位。
输入输出样例
输入 #1

3.0

输出 #1

6.0000 18.8495 28.2743

code:
int main(){
    double n;
    cin>>n;
    printf("%.4f %.4f %.4f",2*n,2*3.14159*n,3.14159*n*n);
    return 0;
}

*/

/*
B2015 计算并联电阻的阻值

题目描述

对于阻值为 r1r1r1 和 r2r2r2 的电阻，其并联电阻阻值公式计算如下：R=1/(1/r1+1/r2)R=1/(1/r1+1/r2)R=1/(1/r1+1/r2)。输入两个电阻阻抗大小，浮点型。输出并联之后的阻抗大小，结果保留小数点后 222 位。
输入格式

两个电阻阻抗大小，浮点型，以一个空格分开。
输出格式

并联之后的阻抗大小，结果保留小数点后 222 位。
输入输出样例
输入 #1

1 2

输出 #1

0.67

code:
int main(){
    double n,m;
    cin>>n>>m;
    printf("%.2f",1/(1.0/n+1.0/m));
    return 0;
}

*/

/*
B2016 浮点数向零舍入

题目描述

输入一个单精度浮点数，将其向零舍入到整数。说明：向零舍入的含义是，正数向下舍入，负数向上舍入。
输入格式

一个单精度浮点数 xxx。
输出格式

一个整数，即向零舍入到整数的结果。
输入输出样例
输入 #1

2.3

输出 #1

2

说明/提示

?1015≤x≤1015-10^{15} \le x \le 10^{15}?1015≤x≤1015。

code:
int main(){
    double n;
    cin>>n;
    cout<<(long long)(n);//也可以直接cin long long
    return 0;
}

*/

/*
B2017 打印 ASCII 码

题目描述

输入一个除空格以外的可见字符，输出其 ASCII 码。
输入格式

一个除空格以外的可见字符。
输出格式

一个十进制整数，即该字符的 ASCII 码。
输入输出样例
输入 #1

A

输出 #1

65

code:
int main(){
    char c;
    cin>>c;
    cout<<(int)c;
    return 0;
}

*/

/*
B2018 打印字符

题目描述

输入一个 ASCII 码，输出对应的字符。
输入格式

一个整数，即字符的 ASCII 码，保证存在对应的可见字符。
输出格式

一行，包含相应的字符。
输入输出样例
输入 #1

65

输出 #1

A

说明/提示

保证所有数据 <128<128<128 并且 >0>0>0。

code:
int main(){
    int c;
    cin>>c;
    cout<<(char)c;
    return 0;
}

*/

/*
B2019 整型与布尔型的转换

题目描述

将一个整型变量的值赋给一个布尔型变量，再将这个布尔型变量的值赋给一个整型变量，得到的值是多少？
输入格式

一个整型范围内的整数，即初始时整型变量的值。
输出格式

一个整数，经过上述过程后得到的结果。
输入输出样例
输入 #1

3

输出 #1

1

code:
int main(){
    int c;
    cin>>c;
    c==0?cout<<0:cout<<1;
    return 0;
}

*/

/*
B2020 分糖果

题目描述

某个幼儿园里，有 555 位小朋友编号依次为 1,2,3,4,51,2,3,4,51,2,3,4,5 他们按照自己的编号顺序围坐在一张圆桌旁。他们身上有若干糖果，现在他们玩一个分糖果游戏。从 111 号小朋友开始，将自己的糖果均分成 333 份（如果有多余的糖果，就自己立即吃掉），自己留一份，其余两份分给和他相邻的两个小朋友。接着 2,3,4,52,3,4,52,3,4,5 号小朋友也这样做。问一轮结束后，每个小朋友手上分别有多少糖果。
输入格式

一行，555 个用空格隔开的 int 范围内的正整数，分别是游戏开始时 1,2,3,4,51,2,3,4,51,2,3,4,5 号小朋友手里糖果的数量。
输出格式

222 行，第 111 行是用一个空格隔开的 555 个整数，表示一轮游戏结束后 1,2,3,4,51,2,3,4,51,2,3,4,5 号小朋友手里糖果的数量。第 222 行是一个整数，表示一轮游戏过程中吃掉的糖果的总数。
输入输出样例
输入 #1

8 9 10 11 12

输出 #1

11 7 9 11 6
6

code:
int num[5],ans,t;
int main(){
	for(int i=0;i<5;i++) cin >> num[i];
	for(int i=0;i<5;i++){
		t=num[i]/3;
		ans+=num[i]%3;
		i==0?num[4]+=t:num[i-1]+=t;
        i==4?num[0]+=t:num[i+1]+=t;
		num[i]=t;
	}
	for(int i=0;i<5;i++)cout << num[i] << " ";
	cout << endl << ans << endl;
	return 0;
}

*/

/*
B2021 输出保留 3 位小数的浮点数

题目描述

读入一个单精度浮点数，保留 333 位小数输出这个浮点数。
输入格式

只有一行，一个单精度浮点数。
输出格式

也只有一行，读入的单精度浮点数。
输入输出样例
输入 #1

12.34521

输出 #1

12.345

code:
int main(){
    float n;
    cin>>n;
    printf("%.3f",n);
	return 0;
}

*/

/*
B2022 输出保留 12 位小数的浮点数

题目描述

读入一个双精度浮点数，保留 121212 位小数，输出这个浮点数。
输入格式

只有一行，一个双精度浮点数。
输出格式

也只有一行，保留 121212 位小数的浮点数。
输入输出样例
输入 #1

3.1415926535798932

输出 #1

3.141592653580

code:
int main(){
    double n;
    cin>>n;
    printf("%.12f",n);
	return 0;
}

*/

/*
B2023 空格分隔输出

题目描述

读入一个字符，一个整数，一个单精度浮点数，一个双精度浮点数，然后按顺序输出它们，并且要求在他们之间用一个空格分隔。输出浮点数时保留 666 位小数。
输入格式

第一行是一个字符；

第二行是一个整数；

第三行是一个单精度浮点数；

第四行是一个双精度浮点数。
输出格式

输出字符、整数、单精度浮点数和双精度浮点数，之间用空格分隔。
输入输出样例
输入 #1

a
12
2.3
3.2

输出 #1

a 12 2.300000 3.200000

code:
int main(){
    char c;
    int a;
    double n,m;
    cin>>c>>a>>n>>m;
    cout<<c<<" "<<a<<" ";
    printf("%.6f %.6f",n,m);
	return 0;
}

*/

/*
B2024 输出浮点数

题目描述

读入一个双精度浮点数，分别按输出格式 %f ，%f 保留 555 位小数，%e 和 %g 的形式输出这个整数，每次在单独一行上输出。
输入格式

一个双精度浮点数。
输出格式

第一行是按 %f 输出的双精度浮点数；

第二行是按 %f 保留 555 位小数输出的双精度浮点数；

第三行是按 %e 输出的双精度浮点数；

第四行是按 %g 输出的双精度浮点数。
输入输出样例
输入 #1

12.3456789

输出 #1

12.345679
12.34568
1.234568e+001
12.3457

code:
int main(){
    double n;
    cin>>n;
    printf("%f\n%.5f\n%e\n%g\n",n,n,n,n);
	return 0;
}

*/

/*
B2025 输出字符菱形

题目描述

用 * 构造一个对角线长 555 个字符，倾斜放置的菱形。
输入格式

没有输入要求。
输出格式

如样例所示。用 * 构成的菱形。
输入输出样例
输入 #1

输出 #1

  *
 ***
*****
 ***
  *

code:
int main(){
    printf(
  	"  *\n"
    " ***\n"
    "*****\n"
    " ***\n"
    "  *\n");
    return 0;
}

*/

/*
B2026 计算浮点数相除的余

题目描述

计算两个双精度浮点数 aaa 和 bbb 的相除的余数，aaa 和 bbb 都是双精度浮点数。这里余数（rrr）的定义是：a=k×b+ra=k \times b+ra=k×b+r，其中 kkk 是整数，0≤r<b0 \le r<b0≤r<b。
输入格式

输入仅一行，包括两个双精度浮点数 aaa 和 bbb。
输出格式

输出也仅一行，a/ba/ba/b 的余数。

选手输出与标准答案的绝对误差或相对误差不超过 10?510^{-5}10?5 即视为正确。
输入输出样例
输入 #1

73.263 0.9973

输出 #1

0.4601

code:
int main(){
    double n,m;
    cin>>n>>m;
    cout<<n-(int)(n/m)*m;
    return 0;
}

*/

/*
B2027 计算球的体积

题目描述

已知球半径为 rrr 时，球的体积为 V=43πr3V=\frac{4}{3}\pi r^3V=34?πr3。

小理手里有个半径为 rrr 的球体，他现在想知道这个球的体积为多少？

计算时，取 π=3.14\pi = 3.14π=3.14。
输入格式

输入共一行，其中包括一个正整数 rrr 表示球体的半径。
输出格式

输出共一行，其中包括球体的体积。要求保留小数点后555 位。
输入输出样例
输入 #1

5

输出 #1

523.33333

说明/提示

1≤r≤1001\leq r\leq 1001≤r≤100。

code:
int main(){
    double n;
    cin>>n;
    printf("%.5f",4.0/3*3.14*n*n*n);
    return 0;
}

*/

/*
B2028 反向输出一个三位数

题目描述

将一个三位数反向输出，例如输入 358358358，反向输出 853853853。
输入格式

一个三位数 nnn。
输出格式

反向输出 nnn。
输入输出样例
输入 #1

100

输出 #1

001

输入 #2

678

输出 #2

876

code:
int main(){
    int n;
    cin>>n;
    cout<<n%10<<n%100/10<<n/100;
    return 0;
}

*/

/*
B2029 大象喝水

题目描述

一只大象口渴了，要喝 202020 升水才能解渴，但现在只有一个深 hhh 厘米，底面半径为 rrr 厘米的小圆桶 （hhh 和 rrr 都是整数）。问大象至少要喝多少桶水才会解渴。
输入格式

输入有一行：包行两个整数，以一个空格分开，分别表示小圆桶的深 hhh 和底面半径 rrr，单位都是厘米。
输出格式

输出一行，包含一个整数，表示大象至少要喝水的桶数。
输入输出样例
输入 #1

23 11

输出 #1

3

说明/提示
数据规模与约定

对于全部的测试点，保证 1≤h≤5001 \leq h \leq 5001≤h≤500，1≤r≤1001 \leq r \leq 1001≤r≤100。

code:
int main(){
    int n,m;
    cin>>n>>m;
    cout<<20000/((int)(3.1415*m*m*n))+1;
    return 0;
}

*/

/*
B2030 计算线段长度
题目描述

已知线段的两个端点的坐标 A(Xa,Ya)，B(Xb ,Yb) ，求线段 AB 的长度。
输入格式

输入。

共两行。

第一行是两个实数 Xa，YaXa，YaXa，Ya，即 AAA 的坐标。

第二行是两个实数 Xb，YbXb，YbXb，Yb，即 BBB 的坐标。

输入中所有实数的绝对值均不超过 100001000010000。
输出格式

输出。

一个实数，即线段 ABABAB 的长度，保留到小数点后 333 位。
输入输出样例
输入 #1

1 1
2 2

输出 #1

1.414

code:
int main(){
    double xa,ya,xb,yb;
    cin>>xa>>ya>>xb>>yb;
    printf("%.3f",sqrt(abs(xa-xb)*abs(xa-xb)+abs(ya-yb)*abs(ya-yb)));
    return 0;
}

*/

/*
B2031 计算三角形面积

题目描述

平面上有一个三角形，它的三个顶点坐标分别为 (x1,y1),(x2,y2),(x3,y3)(x_1,y_1),(x_2,y_2),(x_3,y_3)(x1?,y1?),(x2?,y2?),(x3?,y3?)，那么请问这个三角形的面积是多少。
输入格式

输入仅一行，包括 666 个双精度浮点数，分别对应 x1,y1,x2,y2,x3,y3x_1,y_1,x_2,y_2,x_3,y_3x1?,y1?,x2?,y2?,x3?,y3?。
输出格式

输出也是一行，输出三角形的面积，精确到小数点后两位。
输入输出样例
输入 #1

0 0 4 0 0 3

输出 #1

6.00

code:
double x1,y1,x2,y2,x3,y3;//y1被万能头定义过 不能使用万能头
int main(){
    scanf("%lf%lf%lf%lf%lf%lf",&x1,&y1,&x2,&y2,&x3,&y3);
    printf("%.2lf\n",abs((x1-x3)*(y1-y3)-(x2-x3)*(y2-y3))/2);
    return 0;
}

*/

/*
B2032 等差数列末项计算

题目描述

等差数列是一个很有趣的数列，它的任何相邻两项的差相等。

现在给出一个等差数列的前两项 a1,a2a_1,a_2a1?,a2? 的值，求第 nnn 项是多少。
输入格式

一行，包含三个整数 a1,a2,na_1,a_2,na1?,a2?,n（?100≤a1,a2≤100-100 \le a_1,a_2 \le 100?100≤a1?,a2?≤100，0<n≤10000<n \le 10000<n≤1000。）
输出格式

一个整数，即第 nnn 项的值。
输入输出样例
输入 #1

1 4 100

输出 #1

298

code:
int main(){
    int a,b,n;
    cin>>a>>b>>n;
    cout<<a+(b-a)*(n-1);
    return 0;
}

*/

/*
B2033 A*B 问题

题目描述

输入两个正整数 AAA 和 BBB，求 A×BA \times BA×B 的值。注意乘积的范围和数据类型的选择。
输入格式

一行，包含两个正整数 AAA 和 BBB，中间用单个空格隔开。1≤A,B≤500001 \le A,B \le 500001≤A,B≤50000。
输出格式

一个整数，即 A×BA \times BA×B 的值。
输入输出样例
输入 #1

3 4

输出 #1

12

输入 #2

36 18

输出 #2

648

code:
int main(){
    long long a,b;//int会越界
    cin>>a>>b;
    cout<<a*b;
    return 0;
}

*/

/*
B2034 计算 2 的幂

题目描述

给定非负整数 nnn，求 2n2^n2n 的值。
输入格式

一个整数 nnn。0≤n<310\le n<310≤n<31。
输出格式

一个整数，即 222 的 nnn 次方。

请注意，如果您正在使用 cout 进行输出，您需要关注被输出的数据的类型。输出格式不符合预期可能会造成答案错误。

常用函数的返回值类型可以在 cppreference.com 和 cplusplus.com 查询到。例如，您可以在这两个网站中查到 pow 函数的返回值是 float 或 double。

您可以使用显式或隐式的类型转换，来变换数据类型。
输入输出样例
输入 #1

3

输出 #1

8

code:
int main(){
    int n;
    cin>>n;
    cout<<(long long)pow(2,n);//注意强转
    return 0;
}

*/

/*
B2035 判断数正负

题目描述

给定一个整数 NNN，判断其正负。如果 N>0N>0N>0, 输出 positive ; 如果 N=0N=0N=0, 输出 zero ; 如果 N<0,N<0,N<0, 输出 negative。
输入格式

一个整数 N(?109≤N≤109)N(-10^9 \le N \le 10^9)N(?109≤N≤109)。
输出格式

如果 N>0N>0N>0， 输出 positive;

如果 N=0N=0N=0, 输出 zero；

如果 N<0N<0N<0， 输出 negative。
输入输出样例
输入 #1

95

输出 #1

positive

code:
int main(){
    long long n;
    cin>>n;
    if(n>0)cout<<"positive";
    else if(n==0)cout<<"zero";
    else cout<<"negative";
    return 0;
}

*/

/*
B2036 输出绝对值

题目描述

输入一个浮点数 nnn，输出这个浮点数的绝对值。
输入格式

输入一个浮点数 nnn，其绝对值不超过 100001000010000。
输出格式

输出 nnn 的绝对值，保留到小数点后两位。
输入输出样例
输入 #1

-3.14

输出 #1

3.14

code:
int main(){
    double n;
    cin>>n;
    printf("%.2f",abs(n));
    return 0;
}

*/

/*
B2037 奇偶数判断

题目描述

给定一个整数，判断该数是奇数还是偶数。如果 nnn 是奇数，输出 odd；如果 nnn 是偶数，输出 even。
输入格式

输入仅一行，一个整数 nnn。
输出格式

输出仅一行，如果 nnn 是奇数，输出 odd；如果 nnn 是偶数，输出 even。
输入输出样例
输入 #1

5

输出 #1

odd

输入 #2

10

输出 #2

even

说明/提示

?100≤n≤100-100\le n\le 100?100≤n≤100

code:
int main(){
    long long n;
    cin>>n;
    n&0x0001?cout<<"odd":cout<<"even";
    return 0;
}

*/

/*
B2038 奇偶 ASCII 值判断

题目描述

任意输入一个字符，判断其 ASCII 是否是奇数，若是，输出 YES，否则，输出 NO 例如，字符 A 的 ASCII 值是 65，则输出 YES，若输入字符 B(ASCII 值是 666666)，则输出 NO。
输入格式

输入一个字符。
输出格式

如果其 ASCII 值为奇数，则输出 YES，否则，输出 NO。
输入输出样例
输入 #1

A

输出 #1

YES

输入 #2

B

输出 #2

NO

code:
int main(){
    char n;
    cin>>n;
    ((int)n)&0x0001?cout<<"YES":cout<<"NO";
    return 0;
}

*/

/*
B2039 整数大小比较

题目描述

输入两个整数，比较它们的大小。若 x>yx>yx>y ，输出 > ；若 x=yx=yx=y ，输出 = ；若 x<yx<yx<y，输出 < 。
输入格式

一行，包含两个整数 xxx 和 yyy ，中间用单个空格隔开。 0≤x<232,?231≤y<2310 \le x<2^{32}, -2^{31} \le y<2^{31}0≤x<232,?231≤y<231 。
输出格式

一个字符。若 x>yx>yx>y，输出 > ；若 x=yx=yx=y ，输出 = ；若 x<yx<yx<y ，输出 < ；
输入输出样例
输入 #1

1000 100

输出 #1

>

code:
int main(){
    long long n,m;
    cin>>n>>m;
    if(n==m)cout<<"=";
    else n>m?cout<<">":cout<<"<";
    return 0;
}

*/

/*
B2040 判断是否为两位数

题目描述

判断一个正整数是否是两位数（即大于等于 101010 且小于等于 999999）。
输入格式

一个正整数，不超过 100010001000。
输出格式

一行。若该正整数是两位数，输出 111，否则输出 000。
输入输出样例
输入 #1

54

输出 #1

1

code:#include<bits/stdc++.h>
using namespace std;
int main(){
    long long n;
    cin>>n;
    if(10<=n && n<=99)cout<<1;
    else cout<<0;
    return 0;
}

*/

/*
B2041 收集瓶盖赢大奖

题目描述

某饮料公司最近推出了一个“收集瓶盖赢大奖”的活动：如果你拥有 101010 个印有“幸运”、或 202020 个印有“鼓励”的瓶盖，就可以兑换一个神秘大奖。现分别给出你拥有的印有“幸运”和“鼓励”的瓶盖数，判断是否可以去兑换大奖。若可以兑换大奖，输出 1 ，否则输出 0 。
输入格式

一行，包含两个整数，分别是印有“幸运”和“鼓励”的瓶盖数，用一个空格隔开。
输出格式

一行。若可以兑换大奖，输出 111 ，否则输出 000。
输入输出样例
输入 #1

11 19

输出 #1

1

code:
int main(){
    long long n,m;
    cin>>n>>m;
    if(n>=10 || m>=20)cout<<1;
    else cout<<0;
    return 0;
}

*/

/*
B2042 判断一个数能否同时被 3 和 5 整除

题目描述

判断一个数 nnn 能否同时被 333 和 555 整除。
输入格式

输入一行，包含一个整数 nnn。
输出格式

输出一行，如果能同时被 333 和 555 整除输出 YES，否则输出 NO。
输入输出样例
输入 #1

15

输出 #1

YES

说明/提示

（?109<n<109-10^9<n<10^9?109<n<109）

code:
int main(){
    long long n;
    cin>>n;
    if(n%3==0 && n%5==0)cout<<"YES";
    else cout<<"NO";
    return 0;
}

*/

/*
B2043 判断能否被 3，5，7 整除

题目描述

给定一个整数 xxx，判断它能否被 333，555，777 整除，并输出以下信息：

1、能同时被 3,5,73,5,73,5,7 整除（直接输出 3 5 7，每个数中间一个空格）；

2、只能被其中两个数整除（按从小到大的顺序输出两个数，例如：3 5 或者 3 7 或者 5 7，中间用空格分隔）；

3、只能被其中一个数整除（输出这个除数）；

4、不能被任何数整除，输出小写字符 n。
输入格式

输入一行，包括一个整数 xxx。
输出格式

输出一行，按照描述要求给出整数被 333，555，777 整除的情况。
输入输出样例
输入 #1

105

输出 #1

3 5 7

说明/提示
数据规模与约定

对于全部的测试点，保证 1≤x≤2001 \leq x \leq 2001≤x≤200。

code:
int main(){
    int n;
    cin>>n;
    bool t=false;
    if(n%3==0)cout<<"3 ",t=true;
    if(n%5==0)cout<<"5 ",t=true;
    if(n%7==0)cout<<"7",t=true;
    if(t==false)cout<<"n";
    return 0;
}

*/

/*
B2044 有一门课不及格的学生

题目描述

给出一名学生的语文、数学、英语成绩，判断他是否恰好有一门课不及格（成绩小于 606060 分）。若该学生恰好有一门成绩不及格输出 111，否则输出 000。
输入格式

一行包含三个 0?1000 \sim 1000?100 之间的整数，分别表示该生的语文、数学、英语成绩。
输出格式

该学生恰好有一门成绩不及格输出 111，否则输出 000。
输入输出样例
输入 #1

59 60 61

输出 #1

1

code:
int n,sum;
int main(){
    while(cin>>n){
        if(n<60)sum++;
    }
    sum==1?cout<<1:cout<<0;
    return 0;
}

*/

/*
B2045 晶晶赴约会

题目描述

晶晶的朋友贝贝约晶晶下周一起去看展览，但晶晶每周的 1,3,51,3,51,3,5 有课必须上课，请帮晶晶判断她能否接受贝贝的邀请，如果能输出 YES；如果不能则输出 NO。
输入格式

输入有一行，贝贝邀请晶晶去看展览的日期，用数字 111 到 777 表示从星期一到星期日。
输出格式

输出有一行，如果晶晶可以接受贝贝的邀请，输出 YES，否则，输出 NO。注意 YES 和 NO 都是大写字母！
输入输出样例
输入 #1

2

输出 #1

YES

code:
int main(){
    int n;
    cin>>n;
    if(n==1 || n==3 || n==5)cout<<"NO";
    else cout<<"YES";
    return 0;
}

*/

/*
B2046 骑车与走路

题目描述

在清华校园里，没有自行车，上课办事会很不方便。但实际上。并非去办任何事情都是骑车快，因为骑车总要找车、开锁、停车、锁车等，这要耽误一些时间。假设找到自行车，开锁并车上自行车的时间为 272727 秒；停车锁车的时间为 232323 秒；步行每秒行走 1.21.21.2 米，骑车每秒行走 3.03.03.0 米。请判断走不同的距离去办事，是骑车快还是走路快。
输入格式

输入一行，包含一个整数，表示一次办事要行走的距离，单位为米。
输出格式

    如果骑车快，输出一行 Bike；

    如果走路快，输出一行 Walk；

    如果一样快，输出一行 All。

输入输出样例
输入 #1

1

输出 #1

Walk

code:
int main(){
    double length;
    cin>>length;
    if((1.0*length/1.2)==(1.0*length/3.0+23+27))cout<<"All";
    else ((1.0*length/1.2)>(1.0*length/3.0+23+27))?cout<<"Bike":cout<<"Walk";
    return 0;
}

*/

/*
B2047 分段函数

题目描述

编写程序，计算下列分段函数 y=f(x)y=f(x)y=f(x) 的值。

当 0≤x<50 \le x<50≤x<5 时，y=?x+2.5y=-x+2.5y=?x+2.5。

当 5≤x<105 \le x<105≤x<10 时，y=2?1.5(x?3)(x?3)y=2-1.5(x-3)(x-3)y=2?1.5(x?3)(x?3)。

当 10≤x<2010 \le x<2010≤x<20 时，y=x/2?1.5y=x/2-1.5y=x/2?1.5。
输入格式

一个浮点数 xxx。
输出格式

输出 xxx 对应的分段函数值：f(x)f(x)f(x)。结果保留到小数点后三位。
输入输出样例
输入 #1

1.0

输出 #1

1.500

说明/提示

对于 100% 的数据 0≤x<200 \le x<200≤x<20

code:
int main(){
    double x,y;
    cin>>x;
    if(0<=x && x<5)y=-x+2.5;
    else if(5<=x && x<10)y=2-1.5*(x-3)*(x-3);
    else if(10<=x && x<20)y=1.0*x/2.0-1.5;
    printf("%.3f",y); 
    return 0;
}

*/

/*
B2048 计算邮资

题目描述

请根据邮件的重量和用户选择是否加急计算邮费。计算规则：

    重量在 100010001000 以内（包括），基本费 888 元；

    超过 100010001000 克的部分，每 500500500 克加收超重费 444 元，不足 500500500 克部分按 500500500 克计算；

    如果用户选择加急，多收 555 元。

输入格式

一行，包含一个正整数 xxx 和一个字符 c(y 或 n)，之间用一个空格隔开，分别表示重量和是否加急。

如果字符是 y，说明选择加急；如果字符是 n，说明不加急。
输出格式

输出一行一个正整数，表示邮费。
输入输出样例
输入 #1

1200 y

输出 #1

17

说明/提示

对于100%数据 1≤x≤1061\leq x\leq 10^61≤x≤106

code:
int main(){
    long long x;
    cin>>x;
    char y;
    cin>>y;
    if(x<=1000)y=='y'?cout<<8+5:cout<<8;
    else y=='y'?cout<<(x+500)/500*4+5:cout<<(x+500)/500*4;
    return 0;
}

*/

/*
B2049 最大数输出

题目描述

输入三个整数，输出最大的数。
输入格式

输入为一行，包含三个整数，数与数之间以一个空格分开。
输出格式

输出一行，包含一个整数，即最大的整数。
输入输出样例
输入 #1

10 20 56

输出 #1

56

说明/提示
数据规模与约定

对于全部的测试点，保证输入的整数均在 32 位有符号整型 (int/long int) 范围内。

code:
int main(){//注意：未知正负
	int a, b, c;
	scanf("%d%d%d", &a, &b, &c);
	printf("%d", max(max(a, b), c)); 
	return 0;
}

*/

/*
B2050 三角形判断

题目描述

给定三个正整数，分别表示三条线段的长度，判断这三条线段能否构成一个三角形。
输入格式

输入共一行，包含三个正整数，分别表示三条线段的长度，数与数之间以一个空格分开。（三条边的长度均不超过 100001000010000）
输出格式

如果能构成三角形，则输出 1 ，否则输出 0。
输入输出样例
输入 #1

1 1 1

输出 #1

1

输入 #2

1 1 3

输出 #2

0

说明/提示

构成三角形的条件：

任意两边长度之和大于第三条边的长度。

code:
int main(){
	int a, b, c;
    cin>>a>>b>>c;
    (((max(max(a, b), c))*2)>=(a+b+c))?cout<<0:cout<<1;
	return 0;
}

*/

/*
B2051 点和正方形的关系

题目描述

有一个正方形，四个角的坐标（x,y)x,y)x,y) 分别是（1,?11,-11,?1），（1,11,11,1），（?1,?1-1,-1?1,?1），（?1,1-1,1?1,1），xxx 是横轴，yyy 是纵轴。写一个程序，判断一个给定的点是否在这个正方形内（包括正方形边界）。
输入格式

输入一行，包括两个整数 x,yx,yx,y，以一个空格分开，表示坐标 (x,y)(x,y)(x,y)。
输出格式

输出一行，如果点在正方形内，则输出 yes，否则输出 no。
输入输出样例
输入 #1

1 1

输出 #1

yes

code:
int x,y;
int main(){
    cin>>x>>y;
    (x>=-1&&x<=1&&y>=-1&&y<=1)?cout<<"yes":cout<<"no";
    return 0;
}

*/

/*
B2052 简单计算器

题目描述

一个最简单的计算器，支持 +,-,*,/ 四种运算。仅需考虑输入输出为整数的情况，数据和运算结果不会超过 int 表示的范围。然而：

    如果出现除数为 000 的情况，则输出：Divided by zero!。

    如果出现无效的操作符（即不为 +,-,*,/ 之一），则输出：Invalid operator!。

输入格式

输入只有一行，共有三个参数，其中第 1,21,21,2 个参数为整数，第 333 个参数为操作符（+,-,*,/）。
输出格式

输出只有一行，一个整数，为运算结果。然而：

    如果出现除数为 000 的情况，则输出：Divided by zero!。

    如果出现无效的操作符（即不为 +,-,*,/ 之一），则输出：Invalid operator!。

输入输出样例
输入 #1

1 2 +

输出 #1

3

输入 #2

2 4 *

输出 #2

8

输入 #3

5 0 /

输出 #3

Divided by zero!

code:
int main(){
	int a,b;
	char c;
	cin>>a>>b>>c;
	if(b==0&&c=='/')cout<<"Divided by zero!"<<endl;
	else if(c=='+')cout<<a+b<<endl;
	else if(c=='-')cout<<a-b<<endl;
	else if(c=='*')cout<<a*b<<endl;
	else if(c=='/')cout<<a/b<<endl;
	else cout<<"Invalid operator!"<<endl;
	return 0;
}

*/

/*
B2053 求一元二次方程

题目描述

利用公式 :

x1=?b+b2?4ac2a,x2=?b?b2?4ac2ax_1=\frac{-b+\sqrt{b^2-4ac}}{2a} , x_2=\frac{-b-\sqrt{b^2-4ac}}{2a}
x1?=2a?b+b2?4ac
??,x2?=2a?b?b2?4ac

??

求一元二次方程 ax2+bx+c=0ax^2+bx+c=0ax2+bx+c=0 的根，其中 aaa 不等于 000。结果要求精确到小数点后 555 位。
输入格式

输入一行，包含三个浮点数 a,b,ca,b,ca,b,c（它们之间以一个空格分开），分别表示方程 ax2+bx+c=0ax^2+bx+c=0ax2+bx+c=0 的系数。
输出格式

输出一行，表示方程的解。

若两个实根相等，则输出形式为：x1=x2=aaaa；

若两个实根不等，在满足根小者在前的原则，则输出形式为：x1=aaaa;x2=bbbb；

若无实根输出 No answer!。

所有输出部分要求精确到小数点后 555 位，数字、符号之间没有空格。
输入输出样例
输入 #1

-15.97 19.69 12.02

输出 #1

x1=-0.44781;x2=1.68075

code:
double a,b,c,delta,x1,x2;
int main() {
    cin>>a>>b>>c;
    delta=b*b-4*a*c;
    if (delta>0) {
        x1=(-b+sqrt(delta))/(2*a);
        x2=(-b-sqrt(delta))/(2*a);
        if (x1>x2) swap(x1,x2);
        printf("x1=%.5lf;x2=%.5lf",x1,x2);
    } else if (delta==0) {
        x1=(-b+sqrt(delta))/(2*a);
        x2=(-b-sqrt(delta))/(2*a);
        printf("x1=x2=%.5lf",x1);
    } else cout<<"No answer!";
    return 0;
}

*/

/*
B2054 求平均年龄

题目描述

班上有学生若干名，给出每名学生的年龄（整数），求班上所有学生的平均年龄，保留到小数点后两位。
输入格式

第一行有一个整数 nnn（1≤n≤1001 \le n \le 1001≤n≤100），表示学生的人数。其后 nnn 行每行有 111 个整数，表示每个学生的年龄，取值为 151515 到 252525。
输出格式

输出一行，该行包含一个浮点数，为要求的平均年龄，保留到小数点后两位。
输入输出样例
输入 #1

2
18
17

输出 #1

17.50

code:
int main() {
    int n,age,sum=0;
    cin>>n;
    for(int i=0;i<n;i++)cin>>age,sum+=age;
    printf("%.2f",1.0*sum/n);
    return 0;
}

*/

/*
B2055 均值

题目描述

给出一组样本数据，计算其均值。
输入格式

输入有两行，第一行包含一个整数，表示样本容量 nnn。
第二行包含 nnn 个浮点数 aia_iai?，代表各个样本数据。
输出格式

输出一行，包含一个浮点数，表示均值。

选手输出与标准输出的相对误差或绝对误差不超过 10?310^{-3}10?3 即视为正确。
输入输出样例
输入 #1

2
1.0 3.0

输出 #1

2.0000

说明/提示
数据规模与约定

对于全部的测试点，保证 1≤n≤1001 \leq n \leq 1001≤n≤100，OaiO≤104|a_i| \leq 10^4Oai?O≤104。

code:
int main() {
    int n;
    double age,sum=0;
    cin>>n;
    for(int i=0;i<n;i++)cin>>age,sum+=age;
    printf("%.4f",1.0*sum/n);
    return 0;
}

*/

/*
B2056 求整数的和与均值

题目描述

读入 n(1≤n≤10000)n(1 \le n \le 10000)n(1≤n≤10000) 个整数，求它们的和与均值。
输入格式

输入第一行是一个整数 nnn，表示有 nnn 个整数。

第 2?n+12 \sim n+12?n+1 行每行包含 111 个整数。每个整数的绝对值均不超过 100001000010000。
输出格式

输出一行，先输出和，再输出平均值（保留到小数点后 555 位），两个数间用单个空格分隔。
输入输出样例
输入 #1

4
344
222
343
222

输出 #1

1131 282.75000

code:
int main() {
    int n;
    double age,sum=0;
    cin>>n;
    for(int i=0;i<n;i++)cin>>age,sum+=age;
    printf("%d %.5f",(int)sum,1.0*sum/n);
    return 0;
}

*/

/*
B2057 最高的分数

题目描述

孙老师讲授的《计算概论》这门课期中考试刚刚结束，他想知道考试中取得的最高分数。因为人数比较多，他觉得这件事情交给计算机来做比较方便。你能帮孙老师解决这个问题吗？
输入格式

输入两行，第一行为整数 nnn（1≤n<1001 \le n<1001≤n<100），表示参加这次考试的人数。第二行是这 nnn 个学生的成绩，相邻两个数之间用单个空格隔开。所有成绩均为 000 到 100100100 之间的整数。
输出格式

输出一个整数，即最高的成绩。
输入输出样例
输入 #1

5
85 78 90 99 60

输出 #1

99

code:
int main() {
    int n,age,maxage=0;
    cin>>n;
    for(int i=0;i<n;i++)cin>>age,maxage=max(age,maxage);
    cout<<maxage;
    return 0;
}

*/

/*
B2058 奥运奖牌计数

题目描述

200820082008 年北京奥运会，A 国的运动员参与了 nnn 天的决赛项目 (1≤n≤100)(1 \le n \le 100)(1≤n≤100)。现在要统计一下 A 国所获得的金、银、铜牌数目及总奖牌数。输入第 111 行是 A 国参与决赛项目的天数 nnn，其后 nnn 行，每一行是该国某一天获得的金、银、铜牌数目（不超过 100)100)100)。输出 444 个整数，为 A 国所获得的金、银、铜牌总数及总奖牌数。
输入格式

第 111 行是 A 国参与决赛项目的天数 nnn，其后 nnn 行，每一行是该国某一天获得的金、银、铜牌数目，以一个空格分开。
输出格式

输出 111 行，包括 444 个整数，为 A 国所获得的金、银、铜牌总数及总奖牌数，以一个空格分开。
输入输出样例
输入 #1

3
1 0 3
3 1 0
0 3 0

输出 #1

4 4 3 11

code
int n,num[3],sum[3],all;
int main() {
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<3;j++)
            cin>>num[j],sum[j]+=num[j];
    for(int i=0;i<3;i++)
        cout<<sum[i]<<" ",all+=sum[i];
    cout<<all;
    return 0;
}

*/

/*
B2059 奇数求和

题目描述

计算非负整数 mmm 到 nnn（包括 mmm 和 nnn）之间的所有奇数的和，其中，mmm 不大于 nnn，且 nnn 不大于 300300300。例如 m=3,n=12,m=3,n=12,m=3,n=12, 其和则为：3+5+7+9+11=353+5+7+9+11=353+5+7+9+11=35。
输入格式

两个数 mmm 和 nnn，两个数以一个空格分开，其中 0≤m≤n≤3000 \le m \le n \le 3000≤m≤n≤300。
输出格式

输出一行，包含一个整数，表示 mmm 到 nnn（包括 mmm 和 nnn）之间的所有奇数的和。
输入输出样例
输入 #1

7 15

输出 #1

55

code:
int main(){
	int n,m,ans=0;
	cin >> n >> m;
	for(int i=n;i<=m;i++)
        if(i%2==1) 
            ans+=i;
	cout << ans;
	return 0;
}

*/

/*
B2060 满足条件的数累加

题目描述

将正整数 mmm 和 nnn 之间（包括 mmm 和 n)n)n) 能被 171717 整除的数累加，其中，0<m<n<10000<m<n<10000<m<n<1000。
输入格式

一行，包含两个整数 mmm 和 nnn，其间，以一个空格间隔。
输出格式

输出一行，包行一个整数，表示累加的结果。
输入输出样例
输入 #1

50 85

输出 #1

204

code:
int main(){
	int a,b,ans=0;
	cin>>a>>b;
	for(;a<=b;a++)
		if(a%17==0) 
            ans+=a;
    cout<<ans;
    return 0;
}

*/

/*
B2061 整数的个数

题目描述

给定 kkk（1<k<1001<k<1001<k<100）个正整数，其中每个数都是大于等于 111，小于等于 101010 的数。写程序计算给定的 kkk 个正整数中，111，555 和 101010 出现的次数。
输入格式

输入有两行：第一行包含一个正整数 kkk，第二行包含 kkk 个正整数，每两个正整数用一个空格分开。
输出格式

输出有三行，第一行为 111 出现的次数，，第二行为 555 出现的次数，第三行为 101010 出现的次数。
输入输出样例
输入 #1

5
1 5 8 10 5 

输出 #1

1
2
1

code:
int main(){
    int n;
    cin>>n;
    int num[n],sum;
    for(int i=0;i<n;i++)
        cin>>num[i];
    sum=0;
    for(int i=0;i<n;i++)
        if(num[i]==1)
            sum++;
    cout<<sum<<endl;
    sum=0;
    for(int i=0;i<n;i++)
        if(num[i]==5)
            sum++;
    cout<<sum<<endl;
    sum=0;
    for(int i=0;i<n;i++)
        if(num[i]==10)
            sum++;
    cout<<sum<<endl;
}

*/

/*
B2062 乘方计算

题目描述

给出一个整数 aaa 和一个正整数 nnn，求乘方 ana^nan。
输入格式

一行，包含两个整数 aaa 和 nnn。?1000000≤a≤1000000-1000000 \le a \le 1000000?1000000≤a≤1000000，1≤n≤100001 \le n \le 100001≤n≤10000。
输出格式

一个整数，即乘方结果。题目保证最终结果的绝对值不超过 100000010000001000000。
输入输出样例
输入 #1

2 3

输出 #1

8

code:
int main(){
    int n,m;
    cin>>n>>m;
    cout<<(long long)pow(n,m);
    return 0;
}

*/

/*
B2063 人口增长问题

题目描述

假设目前的世界人口有 xxx 亿，按照每年 0.1%0.1\%0.1% 的增长速度，nnn 年后将有多少人？
输入格式

一行两个正整数 xxx 和 nnn，之间有一个空格。其中，1≤x≤100,1≤n≤1001 \leq x\leq 100, 1\leq n\leq 1001≤x≤100,1≤n≤100。
输出格式

一行一个数，表示答案。以亿为单位，保留到小数点后 444 位。
输入输出样例
输入 #1

13 10

输出 #1

13.1306

code:
int main(){
    double x;
    int n;
    cin>>x>>n;
    for(int i=0;i<n;i++)
        x=1.0*x*(1+0.001);
    printf("%.4f",x);
    return 0;
}

*/

/*
B2064 斐波那契数列

题目描述

斐波那契数列是指这样的数列：数列的第一个和第二个数都为 111，接下来每个数都等于前面 222 个数之和。

给出一个正整数 aaa，要求斐波那契数列中第 aaa 个数是多少。
输入格式

第 111 行是测试数据的组数 nnn，后面跟着 nnn 行输入。每组测试数据占 111 行，包括一个正整数 aaa（1≤a≤301 \le a \le 301≤a≤30）。
输出格式

输出有 nnn 行，每行输出对应一个输入。输出应是一个正整数，为斐波那契数列中第 aaa 个数的大小。
输入输出样例
输入 #1

4
5
2
19
1

输出 #1

5
1
4181
1

code:
int fbnq[41];
int main(){
    int n,num;
    cin>>n;
    fbnq[1]=1;
    fbnq[2]=1;
    for(int i=3;i<=40;i++)
        fbnq[i]=fbnq[i-1]+fbnq[i-2];
    for(int i=0;i<n;i++)
        cin>>num,cout<<fbnq[num]<<endl;
    return 0;
}

*/

/*
B2065 鸡尾酒疗法

题目描述

鸡尾酒疗法，原指“高效抗逆转录病毒治疗”（HAART），由美籍华裔科学家何大一于 199619961996 年提出，是通过三种或三种以上的抗病毒药物联合使用来治疗艾滋病。该疗法的应用可以减少单一用药产生的抗药性，最大限度地抑制病毒的复制，使被破坏的机体免疫功能部分甚至全部恢复，从而延缓病程进展，延长患者生命，提高生活质量。

人们在鸡尾酒疗法的基础上又提出了很多种改进的疗法。为了验证这些治疗方法是否在疗效上比鸡尾酒疗法更好，可用通过临床对照实验的方式进行。

假设鸡尾酒疗法的有效率为 xxx，新疗法的有效率为 yyy，如果 y?xy-xy?x 大于 5%5\%5%，则效果更好，如果 x?yx-yx?y 大于 5%5\%5%，则效果更差，否则称为效果差不多。

下面给出 nnn 组临床对照实验，其中第一组采用鸡尾酒疗法，其他 n?1n-1n?1 组为各种不同的改进疗法。请写程序判定各种改进疗法效果如何。
输入格式

第一行为整数 nnn（1<n≤201<n \le 201<n≤20）；

其余 nnn 行每行两个整数，第一个整数是临床实验的总病例数（小于等于 10000)10000)10000)，第二个疗效有效的病例数。

这 nnn 行数据中，第一行为鸡尾酒疗法的数据，其余各行为各种改进疗法的数据。
输出格式

有 n?1n-1n?1 行输出，分别表示对应改进疗法的效果：

如果效果更好，输出 better；如果效果更差，输出 worse；否则输出 same。
输入输出样例
输入 #1

5
125 99
112 89
145 99
99 97
123 98

输出 #1

same
worse
better
same

code:
int n, a, b, c, d;
int main() {
    cin>>n>>a>>b;
    double x = 1.0 * b / a, y;
    while (n-- != 1) {
        cin>>c>>d;
        y = 1.0 * d / c;
        if(y - x >= 0.05) puts("better");
        else
            if(x - y >= 0.05) puts("worse");
            else puts("same");
    }
    return 0;
}

*/

/*
B2066 救援

题目描述

救生船从大本营出发，营救若干屋顶上的人回到大本营，屋顶数目以及每个屋顶的坐标。

和人数都将由输入决定，求出所有人都到达大本营并登陆所用的时间。

在直角坐标系的原点是大本营，救生船每次从大本营出发，救了人之后将人送回大本营。坐标系中的点代表屋顶，每个屋顶由其位置坐标和其上的人数表示。救生船每次从大本营出发，以速度 505050 米 / 分钟驶向下一个屋顶，达到一个屋顶后，救下其上的所有人，每人上船 111 分钟，船原路返回，达到大本营，每人下船 0.50.50.5 分钟。假设原点与任意一个屋顶的连线不穿过其它屋顶。
输入格式

第一行，一个整数，表示屋顶数 nnn。

接下来依次有 nnn 行输入，每一行上包含两个表示屋顶相对于大本营的平面坐标位置的实数（单位是米）、一个表示人数的整数，数之间以一个空格分开。
输出格式

一行，救援需要的总时间，精确到分钟（向上取整）。
输入输出样例
输入 #1

1
30 40 3

输出 #1

7

code:
int main(){
    int n,p;
    cin>>n;
    double x,y,dis,sum = 0;
    for (int i = 1; i <= n; i++){
        cin>>x>>y>>p;
        dis = sqrt(x * x + y * y);
        sum += dis / 50 + p + dis / 50 + p * 0.5;
    }
    printf("%d\n", int(ceil(sum)));
    return 0;
}

*/

/*
B2067 药房管理

题目描述

对药品的管理是其中的一项重要内容。现在药房的管理员希望使用计算机来帮助他管理。假设对于任意一种药品，每天开始工作时的库存总量已知，并且一天之内不会通过进货的方式增加。每天会有很多病人前来取药，每个病人希望取走不同数量的药品。如果病人需要的数量超过了当时的库存量，药房会拒绝该病人的请求。管理员希望知道每天会有多少病人没有取上药。
输入格式

共 333 行，第一行是每天开始时的药品总量 mmm。

第二行是这一天取药的人数 n(0<n≤100)n(0<n \le 100)n(0<n≤100)。

第三行共有 nnn 个数，分别记录了每个病人希望取走的药品数量（按照时间先后的顺序）。
输出格式

只有 111 行，为这一天没有取上药品的人数。
输入输出样例
输入 #1

30
6
10 5 20 6 7 8

输出 #1

2

code:
int main(){
    int n,m,person,sum=0;
    cin>>n>>m;
    for(int i=0;i<m;i++){
        cin>>person;
        if(person<=n)n-=person;
        else sum++;
    }
    cout<<sum;
    return 0;
}

*/

/*
B2068 统计满足条件的 4 位数

题目描述

给定若干个四位数，求出其中满足以下条件的数的个数：个位数上的数字减去千位数上的数字，再减去百位数上的数字，再减去十位数上的数字的结果大于零。
输入格式

输入为两行，第一行为四位数的个数 nnn，第二行为 nnn 个的四位数。(n≤100)(n \le 100)(n≤100)。
输出格式

输出为一行，包含一个整数，表示满足条件的四位数的个数。
输入输出样例
输入 #1

5
1234 1349 6119 2123 5017

输出 #1

3

code:
int main(){
    int n,num,sum=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>num;
        if((num%10)>(num/10%10+num/100%10+num/1000))
            sum++;
    }
    cout<<sum;
    return 0;
}

*/

/*
B2069 求分数序列和

题目描述

有一个分数序列 q1p1,q2p2,q3p3,q4p4,q5p5,...\frac{q_{1}}{p_{1}},\frac{q_{2}}{p_{2}},\frac{q_{3}}{p_{3}},\frac{q_{4}}{p_{4}},\frac{q_{5}}{p_{5}},...p1?q1??,p2?q2??,p3?q3??,p4?q4??,p5?q5??,...,其中qi+1=qi+piq_{i+1}=q_{i}+p_{i}qi+1?=qi?+pi?, pi+1=qi,p1=1,q1=2 p_{i+1}=q_{i},p_{1}=1,q_{1}=2pi+1?=qi?,p1?=1,q1?=2。比如这个序列前6项分别是21,32,53,85,138,2113\frac{2}{1},\frac{3}{2},\frac{5}{3},\frac{8}{5},\frac{13}{8},\frac{21}{13}12?,23?,35?,58?,813?,1321?。求这个分数序列的前n项之和。
输入格式

输入有一行，包含一个正整数 n(n?30)n(n\leqslant30)n(n?30)。
输出格式

输出有一行，包含一个浮点数，表示分数序列前 nnn 项的和，精确到小数点后 444 位。
输入输出样例
输入 #1

2

输出 #1

3.5000

code:
int num[32],n;
double sum;
int main(){
    cin>>n;
    num[0]=1;
    num[1]=1;
    for(int i=1;i<=n;i++){
        num[i+1]=num[i]+num[i-1];
        sum+=1.0*num[i+1]/num[i];
    }
    printf("%.4f",sum);
    return 0;
}

*/

/*
B2070 计算分数加减表达式的值

题目描述

Sn=11?12+13?14+15?16+...+(?1)n?1×1nS_n=\frac{1}{1}-\frac{1}{2}+\frac{1}{3}-\frac{1}{4}+\frac{1}{5}-\frac{1}{6}+...+(-1)^{n-1}\times\frac{1}{n}Sn?=11??21?+31??41?+51??61?+...+(?1)n?1×n1?。

输入一个整数 nnn，求 SnS_nSn?。
输入格式

输入为一行，含一个正整数 nnn。
输出格式

输出为一行，为 SnS_nSn? 的值，结果保留小数点后 444 位小数。
输入输出样例
输入 #1

2

输出 #1

0.5000

说明/提示

1≤n≤10001\leq n\leq 10001≤n≤1000。

code:
int main(){
    int n;
    double sum=0;
    cin>>n;
    for(int i=1;i<=n;i++)
        sum+=1.0/i*pow(-1,i+1);
    printf("%.4f",sum);
    return 0;
}

*/

/*
B2071 余数相同问题

题目描述

已知三个正整数 aaa，bbb，ccc。现有一个大于 111 的整数 xxx，将其作为除数分别除 aaa，bbb，ccc，得到的余数相同。

请问满足上述条件的 xxx 的最小值是多少？数据保证 xxx 有解。
输入格式

一行，三个不大于 100000010000001000000 的正整数 aaa，bbb，ccc，两个整数之间用一个空格隔开。
输出格式

一个整数，即满足条件的 xxx 的最小值。
输入输出样例
输入 #1

300 262 205

输出 #1

19

code:
int main(){
    int a,b,c;
    cin>>a>>b>>c;
    for(int i=2;;i++)
        if(a%i==b%i && a%i==c%i){
            cout<<i;
            return 0;
        }
}

*/

/*
B2072 分苹果

题目描述

把一堆苹果分给 nnn 个小朋友，要使每个人都能拿到苹果，而且每个人拿到的苹果数都不同的话，这堆苹果至少应该有多少个？
输入格式

一个不大于 100010001000 的正整数 nnn，代表小朋友人数。
输出格式

一个整数，表示满足条件的最少苹果个数。
输入输出样例
输入 #1

8

输出 #1

36

code:
int main(){
    int n,sum=0;
    cin>>n;
    for(int i=1;i<=n;i++)
        sum+=i;
    cout<<sum;
}

*/

/*
B2073 求小数的某一位

题目描述

分数 ab\dfrac{a}{b}ba? 化为小数后，小数点后第 nnn 位的数字是多少？
输入格式

三个正整数 aaa，bbb，nnn，相邻两个数之间用单个空格隔开。0<a≤b≤1000<a\le b\le1000<a≤b≤100，1≤n≤100001 \le n \le 100001≤n≤10000。
输出格式

一个数字。
输入输出样例
输入 #1

1 2 1

输出 #1

5

code:
int main(){
    int a,b,n;
    cin>>a>>b>>n;
	for(int i=1;i<=n;i++) a%=b,a*=10;
	a/=b;
    cout<<a;
    return 0;
}

*/

/*
B2074 计算星期几

题目描述

假设今天是星期日，那么过 aaa 的 bbb 次方天之后是星期几？
输入格式

两个正整数 aaa，bbb，中间用单个空格隔开。0<a≤100,0<b≤100000<a≤100,0<b≤100000<a \le 100,0<b \le 100000<a \le 100,0<b \le 100000<a≤100,0<b≤100000<a≤100,0<b≤10000。
输出格式

一个字符串，代表过 aaa 的 bbb 次方天之后是星期几。

其中，Monday 是星期一，Tuesday 是星期二，Wednesday 是星期三，Thursday 是星期四，Friday 是星期五，Saturday 是星期六，Sunday 是星期日。
输入输出样例
输入 #1

3 2000

输出 #1

Tuesday

code:
int a,b,ans=1;
int main(){
	cin>>a>>b;
	a%=7;
	for(int i=1;i<=b;i++)
		ans*=a,ans%=7;
	if(ans==0)cout<<"Sunday";
	if(ans==1)cout<<"Monday";
	if(ans==2)cout<<"Tuesday";
	if(ans==3)cout<<"Wednesday";
	if(ans==4)cout<<"Thursday";
	if(ans==5)cout<<"Friday";
	if(ans==6)cout<<"Saturday";
	return 0;
}

*/

/*
B2075 幂的末尾

题目描述

幂 aba^bab 的末 333 位数是多少？
输入格式

两个正整数 aaa，bbb。1≤a≤1001 \le a \le 1001≤a≤100，1≤b≤100001 \le b \le 100001≤b≤10000。
输出格式

从高位到低位输出幂的末三位数字，中间无分隔符。若幂本身不足三位，在前面补零。
输入输出样例
输入 #1

2 3

输出 #1

008

输入 #2

7 2011

输出 #2

743

code:
long long a, b, s = 1;
int main(){
    cin >> a >> b;
    for(int i = 0;i < b;i++)
        s *= a, s %= 1000;
    printf("%03lld", s);//输出方式很精妙
    return 0;
}

*/

/*
B2076 球弹跳高度的计算

题目描述

一球从某一高度落下（整数，单位米），每次落地后反跳回原来高度的一半，再落下。

编程计算气球在第 101010 次落地时，共经过多少米？第 101010 次反弹多高？
输入格式

输入一个整数 hhh，表示球的初始高度。
输出格式

输出包含两行：

第 111 行：到球第 101010 次落地时，一共经过的米数。

第 222 行：第 101010 次弹跳的高度。

注意：结果可能是实数，结果用 double 类型保存。

提示：输出时不需要对精度特殊控制，用 cout<<ANSWER，或者 printf("%g",ANSWER) 即可。
输入输出样例
输入 #1

20

输出 #1

59.9219
0.0195313

code:
double h;
int main(){
    cin>>h;
	printf("%lf %lf",h*767.0/256.0,h/1024.0); //等比推算公式
	return 0;
}

*/

/*
B2077 角谷猜想

题目描述

所谓角谷猜想，是指对于任意一个正整数，如果是奇数，则乘 333 加 111，如果是偶数，则除以 222，得到的结果再按照上述规则重复处理，最终总能够得到 111。如，假定初始整数为 555，计算过程分别为 161616 、 888 、 444 、 222 、 111。

程序要求输入一个整数，将经过处理得到 111 的过程输出来。
输入格式

一个正整数 N(N≤2,000,000)N(N \le 2,000,000)N(N≤2,000,000)。
输出格式

从输入整数到 111 的步骤，每一步为一行，每一部中描述计算过程。最后一行输出 End。如果输入为 111，直接输出 End。
输入输出样例
输入 #1

5

输出 #1

5*3+1=16
16/2=8
8/2=4
4/2=2
2/2=1
End

code:
int main() {
	int n;
    cin>>n;
	while(n != 1)
		if(n & 1) {
			printf("%d*3+1=%d\n", n, n * 3 + 1);
			n = n * 3 + 1;
		} else {
			printf("%d/2=%d\n", n, n / 2);
			n /= 2;
		}
	printf("End");
	return 0;
}

*/

/*
B2078 含 k 个 3 的数

题目描述

输入两个正整数 mmm 和 kkk，其中 1<m≤10151 \lt m \leq 10^{15}1<m≤1015，1<k≤151 \lt k \leq 151<k≤15 ，判断 mmm 是否恰好含有 kkk 个 333，如果满足条件，则输出 YES，否则，输出 NO。
输入格式

输入一行，为两个整数 m,km,km,k，中间用单个空格间隔。
输出格式

满足条件，则输出 YES，否则，输出 NO。
输入输出样例
输入 #1

43833 3

输出 #1

YES

code:
int main() {
    long long n,sum=0;
    cin>>n;
    while(n){
        if(n%10==3)sum++;
        n/=10;
    }
    cin>>n;
    n==sum?cout<<"YES":cout<<"NO";
	return 0;
}

*/

/*
B2079 求出 e 的值

题目描述

利用公式 e=1+1/1!+1/2!+1/3!+?+1/n!e=1+1/1!+1/2!+1/3!+ \cdots +1/n!e=1+1/1!+1/2!+1/3!+?+1/n!，求 eee 的值，要求保留小数点后 101010 位。
输入格式

输入只有一行，该行包含一个整数 nnn，表示计算 eee 时累加到 1/n!1/n!1/n!。
输出格式

输出只有一行，该行包含计算出来的 eee 的值，要求打印小数点后 101010 位。
输入输出样例
输入 #1

10

输出 #1

2.7182818011

说明/提示

2≤n≤152 \le n \le 152≤n≤15。

code:
int main(){
	int n;
	double e=1.0,sum=1.0;
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		e*=i,sum+=1/e;
	printf("%0.10lf",sum);
	return 0;
}

*/

/*
B2080 计算多项式的值

题目描述

假定多项式的形式为 xn+x(n?1)+x^n+x^{(n-1)}+xn+x(n?1)+ … +x2+x+1+x^2+x+1+x2+x+1，请计算给定单精度浮点数 xxx 和正整数 nnn 值的情况下这个多项式的值。多项式的值精确到小数点后两位，保证最终结果在 double 范围内。
输入格式

输入仅一行，包括 xxx 和 nnn，用单个空格隔开。
输出格式

输出一个实数，即多项式的值，精确到小数点后两位。保证最终结果在 double 范围内。
输入输出样例
输入 #1

2.0 4

输出 #1

31.00

说明/提示

xxx 在 double 范围内，n≤1000000n \le 1000000n≤1000000。

code:
double x,ans = 1;
int n;
int main(){
	cin >> x >> n;
	for (int i = 1;i <= n; ++ i)
		ans += pow (x,i);
	printf ("%.2f\n",ans);
	return 0;
}

*/

/*
B2081 与 7 无关的数

题目描述

一个正整数，如果它能被 777 整除，或者它的十进制表示法中某一位上的数字为 777，则称其为与 777 相关的数。现求所有小于等于 n(n<100)n(n<100)n(n<100) 与 777 无关的正整数的平方和。
输入格式

输入为一行，正整数 n(n<100)n(n<100)n(n<100)。
输出格式

输出一行，包含一个整数，即小于等于 nnn 的所有与 777 无关的正整数的平方和。
输入输出样例
输入 #1

21

输出 #1

2336

code:
int main(){
    long long n,ans;
    cin>>n;
    for(int i=1;i<=n;i++)
        if(!(i%7==0||i%10==7||i/10%10==7))ans+=i*i;
    cout<<ans;
}

*/

/*
B2082 数字统计

题目描述

请统计某个给定范围 [L,R][L,R][L,R] 的所有整数中，数字 222 出现的次数。

比如给定范围 [2,22][2,22][2,22]，数字 222 在数 222 中出现了 111 次，在数 121212 中出现 111 次，在数 202020 中出现 111 次，在数 212121 中出现 111 次，在数 222222 中出现 222 次，所以数字 222 在该范围内一共出现了 666 次。
输入格式

输入共 111 行，为两个正整数 LLL 和 RRR，之间用一个空格隔开。
输出格式

输出共 111 行，表示数字 222 出现的次数。
输入输出样例
输入 #1

2 22

输出 #1

6

输入 #2

2 100

输出 #2

20

说明/提示

1<L,R<100001<L,R<100001<L,R<10000。

code:
int L,R,c,ans,i;
int main(){
    cin>>L>>R;
    for(i=L;i<=R;i++){
        c=i;
        while(c){
            if(c%10==2)ans++;
            c=c/10;
        }
    }
    cout<<ans;
    return 0;
}

*/

/*
B2083 画矩形

题目描述

根据输入的四个参数：a,b,c,fa,b,c,fa,b,c,f 参数，画出对应的矩形。

前两个参数 a,ba,ba,b 为整数，依次代表矩形的高和宽；

第三个参数 ccc 是一个字符，表示用来填充的矩形符号；

第四个参数f为 111 或 000，000 代表空心，111 代表实心。 具体例子请见样例。
输入格式

第一行：a,b,c,f。
输出格式

一个矩形。
输入输出样例
输入 #1

7 7 @ 0

输出 #1

@@@@@@@
@     @
@     @
@     @
@     @
@     @
@@@@@@@

说明/提示

数据范围：

3≤a≤1003 \le a \le 1003≤a≤100。

5≤b≤1005 \le b \le 1005≤b≤100。

ccc 是一个可见的字符。

0≤f≤1000 \le f \le 1000≤f≤100。

code:#include<bits/stdc++.h>
using namespace std;
int a, b, f;
char c;
int main(){
    cin>>a>>b>>c>>f;
	for (int i = 0; i < a; i++){
		for (int j = 0; j < b; j++){
			if (i != 0 && i != a - 1 && j != 0 && j != b - 1) printf("%c", f == 0?' ':c); 
			else printf("%c", c);
		}
        cout<<endl;
	}
	return 0;
}

*/

/*
B2084 质因数分解

题目描述

已知正整数 nnn 是两个不同的质数的乘积，试求出较大的那个质数。
输入格式

输入只有一行，包含一个正整数 nnn（6<n<1096<n<10^96<n<109）。
输出格式

输出只有一行，包含一个正整数 ppp，即较大的那个质数。
输入输出样例
输入 #1

21

输出 #1

7

code:
int main() {
    int n;
    cin>>n;
    for(int i=2;i<=n;i++) 
    	if(n%i==0) { 
      	    cout<<n/i<<endl;
            return 0;
    	}
}

*/

/*
B2085 第 n 小的质数

题目描述

输入一个正整数 nnn，求正整数范围中第 nnn 小的质数。
输入格式

一个不超过 300003000030000 的正整数 nnn。
输出格式

第 nnn 小的质数。
输入输出样例
输入 #1

10

输出 #1

29

code:
int main(){
	int n,sum=0;
    cin>>n;
	for(int i=2;n;i++){
		bool flag=1;
		for(int j=2;j*j<=i;j++){
			if(i%j==0){
				flag=0;
				break;
			}
		}
		if(flag){
			n--;
			sum=i;
		}
	}
    cout<<sum;
	return 0;
}

*/

/*
B2086 不定方程求解

题目描述

给定正整数 aaa，bbb，ccc。求不定方程 ax+by=cax+by=cax+by=c 关于未知数 xxx 和 yyy 的所有非负整数解组数。
输入格式

一行，包含三个正整数 aaa，bbb，ccc，两个整数之间用单个空格隔开。每个数均不大于 100010001000。
输出格式

一个整数，即不定方程的非负整数解组数。
输入输出样例
输入 #1

2 3 18

输出 #1

4

code:
int main(){
	int a, b, c, y, cnt = 0;
	cin >> a >> b >> c;
	for (int x = 0; x <= c / a; x ++)
		if (a * x + b *(int)((c - a * x) / b)== c) 
            cnt ++;
	cout << cnt;
	return 0;
}

*/

/*
B2087 与指定数字相同的数的个数

题目描述

输出一个整数序列中与指定数字相同的数的个数。
输入格式

输入包含三行：

第一行为 nnn，表示整数序列的长度（n≤100n\le100n≤100）；

第二行为 nnn 个整数，整数之间以一个空格分开；

第三行包含一个整数，为指定的整数 mmm。
输出格式

输出为 nnn 个数中与 mmm 相同的数的个数。
输入输出样例
输入 #1

3
2 3 2
2

输出 #1

2

code:
int main(){
    int n,sum=0;
    cin>>n;
    int a[n],b;
    for(int i=0;i<n;i++)
        cin>>a[i];
    cin>>b;
    for(int i=0;i<n;i++)
        if(a[i]==b)
            sum++;
    cout<<sum;
	return 0;
}

*/

/*
B2088 计算书费

题目描述

下面是一个图书的单价表：

    计算概论 28.9 元/本
    数据结构与算法 32.7 元/本
    数字逻辑 45.6元/本
    C++程序设计教程 78 元/本
    人工智能 35 元/本
    计算机体系结构 86.2 元/本
    编译原理 27.8元/本
    操作系统 43 元/本
    计算机网络 56 元/本
    JAVA程序设计 65 元/本

依次给定每种图书购买的数量，编程计算应付的总费用。
输入格式

输入一行，含 101010 个非负整数，每两个整数之间有一个空格。

第 iii 个整数表示要购买上述第 iii 种图书的数量（数量不超过 100100100，以本为单位，iii 分别为 1,2,3,??,101,2,3, \cdots ,101,2,3,?,10）。
输出格式

输出一行，包含一个实数，表示应付的总费用。精确到小数点后一位。
输入输出样例
输入 #1

1 5 8 10 5 1 1 2 3 4

输出 #1

2140.2

code:
float a[10]={28.9,32.7,45.6,78,35,86.2,27.8,43,56,65},x=0;
int main(){
    int i,num;
    for (i=0;i<10;i++)
        cin >> num,x += num*a[i];
    cout << fixed  << setprecision(1) << x;
    return 0;
}

*/

/*
B2089 数组逆序重存放

题目描述

将一个数组中的值按逆序重新存放。例如，原来的顺序为 8,6,5,4,18,6,5,4,18,6,5,4,1。要求改为 1,4,5,6,81,4,5,6,81,4,5,6,8。
输入格式

输入为两行：第一行数组中元素的个数 nnn（1<n≤1001 \lt n \le 1001<n≤100)，第二行是 nnn 个整数，每两个整数之间用空格分隔。
输出格式

输出为一行：输出逆序后数组的整数，每两个整数之间用空格分隔。
输入输出样例
输入 #1

5
8 6 5 4 1

输出 #1

1 4 5 6 8

code:
int main(){
    int n;
    cin>>n;
    int num[n];
    for(int i=0;i<n;i++)
        cin>>num[i];
    for(int i=0;i<n;i++)
        cout<<num[n-i-1]<<" ";
    return 0;
}

*/

/*
B2090 年龄与疾病

题目描述

某医院进行一项研究，想知道某项疾病是否与年龄有关。因此对以往的诊断记录进行整理，统计 0-18 、 19-35 、 36-60、 61 及以上这四个年龄段的患者人数占总患者人数的比例。
输入格式

输入共 222 行。

第一行包含一个整数 NNN（0<n≤1000<n \le 1000<n≤100），表示总患者人数。

第二行包含 NNN 个整数，代表这 NNN 个患者就诊时的年龄。
输出格式

输出共 444 行。

第 111 行包含一个百分数，这个百分数保留小数点后 222 位，代表 0?180-180?18 岁这个年龄段的患者人数占总患者人数的比例。

第 222 行包含一个百分数，这个百分数保留小数点后 222 位，代表 19?3519-3519?35 岁这个年龄段的患者人数占总患者人数的比例。

第 333 行包含一个百分数，这个百分数保留小数点后 222 位，代表 36?6036-6036?60 岁这个年龄段的患者人数占总患者人数的比例。

第 444 行包含一个百分数，这个百分数保留小数点后 222 位，代表 616161 岁及以上这个年龄段的患者人数占总患者人数的比例。
输入输出样例
输入 #1

10
1 11 21 31 41 51 61 71 81 91

输出 #1

20.00%
20.00%
20.00%
40.00%

输入 #2

12
10 19 86 94 58 57 34 19 88 69 5 13

输出 #2

25.00%
25.00%
16.67%
33.33%

code:
int a[5],n,c;
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>c;
		if(c<=18)        a[1]++;
		else if(19<=c&&c<=35) a[2]++;
		else if(36<=c&&c<=60) a[3]++;
		else if(c>60)         a[4]++;
	}
	printf("%.2lf%%\n%.2lf%%\n%.2lf%%\n%.2lf%%\n",double(a[1])/n*100,double(a[2])/n*100,double(a[3])/n*100,double(a[4])/n*100);
 	return 0;
}

*/

/*
B2091 向量点积计算

题目描述

在线性代数、计算几何中，向量点积是一种十分重要的运算。

给定两个 nnn 维向量 a=(a1,a2,??,an)a=(a_1,a_2, \cdots ,a_n)a=(a1?,a2?,?,an?) 和 b=(b1,b2,??,bn)b=(b_1,b_2, \cdots ,b_n)b=(b1?,b2?,?,bn?)，求点积 aaa ・ b=a1b1+a2b2+?+anbnb=a_1b_1+a_2b_2+ \cdots +a_nb_nb=a1?b1?+a2?b2?+?+an?bn?。
输入格式

第一行是一个整数 nnn。1≤n≤10001 \le n \le 10001≤n≤1000。

第二行包含 nnn 个整数 a1,a2,??,ana_1,a_2, \cdots ,a_na1?,a2?,?,an?。

第三行包含 nnn 个整数 b1,b2,??,bnb_1,b_2, \cdots ,b_nb1?,b2?,?,bn?。

相邻整数之间用单个空格隔开。每个整数的绝对值都不超过 100010001000。
输出格式

一个整数，即两个向量的点积结果。
输入输出样例
输入 #1

3
1 4 6
2 1 5

输出 #1

36

code:
int n,sum; 
int main(){
	cin>>n;
    int a[n],b[n];
	for(int i=0;i<n;i++)
		cin>>a[i];
	for(int i=0;i<n;i++)
		cin>>b[i];
	for(int i=0;i<n;i++)
		sum+=a[i]*b[i];
	cout<<sum<<endl;
	return 0;
}

*/

/*
B2092 开关灯

题目描述

假设有 NNN 盏灯（NNN 为不大于 500050005000 的正整数），从 111 到 NNN 按顺序依次编号，初始时全部处于开启状态；第一个人（111 号）将灯全部关闭，第二个人（222 号）将编号为 222 的倍数的灯打开，第三个人（333 号）将编号为 333 的倍数的灯做相反处理（即，将打开的灯关闭，将关闭的灯打开）。依照编号递增顺序，以后的人都和 333 号一样，将凡是自己编号倍数的灯做相反处理。问当第 NNN 个人操作完之后，有哪些灯是关闭着的？
输入格式

输入为一行，一个整数 NNN，为灯的数量。
输出格式

输出为一行，按顺序输出关着的灯的编号。编号与编号之间间隔一个空格。
输入输出样例
输入 #1

10

输出 #1

1 4 9

输入 #2

5

输出 #2

1 4

code:
int main(){
	int n;
	cin>>n;
	for(int i=1;i*i<=n;i++) 
        cout<<i*i<<" ";
	return 0;
}

*/

/*
B2093 查找特定的值

题目描述

在一个序列（下标从 000 开始）中查找一个给定的值，输出第一次出现的位置。
输入格式

第一行包含一个正整数 nnn，表示序列中元素个数。1≤n≤100001 \le n \le 100001≤n≤10000。

第二行包含 nnn 个整数，依次给出序列的每个元素，相邻两个整数之间用单个空格隔开。元素的绝对值不超过 100001000010000。

第三行包含一个整数 xxx，为需要查找的特定值。xxx 的绝对值不超过 100001000010000。
输出格式

若序列中存在 xxx，输出 xxx 一次出现的下标； 否则输出 -1。
输入输出样例
输入 #1

5
2 3 6 7 3
3

输出 #1

1

code:
int a[10007],n,x;
int main(){
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>a[i];
    cin>>x;
    for(int i=0;i<n;i++)
        if(a[i]==x){
            cout<<i;
            return 0;
        }
    cout<<-1;
    return 0;
}

*/

/*
B2094 不与最大数相同的数字之和

题目描述

输出一个整数数列中不与最大数相同的数字之和。
输入格式

输入分为两行：

第一行为 N(NN(NN(N 为接下来数的个数，N≤100)N \le 100)N≤100)；

第二行为 NNN 个整数，数与数之间以一个空格分开，每个整数的范围是 ?1000,000-1000,000?1000,000 到 1000,0001000,0001000,000。
输出格式

输出为 NNN 个数中除去最大数其余数字之和。
输入输出样例
输入 #1

3
1 2 3 

输出 #1

3

code:
int main(){
    int n,top=-1000000,sum=0;
    cin>>n;
    int num[n];
    for(int i=0;i<n;i++){
        cin>>num[i];
        top=max(num[i],top);
    }
    for(int i=0;i<n;i++){
        if(num[i]==top)continue;
        sum+=num[i];
    }
    cout<<sum;
    return 0;
}

*/

/*
B2095 白细胞计数

题目描述

医院采样了某临床病例治疗期间的白细胞数量样本 nnn 份，用于分析某种新抗生素对该病例的治疗效果。为了降低分析误差，要先从这 nnn 份样本中去除一个数值最大的样本和一个数值最小的样本，然后将剩余 n?2n-2n?2 个有效样本的平均值作为分析指标。同时，为了观察该抗生素的疗效是否稳定，还要给出该平均值的误差，即所有有效样本（即不包括已扣除的两个样本）与该平均值之差的绝对值的最大值。

现在请你编写程序，根据提供的 nnn 个样本值，计算出该病例的平均白细胞数量和对应的误差。
输入格式

输入的第一行是一个正整数 nnn（2<n≤3002<n \le 3002<n≤300），表明共有 nnn 个样本。

以下共有 nnn 行，每行为一个浮点数，为对应的白细胞数量，其单位为 109/L10^9/L109/L。数与数之间以一个空格分开。
输出格式

输出为两个浮点数，中间以一个空格分开。分别为平均白细胞数量和对应的误差，单位也是 109/L10^9/L109/L。计算结果需保留到小数点后 222 位。
输入输出样例
输入 #1

5
12.0
13.0
11.0
9.0
10.0

输出 #1

11.00 1.00

code:
int main(){
	int n;
	cin >> n;
	double a[n],num = 0,b;
	for(int i = 0;i < n;i++) 
        cin >> a[i];
	sort(a,a+n);
	for(int i = 1;i < n - 1;i++) 
        num += a[i];
    b = num / (n - 2);
	printf("%.2lf %.2lf",b,max((b - a[1]),(a[n - 2] - b)));
	return 0;
}

*/

/*
B2096 直方图

题目描述

给定一个非负整数数组，统计里面每一个数的出现次数。我们只统计到数组里最大的数。

假设 Fmax（Fmax≤100000）Fmax（Fmax \le 100000）Fmax（Fmax≤100000）是数组里最大的数，那么我们只统计 {0,1,2…Fmax}\{0,1,2 \ldots Fmax \}{0,1,2…Fmax} 里每个数出现的次数。
输入格式

第一行 nnn 是数组的大小。1≤n≤1000001 \le n \le 1000001≤n≤100000。

紧接着一行是数组的 nnn 个元素。
输出格式

按顺序输出每个数的出现次数，一行一个数。如果没有出现过，则输出 000。

对于例子中的数组，最大的数是 333，因此我们只统计 {0,1,2,3}\{0,1,2,3\}{0,1,2,3} 的出现频数。
输入输出样例
输入 #1

5
1 1 2 3 1

输出 #1

0
3
1 
1

code:
int n,sum[100001],top=0,a;
int main(){
	cin >> n;
    for(int i=0;i<n;i++){
        cin>>a;
        sum[a]++;
        top=max(top,a);
    }
    for(int i=0;i<=top;i++)
        cout<<sum[i]<<endl;
	return 0;
}

*/

/*
B2097 最长平台

题目描述

已知一个已经从小到大排序的数组，这个数组中连续的一串值相同的元素就是一个平台，例如，在 111，222，222，333，333，333，444，555，555，666 中 111，2?22-22?2，3?3?33-3-33?3?3，444，5?55-55?5，666 都是平台。

编写一个程序，接收一个数组，把这个数组最长的平台找出来。在上面的例子中 3?3?33-3-33?3?3 就是最长的平台。
输入格式

第一行有一个整数 nnn，为数组元素的个数。（1≤n≤1001 \le n \le 1001≤n≤100）

第二行有 nnn 个整数，整数之间以一个空格分开，整数 kkk 范围（0<k<20000<k<20000<k<2000）。
输出格式

输出最长平台的长度。
输入输出样例
输入 #1

10
1 2 2 3 3 3 4 5 5 6

输出 #1

3

code:
int a[101] = {-1}, n,ans,g;
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) 
        cin >> a[i];
    for (int i = 1; i <= n; i++)
        if (a[i] == a[i - 1]) g++; 
        else ans = max(ans, g),g = 1;
    cout << ans;
    return 0;
}

*/

/*
B2098 整数去重

题目描述

给定含有 nnn 个整数的序列，要求对这个序列进行去重操作。所谓去重，是指对这个序列中每个重复出现的数，只保留该数第一次出现的位置，删除其余位置。
输入格式

输入包含两行：

第一行包含一个正整数 nnn（1≤n≤200001 \le n \le 200001≤n≤20000），表示第二行序列中数字的个数；

第二行包含 nnn 个整数，整数之间以一个空格分开。每个整数大于等于 101010 、小于等于 100100100。
输出格式

输出只有一行，按照输入的顺序输出其中不重复的数字，整数之间用一个空格分开。
输入输出样例
输入 #1

5
10 12 93 12 75

输出 #1

10 12 93 75

code:
bool showed[101];
int main() {
    int n,a;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a;
        if(!showed[a]){
            cout<<a<<" ";
            showed[a]=true;
        }
    }
    return 0;
}

*/

/*
B2099 矩阵交换行

题目描述

给定一个 5×55 \times 55×5 的矩阵(数学上，一个 r×cr \times cr×c 的矩阵是一个由 rrr 行 ccc 列元素排列成的矩形阵列)，将第 nnn 行和第 mmm 行交换，输出交换后的结果。
输入格式

输入共 666 行，前 555 行为矩阵的每一行元素,元素与元素之间以一个空格分开。

第 666 行包含两个整数 mmm、nnn，以一个空格分开（1≤m,n≤51 \le m,n \le 51≤m,n≤5）。
输出格式

输出交换之后的矩阵，矩阵的每一行元素占一行，元素之间以一个空格分开。
输入输出样例
输入 #1

1 2 2 1 2
5 6 7 8 3
9 3 0 5 3
7 2 1 4 6
3 0 8 2 4
1 5

输出 #1

3 0 8 2 4
5 6 7 8 3
9 3 0 5 3
7 2 1 4 6
1 2 2 1 2

code:
string c[5];
int main(){
    for(int i=0;i<5;i++)
        getline(cin,c[i]);
    int a,b;
    cin>>a>>b;
    swap(c[a-1],c[b-1]);
    for(int i=0;i<5;i++)
        cout<<c[i]<<endl;
    return 0;
}

*/

/*
B2100 同行列对角线的格

题目描述

输入三个自然数 NNN，iii，jjj（1≤i≤n1 \le i \le n1≤i≤n，1≤j≤n1 \le j \le n1≤j≤n），输出在一个 N×NN \times NN×N 格的棋盘中（行列均从 111 开始编号），与格子 (i(i(i，j)j)j) 同行、同列、同一对角线的所有格子的位置。

如：n=4n=4n=4，i=2i=2i=2，j=3j=3j=3 表示了棋盘中的第二行第三列的格子，

当 n=4n=4n=4，i=2i=2i=2，j=3j=3j=3 时，输出的结果是：

(2,1)(2,2)(2,3)(2,4)(2,1)(2,2)(2,3)(2,4)(2,1)(2,2)(2,3)(2,4) 同一行上格子的位置。

(1,3)(2,3)(3,3)(4,3)(1,3)(2,3)(3,3)(4,3)(1,3)(2,3)(3,3)(4,3) 同一列上格子的位置。

(1,2)(2,3)(3,4)(1,2)(2,3)(3,4)(1,2)(2,3)(3,4) 左上到右下对角线上的格子的位置。

(4,1)(3,2)(2,3)(1,4)(4,1)(3,2)(2,3)(1,4)(4,1)(3,2)(2,3)(1,4) 左下到右上对角线上的格子的位置。
输入格式

一行，三个自然数 NNN，iii，jjj，相邻两个数之间用单个空格隔开 (1≤N≤10)(1 \le N \le 10)(1≤N≤10)。
输出格式

第一行：从左到右输出同一行格子位置；

第二行：从上到下输出同一列格子位置；

第三行：从左上到右下输出同一对角线格子位置；

第四行：从左下到右上输出同一对角线格子位置。

其中每个格子位置用如下格式输出：(x,y)(x,y)(x,y)，xxx 为行号，yyy 为列号，采用英文标点，中间无空格。相邻两个格子位置之间用单个空格隔开。
输入输出样例
输入 #1

4 2 3

输出 #1

(2,1) (2,2) (2,3) (2,4)
(1,3) (2,3) (3,3) (4,3)
(1,2) (2,3) (3,4)
(4,1) (3,2) (2,3) (1,4)

code:
int main(){
    int n,x,y;
    cin>>n>>x>>y;
    for(int i=1;i<=n;i++)
        cout<<"("<<x<<","<<i<<")"<<" ";    	
    cout<<endl;
    for(int i=1;i<=n;i++)
        cout<<"("<<i<<","<<y<<")"<<" ";    	
    cout<<endl;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
		    if(i-j==x-y)
		        cout<<"("<<i<<","<<j<<")"<<" ";	
    cout<<endl;
    for(int i=n;i>=1;i--)
        for(int j=1;j<=n;j++)
		    if(i+j==x+y)
		        cout<<"("<<i<<","<<j<<")"<<" ";	
    cout<<endl;
	return 0;
}

*/

/*
B2101 计算矩阵边缘元素之和

题目描述

输入一个整数矩阵，计算位于矩阵边缘的元素之和。

所谓矩阵边缘的元素，就是第一行和最后一行的元素以及第一列和最后一列的元素。
输入格式

第 111 行包含两个整数，分别为行数 mmm 和列数 nnn，两个整数之间空格隔开。

第 222 行开始有 mmm 行数据，每行包含 nnn 个整数，整数之间空格隔开。
输出格式

对应矩阵的边缘元素和。
输入输出样例
输入 #1

3 3
3 4 1
3 7 1
2 0 1

输出 #1

15

说明/提示

1≤m,n≤1001 \le m,n \le 1001≤m,n≤100。

code:
int main(){
	int m,n,t,ans=0; 
    cin>>m>>n;
	for(int i=1;i<=m;i++)
		for(int j=1;j<=n;j++){
			scanf("%d",&t);
			if((i==1||i==m)||(j==1||j==n))
				ans+=t;
		}
    cout<<ans;
	return 0;
}

*/

/*
B2102 计算鞍点

题目描述

给定一个 5×55 \times 55×5 的矩阵，每行只有一个最大值，每列只有一个最小值，寻找这个矩阵的鞍点。鞍点指的是矩阵中的一个元素，它是所在行的最大值，并且是所在列的最小值。

例如：在下面的例子中，第 444 行第 111 列的元素就是鞍点，值为 888。

11 3 5 6 9
12 4 7 8 10
10 5 6 9 11
8  6 4 7 2
15 10 11 20 25

输入格式

输入包含一个 555 行 555 列的矩阵。
输出格式

如果存在鞍点，输出鞍点所在的行、列及其值，如果不存在，输出 not found。
输入输出样例
输入 #1

11 3 5 6 9
12 4 7 8 10
10 5 6 9 11
8  6 4 7 2
15 10 11 20 25

输出 #1

4 1 8

code:
int a[10][10],maxi[10][10],mini[10][10]; 
int main(){
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
			cin>>a[i][j];
	for(int i=1;i<=5;i++){
		int maxii=0,y;
		for(int j=1;j<=5;j++)
			if(a[i][j]>maxii)
				maxii=a[i][j],y=j;
		maxi[i][y]=maxii;
	}
	for(int i=1;i<=5;i++){
		int minii=1e9,x;
		for(int j=1;j<=5;j++)
			if(a[j][i]<minii)
				minii=a[j][i],x=j;
		mini[x][i]=minii;
	}
	for(int i=1;i<=5;i++)
		for(int j=1;j<=5;j++)
			if(maxi[i][j]!=0&&mini[i][j]!=0){
				cout<<i<<" "<<j<<" "<<maxi[i][j]<<endl;
				return 0;
			}
	cout<<"not found"<<endl;
	return 0;
}

*/

/*
B2103 图像相似度

题目描述

给出两幅相同大小的黑白图像（用 0?10-10?1 矩阵）表示，求它们的相似度。

说明：若两幅图像在相同位置上的像素点颜色相同，则称它们在该位置具有相同的像素点。两幅图像的相似度定义为相同像素点数占总像素点数的百分比。
输入格式

第一行包含两个整数 mmm 和 nnn，表示图像的行数和列数，中间用单个空格隔开。1≤m≤100,1≤n≤1001 \le m \le 100,1 \le n \le 1001≤m≤100,1≤n≤100。

之后 mmm 行，每行 nnn 个整数 000 或 111，表示第一幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。

之后 mmm 行，每行 nnn 个整数 000 或 111，表示第二幅黑白图像上各像素点的颜色。相邻两个数之间用单个空格隔开。
输出格式

一个实数，表示相似度（以百分比的形式给出），精确到小数点后两位。
输入输出样例
输入 #1

3 3
1 0 1
0 0 1
1 1 0
1 1 0
0 0 1
0 0 1

输出 #1

44.44

code:
int a[105][105],b[105][105],m,n;
double xsd,ans;
int main(){
    cin>>m>>n;
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++) 
            cin>>a[i][j];
    for(int i=0;i<m;i++)
        for(int j=0;j<n;j++){
            cin>>b[i][j];
            if(a[i][j]==b[i][j]) 
                xsd++;
        }
    ans=xsd/(m*n)*100;
    printf("%.2f",ans);
    return 0;
}

*/

/*
B2104 矩阵加法

题目描述

输入两个 nnn 行 mmm 列的矩阵 AAA 和 BBB，输出它们的和 A+BA+BA+B，矩阵加法的规则是两个矩阵中对应位置的值进行加和，具体参照样例。
输入格式

第一行包含两个整数 nnn 和 mmm，表示矩阵的行数和列数 (1≤n≤100(1 \le n \le 100(1≤n≤100，1≤m≤100)1 \le m \le 100)1≤m≤100)。

接下来 nnn 行，每行 mmm 个整数，表示矩阵 AAA 的元素。

接下来 nnn 行，每行 mmm 个整数，表示矩阵 BBB 的元素。

相邻两个整数之间用单个空格隔开，每个元素均在 1?10001 \sim 10001?1000 之间。
输出格式

nnn 行，每行 mmm 个整数，表示矩阵加法的结果。相邻两个整数之间用单个空格隔开。
输入输出样例
输入 #1

3 3
1 2 3
1 2 3
1 2 3
1 2 3
4 5 6
7 8 9

输出 #1

2 4 6
5 7 9
8 10 12

code:
int n, m, x,a[107][107];
int main() {
    cin>>n>>m;
    for(int i = 1; i <= n; ++i) 
        for(int j = 1; j <= m; ++j) 
            cin>>a[i][j];
    for(int i = 1; i <= n; ++i) 
        for(int j = 1; j <= m; ++j) 
            cin>>x, a[i][j] += x;
    for(int i = 1; i <= n; ++i) {
        for(int j = 1; j <= m; ++j) 
            cout<<a[i][j]<<" "; 
        cout<<endl;
    }
    return 0;
}

*/

/*
B2105 矩阵乘法

题目描述

计算两个矩阵的乘法。n×mn \times mn×m 阶的矩阵 AAA 乘以 m×km \times km×k 阶的矩阵 BBB 得到的矩阵 CCC 是 n×kn \times kn×k 阶的，且 C[i][j]=A[i][0]×B[0][j]+A[i][1]×B[1][j]+C[i][j]=A[i][0] \times B[0][j]+A[i][1] \times B[1][j]+C[i][j]=A[i][0]×B[0][j]+A[i][1]×B[1][j]+ …… +A[i][m?1]×B[m?1][j](C[i][j]+A[i][m-1] \times B[m-1][j](C[i][j]+A[i][m?1]×B[m?1][j](C[i][j] 表示 CCC 矩阵中第 iii 行第 jjj 列元素）。
输入格式

第一行为 n,m,kn,m,kn,m,k，表示 AAA 矩阵是 nnn 行 mmm 列，BBB 矩阵是 mmm 行 kkk 列，n,m,kn,m,kn,m,k 均小于 100100100。

然后先后输入 AAA 和 BBB 两个矩阵，AAA 矩阵 nnn 行 mmm 列，BBB 矩阵 mmm 行 kkk 列，矩阵中每个元素的绝对值不会大于 100010001000。
输出格式

输出矩阵 CCC，一共 nnn 行，每行 kkk 个整数，整数之间以一个空格分开。
输入输出样例
输入 #1

3 2 3
1 1
1 1
1 1
1 1 1
1 1 1

输出 #1

2 2 2
2 2 2
2 2 2

code:
int a[101][101], b[101][101], c[101][101], n, m, k;
int main(){
    cin >> n >> m >> k;
    for(int i = 0;i < n;++i)
        for(int j = 0;j < m;++j)
            cin >> a[i][j];
    for(int i = 0;i < m;++i)
        for(int j = 0;j < k;++j)
            cin >> b[i][j];
    for(int i = 0;i < n;++i)
        for(int j = 0;j < k;++j)
            for(int o = 0;o < m;++o) 
                c[i][j] += a[i][o] * b[o][j];
    for(int i = 0;i < n;++i){
        for(int j = 0;j < k;++j)
            cout << c[i][j] << " ";
        cout << endl;
    }
    return 0;
}

*/

/*
B2106 矩阵转置

题目描述

输入一个 nnn 行 mmm 列的矩阵 AAA，输出它的转置 ATA^TAT。
输入格式

第一行包含两个整数 nnn 和 mmm，表示矩阵 AAA 的行数和列数。1≤n≤1001 \le n \le 1001≤n≤100，1≤m≤1001 \le m \le 1001≤m≤100。

接下来 nnn 行，每行 mmm 个整数，表示矩阵 AAA 的元素。相邻两个整数之间用单个空格隔开，每个元素均在 1?10001 \sim 10001?1000 之间。
输出格式

mmm 行，每行 nnn 个整数，为矩阵 AAA 的转置。相邻两个整数之间用单个空格隔开。
输入输出样例
输入 #1

3 3
1 2 3
4 5 6
7 8 9

输出 #1

1 4 7
2 5 8
3 6 9

code:
int c[110][110], n, m;
int main(){
    cin >> n >> m;
	for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++) 
            cin >> c[i][j];
    for (int i = 1; i <= m; i ++){
    	for (int j = 1; j <= n; j ++) 
            cout << c[j][i] << " ";
        cout << endl;
    }
    return 0;
}

*/

/*
B2107 图像旋转

题目描述

输入一个 nnn 行 mmm 列的黑白图像，将它顺时针旋转 909090 度后输出。
输入格式

第一行包含两个整数 nnn 和 mmm，表示图像包含像素点的行数和列数。1≤n≤1001 \le n \le 1001≤n≤100，1≤m≤1001 \le m \le 1001≤m≤100。

接下来 nnn 行，每行 mmm 个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在 0?2550 \sim 2550?255 之间。
输出格式

mmm 行，每行 nnn 个整数，为顺时针旋转 909090 度后的图像。相邻两个整数之间用单个空格隔开。
输入输出样例
输入 #1

3 3
1 2 3
4 5 6
7 8 9

输出 #1

7 4 1
8 5 2
9 6 3

code:
int m,n,a[101][101];
int main(){
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++) 
            cin >> a[i][j];
    for(int i = 1; i <= m; i++){
        for(int j = n; j >= 1; j--) 
            cout<< a[j][i] << " " ;
		cout<< endl;
    }
    return 0; 
}

*/

/*
B2108 图像模糊处理

题目描述

给定 nnn 行 mmm 列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理：

1.1.1. 四周最外侧的像素点灰度值不变；

2.2.2. 中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均（舍入到最接近的整数）。
输入格式

第一行包含两个整数 nnn 和 mmm，表示图像包含像素点的行数和列数。1≤n≤1001 \le n \le 1001≤n≤100，1≤m≤1001 \le m \le 1001≤m≤100。

接下来 nnn 行，每行 mmm 个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在 000 ? 255255255 之间。
输出格式

nnn 行，每行 mmm 个整数，为模糊处理后的图像。相邻两个整数之间用单个空格隔开。
输入输出样例
输入 #1

4 5
100 0 100 0 50
50 100 200 0 0
50 50 100 100 200
100 100 50 50 100

输出 #1

100 0 100 0 50
50 80 100 60 0
50 80 100 90 200
100 100 50 50 100

code:
int n,m;
double a[101][101],b[101][101];
int main(){	
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			cin>>a[i][j],b[i][j]=a[i][j];
	for(int i=2;i<n;i++)
		for(int j=2;j<m;j++)
			b[i][j]=floor((a[i+1][j]+a[i-1][j]+a[i][j-1]+a[i][j+1]+a[i][j])*1.0/5+0.5);
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++)
			cout<<b[i][j]<<" ";
        cout<<endl;
	}
	return 0;
}

*/

/*
B2109 统计数字字符个数

题目描述

输入一行字符，统计出其中数字字符的个数。
输入格式

一行字符串，总长度不超过 255255255。
输出格式

输出为 111 行，输出字符串里面数字字符的个数。
输入输出样例
输入 #1

Today is 2021-03-27

输出 #1

8

code:
int main(){
    string s;
    getline(cin, s);
    int cnt = 0;
    for (int i = 0; i <= s.length() - 1; i++)
        if (s[i] <= '9' && s[i] >= '0')
            cnt++;
    cout << cnt ;
    return 0;
}

*/

/*
B2110 找第一个只出现一次的字符

题目描述

给定一个只包含小写字母的字符串，请你找到第一个仅出现一次的字符。如果没有，输出 no。
输入格式

一个字符串，长度小于 110011001100。
输出格式

输出第一个仅出现一次的字符，若没有则输出 no。
输入输出样例
输入 #1

abcabd

输出 #1

c

输入 #2

aabbcc

输出 #2

no

code:
bool visit[26],flag[26];
int main(){
	string str;
	cin >> str;
	for(int i = 0; i < str.size(); i++){
		if(visit[str[i] - 'a'])
			flag[str[i] - 'a'] = true;
		visit[str[i] - 'a'] = true;
    }
	for(int i = 0; i < str.size(); i++)
		if(!flag[str[i] - 'a'])	{
			cout << str[i];
			return 0;
		}
	cout << "no";
	return 0;
}

*/

/*
B2111 基因相关性

题目描述

为了获知基因序列在功能和结构上的相似性，经常需要将几条不同序列的 DNA 进行比对，以判断该比对的 DNA 是否具有相关性。

现比对两条长度相同的 DNA 序列。首先定义两条 DNA 序列相同位置的碱基为一个碱基对，如果一个碱基对中的两个碱基相同的话，则称为相同碱基对。接着计算相同碱基对占总碱基对数量的比例，如果该比例大于等于给定阈值时则判定该两条 DNA 序列是相关的，否则不相关。
输入格式

有三行，第一行是用来判定出两条 DNA 序列是否相关的阈值，随后 222 行是两条 DNA 序列（长度不大于 500500500）。
输出格式

若两条 DNA 序列相关，则输出 yes，否则输出no。
输入输出样例
输入 #1

0.85
ATCGCCGTAAGTAACGGTTTTAAATAGGCC
ATCGCCGGAAGTAACGGTCTTAAATAGGCC

输出 #1

yes

code:
double c,ans;
char a[500],b[500];
int main(){
    cin>>c>>a>>b;
    for(int i=0;i<strlen(a);i++) 
        if(a[i]==b[i]) 
            ans++; 
    ans/=strlen(a);
    if(ans>=c) cout<<"yes"<<endl;
    else cout<<"no"<<endl;
    return 0;
} 

*/

/*
B2112 石头剪子布

题目描述

石头剪子布，是一种猜拳游戏。起源于中国，然后传到日本、朝鲜等地，随着亚欧贸易的不断发展它传到了欧洲，到了近现代逐渐风靡世界。简单明了的规则，使得石头剪子布没有任何规则漏洞可钻，单次玩法比拼运气，多回合玩法比拼心理博弈，使得石头剪子布这个古老的游戏同时用于“意外”与“技术”两种特性，深受世界人民喜爱。

游戏规则：石头打剪刀，布包石头，剪刀剪布。

现在，需要你写一个程序来判断石头剪子布游戏的结果。
输入格式

第一行是一个整数 NNN，表示一共进行了 NNN 次游戏。1≤N≤1001 \le N \le 1001≤N≤100。

接下来 NNN 行的每一行包括两个字符串，表示游戏参与者 Player1，Player2 的选择（石头、剪子或者是布）： S1,S2

字符串之间以空格隔开 S1 S2 只可能取值在 Rock,Scissors,Paper (大小写敏感）中。
输出格式

输出包括 NNN 行，每一行对应一个胜利者（Player1 或者 Player2），或者游戏出现平局，则输出 Tie。
输入输出样例
输入 #1

3
Rock Scissors
Paper Paper
Rock Paper

输出 #1

Player1
Tie
Player2

code:
int main() {
	int n;
	cin>>n;
	for(int i=0; i<n; i++) {
		string a,b;
		cin>>a>>b;
		if(a[0]==b[0]) cout<<"Tie\n";
		else if(a[0]=='R') b[0]=='P'?cout<<"Player2\n":cout<<"Player1\n";
		else if(a[0]=='P') b[0]=='S'?cout<<"Player2\n":cout<<"Player1\n";
		else if(a[0]=='S') b[0]=='R'?cout<<"Player2\n":cout<<"Player1\n";
	}
	return 0;
}

*/

/*
B2113 输出亲朋字符串

题目描述

亲朋字符串定义如下：给定字符串 sss 的第一个字符的 ASCII 值加第二个字符的 ASCII 值，得到第一个亲朋字符；sss 的第二个字符加第三个字符得到第二个亲朋字符；依此类推。注意：亲朋字符串的最后一个字符由 sss 的最后一个字符 ASCII 值加 sss 的第一个字符的 ASCII 值。
输入格式

输入一行，一个长度大于等于 222，小于等于 100100100 的字符串。
输出格式

输出一行，为变换后的亲朋字符串。输入保证变换后的字符串只有一行。
输入输出样例
输入 #1

1234

输出 #1

cege

code:
int x[105];
char s[105];
int main(){
	cin>>s;
	for(int i=0;i<strlen(s)-1;i++)
		x[i]=s[i]+s[i+1];
	for(int i=0;i<strlen(s)-1;i++)
		cout<<char(x[i]);
	cout<<char(s[strlen(s)-1]+s[0]);
    return 0;
}

*/

/*
B2114 配对碱基链

题目描述

脱氧核糖核酸（DNA）由两条互补的碱基链以双螺旋的方式结合而成。

而构成 DNA 的碱基共有 444 种：

    分别为腺瞟呤（AAA）

    鸟嘌呤（GGG）

    胸腺嘧啶（TTT）

    胞嘧啶（CCC）

我们知道，在两条互补碱基链的对应位置上，腺瞟呤总是和胸腺嘧啶配对，鸟嘌呤总是和胞嘧啶配对。

你的任务就是根据一条单链上的碱基序列，给出对应的互补链上的碱基序列。
输入格式

一个字符串，表示一条碱基链。

这个字符串只含有大写字母 AAA 、 TTT 、 GGG 、 CCC，分别表示腺瞟呤、胸腺嘧啶、鸟嘌呤和胞嘧啶。

字符串长度不超过 255255255。
输出格式

一个只含有大写字母 AAA 、 TTT 、 GGG 、 CCC 的字符串，为与输入的碱基链互补的碱基链。
输入输出样例
输入 #1

ATATGGATGGTGTTTGGCTCTG

输出 #1

TATACCTACCACAAACCGAGAC

code:
string s;
int main(){
	cin>>s;
	for(int i=0;i<s.size();i++)
		if(s[i]=='A')cout<<"T";
		else if(s[i]=='T')cout<<"A";
		else if(s[i]=='G')cout<<"C";
		else if(s[i]=='C')cout<<"G";
	return 0;
}

*/

/*
B2116 加密的病历单

题目描述

小英是药学专业大三的学生，暑假期间获得了去医院药房实习的机会。

在药房实习期间，小英扎实的专业基础获得了医生的一致好评，得知小英在计算概论中取得过好成绩后，主任又额外交给她一项任务，解密抗战时期被加密过的一些伤员的名单。

经过研究，小英发现了如下加密规律（括号中是一个“原文 -> 密文”的例子）

1.1.1. 原文中所有的字符都在字母表中被循环右移了三个位置（dec→ghfdec \to ghfdec→ghf）

2.2.2. 逆序存储（abcd→dcbaabcd \to dcbaabcd→dcba）

3.3.3. 大小写反转（abXY→ABxyabXY \to ABxyabXY→ABxy）
输入格式

一个加密的字符串。（长度小于 505050 且只包含大小写字母）
输出格式

输出解密后的字符串。
输入输出样例
输入 #1

GSOOWFASOq

输出 #1

Trvdizrrvj

code:
string s;
int main() {
    cin >> s;
    for (int i = 0; i < s.size(); i++)
        if (s[i] >= 'a' && s[i] <= 'z')s[i] -= 32;
        else s[i] += 32;
    for (int i = 0; i < s.size(); i++) {
        if (s[i] <= 'z' && s[i] >= 'x') s[i] -= 26;
        else if (s[i] <= 'Z' && s[i] >= 'X') s[i] -= 26;
        s[i] += 3;
    }
    for (int i = s.size() - 1; i >= 0; i--)
        cout << s[i];
    return 0;
}

*/

/*
B2117 整理药名

题目描述

医生在书写药品名的时候经常不注意大小写，格式比较混乱。现要求你写一个程序将医生书写混乱的药品名整理成统一规范的格式，即药品名的第一个字符如果是字母要大写，其他字母小写。

如将 ASPIRIN 、 aspirin 整理成 Aspirin。
输入格式

第一行一个数字 nnn，表示有 nnn 个药品名要整理，nnn 不超过 100100100。

接下来 nnn 行，每行一个单词，长度不超过 202020，表示医生手书的药品名。

药品名由字母、数字和 - 组成。
输出格式

nnn 行，每行一个单词，对应输入的药品名的规范写法。
输入输出样例
输入 #1

4
AspiRin
cisapride
2-PENICILLIN
Cefradine-6

输出 #1

Aspirin
Cisapride
2-penicillin
Cefradine-6

code:
int main(){
	int n;
	cin >> n;
  	while(n--){
		string str;
		cin >> str;
 		if('a' <= str[0] && str[0] <= 'z')
			str[0] = str[0] - 'a' + 'A';
		for(int i = 1; i < str.size(); i++)
			if('A' <= str[i] && str[i] <= 'Z')
				str[i] = str[i] - 'A' + 'a';
        cout<<str<<endl;
  	}
	return 0;
}

*/

/*
B2118 验证子串

题目描述

输入两个字符串，验证其中一个串是否为另一个串的子串。
输入格式

两行，每行一个字符串。
输出格式

若第一个串 s1s_1s1? 是第二个串 s2s_2s2? 的子串，则输出(s1) is substring of (s2)；

否则，若第二个串 s2s_2s2? 是第一个串 s1s_1s1? 的子串，输出(s2) is substring of (s1)；

否则，输出 No substring。
输入输出样例
输入 #1

abc
dddncabca

输出 #1

abc is substring of dddncabca

输入 #2

aaa
bbb

输出 #2

 No substring

说明/提示

对于 100%100 \%100% 的数据，字符串长度在 202020 以内。

code:#include<bits/stdc++.h>
using namespace std;
string a,b;
int main(){//stl
    cin>>a>>b;
    if(a.find(b)!=a.npos) cout<<b<<" is substring of "<<a<<endl;
    else if(b.find(a)!=b.npos) cout<<a<<" is substring of "<<b<<endl;
    else cout<<"No substring"<<endl;
    return 0;
}

*/

/*
B2119 删除单词后缀

题目描述

给定一个单词，如果该单词以 er 、 ly 或者 ing 后缀结尾，则删除该后缀（题目保证删除后缀后的单词长度不为 000），否则不进行任何操作。
输入格式

输入一行，包含一个单词（单词中间没有空格，每个单词最大长度为 323232）。
输出格式

输出按照题目要求处理后的单词。
输入输出样例
输入 #1

referer

输出 #1

refer

code:
string s;
int main(){//stl
	cin>>s;
	int siz=s.size();
    if(s[siz-1]=='y'&&s[siz-2]=='l')s.erase(siz-2,2);
    else if(s[siz-1]=='r'&&s[siz-2]=='e')s.erase(siz-2,2);
    else if(s[siz-1]=='g'&&s[siz-2]=='n'&&s[siz-3]=='i')s.erase(siz-3,3);
    cout<<s;
    return 0;
} 

*/

/*
B2120 单词的长度

题目描述

输入一行单词序列，相邻单词之间由 111 个或多个空格间隔，请对应地计算各个单词的长度。

注意：如果有标点符号（如连字符，逗号），标点符号算作与之相连的词的一部分。没有被空格间开的符号串，都算作单词。
输入格式

一行单词序列，最少 111 个单词，最多 300300300 个单词，单词之间用至少 111 个空格间隔。单词序列总长度不超过 100010001000。
输出格式

依次输出对应单词的长度，之间以逗号间隔。
输入输出样例
输入 #1

She was born in 1990-01-02  and  from Beijing city.

输出 #1

3,3,4,2,10,3,4,7,5

code:
int main() {
    string s;
    cin>>s;
    cout<<s.size();
    while (cin >> s) 
        cout << ',' << s.size();
    return 0;
}

*/

/*
B2121 最长最短单词

题目描述

输入 111 行句子（不多于 200200200 个单词，每个单词长度不超过 100)100)100)，只包含字母、空格、逗号和句号。单词由至少一个连续的字母构成，空格、逗号和句号都是单词间的间隔。

输出第 111 个最长的单词和第 111 个最短单词。
输入格式

输入数据：一行句子。
输出格式

输出数据：

第 111 行，第一个最长的单词。

第 222 行，第一个最短的单词。
输入输出样例
输入 #1

I am a student,i am studying Programming language C in Peking University.

输出 #1

Programming
I

code:
int main(){
	string a,b,t;
	int la=0,lb=1000;
	char ch;
	while(ch=getchar()){
		if(ch=='\n'||ch==EOF)	break;
		if(ch==' '||ch==','||ch=='.'){
			if(t.length()>la) a=t,la=t.length();
			if(t.length()<lb) b=t,lb=t.length();
			t="";
			continue;
		}
		t.push_back(ch);
	}
	cout<<a<<endl<<b;
	return 0;
}

*/

/*
B2122 单词翻转

题目描述

小明同学写单词的时候喜欢反着写，比如 hello 他会写成 olleh。给出小明同学写的一个句子，请你将所有的单词复原。
输入格式

共一行，一个字符串表示句子，单词之间以空格分隔。
输出格式

每个单词一行。
输入输出样例
输入 #1

olleh dlrow

输出 #1

hello
world

说明/提示

句子长度不超过 100100100，仅包含小写字母和空格，不存在多余的空格。

code:
int main(){
    string c;
    while(cin>>c){
        for(int i=c.length()-1;i>=0;i--)
            cout<<c[i];
        cout<<endl;
    }
	return 0;
}

*/

/*
B2123 字符串 p 型编码

题目描述

给定一个完全由数字字符（'0','1','2',…,'9'）构成的字符串 str ，请写出 str 的 p 型编码串。例如：字符串 122344111 可被描述为 1个1、2个2、1个3、2个4、3个1 ，因此我们说122344111 的 p 型编码串为 1122132431 ；类似的道理，编码串 101 可以用来描述 1111111111 ；00000000000 可描述为 11个0，因此它的p型编码串即为 110 ；100200300 可描述为 1个1、2个 0、1个2、2个0、1个3、2个0，因此它的 p 型编码串为 112012201320。
输入格式

输入仅一行，包含字符串 str。每一行字符串最多包含 100010001000 个数字字符。
输出格式

输出该字符串对应的 ppp 型编码串。
输入输出样例
输入 #1

122344111

输出 #1

1122132431

code:
string c;
int a = 1;
int main(){
	cin >> c;
	for (int i = 1; i < c.length(); i++,a++)
        if (c[i] != c[i - 1])
            cout << a << c[i - 1],a = 0;
	cout << a << c[c.length() - 1];	
	return 0; 
}

*/

/*
B2124 判断字符串是否为回文

题目描述

输入一个字符串，输出该字符串是否回文。回文是指顺读和倒读都一样的字符串。
输入格式

输入一行字符串，长度小于 100100100。
输出格式

如果字符串是回文，输出 yes；否则，输出 no。
输入输出样例
输入 #1

abcdedcba

输出 #1

yes

code:
string a,b;
int main() {//stl翻转
	cin >> a;
	b = a;
	reverse(a.begin(), a.end());
	if(a == b) printf("yes\n");
    else printf("no\n");
	return 0;
}

*/

/*
B2125 最高分数的学生姓名

题目描述

输入学生的人数，然后再输入每位学生的分数和姓名，求获得最高分数的学生的姓名。
输入格式

第一行输入一个正整数 NNN（N≤100N \le 100N≤100），表示学生人数。

接着输入 NNN 行，每行包括两个整数，代表分数姓名。

分数是一个非负整数，且小于等于 100100100；

姓名为一个连续的字符串，中间没有空格，长度不超过 202020。

数据保证所有同学的姓名都不同，而且最高分只有一位同学。
输出格式

获得最高分数同学的姓名。
输入输出样例
输入 #1

5
87 lilei
99 hanmeimei
97 lily
96 lucy
77 jim

输出 #1

hanmeimei

说明/提示

hanmeimei 的分数最高 999999 分。

code:
int main(){
    int n,max=-1;
    cin>>n;
    string c;
    for(int i = 0;i < n;i ++){
        int x;
        string s;
        cin>>x>>s;//输入
        if(x>max)max=x,c=s;
    }
    cout<<c;
    return 0;
}

*/

/*
B2126 连续出现的字符

题目描述

给定一个字符串，在字符串中寻找第一个连续出现次数不低于 kkk 次的字符。
输入格式

222 行。第 111 行是 kkk；第 222 行是仅包含大小写字母的字符串。
输出格式

字符串中第一个连续出现次数不低于 k 次的字符。如果没有符合条件的字符，输出 No。
输入输出样例
输入 #1

3
abcccaaab

输出 #1

c

说明/提示

1≤k≤10001\leq k\leq10001≤k≤1000，字符串长度不超过 100010001000。

code:
int c,num=1;
string a;
int main(){
	cin>>c>>a;
	for(int i=1;i<a.length();i++){
		if(a[i]==a[i-1]){
			num++;
			if(num>=c){
                cout<<a[i];
                return 0;
            }
		}else num=1;
	}
    puts("No");
	return 0;
}

*/

/*
B2127 求正整数 2 和 n 之间的完全数

题目描述

求正整数 222 和 nnn 之间的完全数（一行一个数）。

完全数：对于一个自然数，所有比它小的所有因数之和，等于它本身，它就是个完全数。如 6=1+2+36=1+2+36=1+2+3。
输入格式

输入 n(n≤10000)n(n \le 10000)n(n≤10000)。
输出格式

一行一个数，按由小到大的顺序。
输入输出样例
输入 #1

10

输出 #1

6

输入 #2

100

输出 #2

6
28

code:
bool check(int n){
    int ans = 0;
    for(int i = 1;i < n;i ++)
        if(n % i == 0)
            ans += i;
    if(ans == n)return 1;
    else return 0;
}
int main(){
    int n;
    cin >> n;
    for(int i = 2;i <= n;i ++)
        if(check(i))
            cout << i << endl;
    return 0;
}

*/

/*
B2128 素数个数

题目描述

编程求 222 ～ n(nn(nn(n 为大于 222 的正整数）中有多少个素数。
输入格式

输入 n(2≤n≤50000)n(2 \le n \le 50000)n(2≤n≤50000)。
输出格式

素数个数。
输入输出样例
输入 #1

10

输出 #1

4

code:
bool check(int x){
    for(int i=2;i*i<=x;i++)
        if(x%i==0)
            return 0;
    return 1;
}
int main(){
    int n,sum=0;
    cin>>n;
    for(int i=2;i<=n;i++)
        if(check(i))
            sum++;
    cout<<sum<<endl;
    return 0;
}

*/

/*
B2129 最大数 max(x,y,z)

题目描述

已知：

m=max?(a,b,c)max?(a+b,b,c)×max?(a,b,b+c)m=\dfrac{\max(a,b,c)}{\max(a+b,b,c) \times \max(a,b,b+c)}m=max(a+b,b,c)×max(a,b,b+c)max(a,b,c)?

输入 aaa，bbb，ccc，求 mmm 。

把求三个数的最大数 max?(x,y,z)\max(x,y,z)max(x,y,z) 分别定义成函数和过程来做。
输入格式

输入只有一个行三个整数，分别为 a,b,ca, b, ca,b,c。
输出格式

输出一行一个小数，为答案，保留三位小数。
输入输出样例
输入 #1

1 2 3

输出 #1

0.200

说明/提示
数据规模与约定

对于全部的测试点，保证 OaO,ObO,OcO≤50|a|,|b|,|c| \leq 50OaO,ObO,OcO≤50。 换句话说，a,b,ca,b,ca,b,c 都在 -50 到 50 之间。

code:
int main(){
    double a, b, c;
    cin >> a >> b >> c;
    cout << fixed << setprecision(3) << max({a, b, c}) / (max({a + b, b, c}) * max({a, b, b + c})) ;
    return 0;
}

*/

/*
B2130 简单算术表达式求值

题目描述

两位正整数的简单算术运算（只考虑整数运算），算术运算为：

+，加法运算；

-，减法运算；

*，乘法运算；

/，整除运算；

%，取余运算。

算术表达式的格式为（运算符前后可能有空格）：

运算数运算符运算数。

请输出相应的结果。
输入格式

一行算术表达式。
输出格式

整型算数运算的结果（结果值不一定为 222 位数，可能多于 222 位或少于 222 位）。
输入输出样例
输入 #1

32+64

输出 #1

96

code:
char ch;
int a,b;
int main(){
    cin>>a>>ch>>b;
	if(ch=='+')cout<<a+b;
	if(ch=='-')cout<<a-b;
	if(ch=='*')cout<<a*b;
	if(ch=='/')cout<<a/b;
	if(ch=='%')cout<<a%b; 
	return 0;
}

*/

/*
B2131 甲流病人初筛

题目描述

目前正是甲流盛行时期，为了更好地进行分流治疗，医院在挂号时要求对病人的体温和咳嗽情况进行检查，对于体温超过 37.537.537.5 度（含等于 37.537.537.5 度）并且咳嗽的病人初步判定为甲流病人（初筛）。现需要统计某天前来挂号就诊的病人中有多少人被初筛为甲流病人。
输入格式

第一行是某天前来挂号就诊的病人数 nnn。(n<200)(n<200)(n<200)。

其后有 nnn 行，每行是病人的信息，包括三个信息：姓名（字符串，不含空格，最多 888 个字符）、体温（float）、是否咳嗽（整数，111 表示咳嗽，000 表示不咳嗽）。每行三个信息之间以一个空格分开。
输出格式

按输入顺序依次输出所有被筛选为甲流的病人的姓名，每个名字占一行。之后在输出一行，表示被筛选为甲流的病人数量。
输入输出样例
输入 #1

5
Zhang 38.3 0
Li 37.5 1
Wang 37.1 1
Zhao 39.0 1
Liu 38.2 1

输出 #1

Li
Zhao
Liu
3

code:
int n,cough,ans;
string name;
double temp;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>name>>temp>>cough;
        if(temp>=37.5&&cough)
            cout<<name<<endl,ans++;
    }
    cout<<ans;
    return 0;
}

*/

/*
B2132 素数对

题目描述

定义两个相差为 222 的素数称为素数对，如 555 和 7,177,177,17 和 191919 等，要求找出所有两个数均不大于 nnn 的素数对。
输入格式

一个正整数 nnn。1≤n≤100001 \le n \le 100001≤n≤10000。
输出格式

所有小于等于 nnn 的素数对。每对素数对输出一行，中间用单个空格隔开。若没有找到任何素数对，输出 empty。
输入输出样例
输入 #1

10

输出 #1

3 5
5 7

输入 #2

100

输出 #2

3 5
5 7
11 13
17 19
29 31
41 43
59 61
71 73

输入 #3

3

输出 #3

empty

code:
int n;
bool b;
bool check(int x){
	for(int i=2;i*i<=x;i++)
		if(x%i==0)
            return 0;
	return 1;
}
int main(){
	cin>>n;
	for(int i=3;i<=n-2;i++)
		if(check(i)&&check(i+2))
			b=1,cout<<i<<" "<<i+2<<endl;
	if(b==0) cout<<"empty";
	return 0;
}

*/

/*
B2133 我家的门牌号

题目描述

我家住在一条短胡同里，这条胡同的门牌号从 111 开始顺序编号。

若其余各家的门牌号之和减去我家门牌号的两倍，恰好等于 nnn，求我家的门牌号及总共有多少家。数据保证有唯一解。
输入格式

一个正整数 nnn。n<100000n<100000n<100000。
输出格式

一行，包含两个正整数，分别是我家的门牌号及总共有多少家，中间用单个空格隔开。
输入输出样例
输入 #1

100

输出 #1

12 16

code:
int n;
int main(){
	cin >> n;
	for(int i = 1; ; i++)
		for(int j = 1; j <= i; j++)
			if(i * (i + 1) / 2 - 3 * j == n){
				cout<< j << " " << i ;
				return 0;
			}
    return 0;
}

*/

/*
B2134 质数的和与积

题目描述

两个质数的和是 SSS，它们的积最大是多少？
输入格式

一个不大于 100001000010000 的正整数 SSS，为两个质数的和。
输出格式

一个整数，为两个质数的最大乘积。数据保证有解。
输入输出样例
输入 #1

50

输出 #1

589

code:
int s,ans;
bool check(int k){
    for(int i=2;i*i<=k;++i)
        if(k%i==0)
            return 0;
    return 1;
}
int main(){
    cin>>s;
    for(int i=(s+1)/2;i>=1;--i)
        if(check(i))
            if(check(s-i)){
                cout<<i*(s-i);
                return 0;
            }
    return 0;
}

*/

/*
B2135 单词替换

题目描述

输入一个字符串，以回车结束（字符串长度 ≤200 \le 200≤200）。该字符串由若干个单词组成，单词之间用一个空格隔开，所有单词区分大小写。现需要将其中的某个单词替换成另一个单词，并输出替换之后的字符串。
输入格式

第 111 行是包含多个单词的字符串 sss；

第 222 行是待替换的单词 a(a(a( 长度 ≤100) \le 100)≤100)；

第 333 行是 aaa 将被替换的单词 b(b(b( 长度 ≤100) \le 100)≤100)。

s,a,bs,a,bs,a,b 最前面和最后面都没有空格。
输出格式

输出只有 111 行，将 sss 中所有单词 aaa 替换成 bbb 之后的字符串。
输入输出样例
输入 #1

You want someone to help you
You
I

输出 #1

I want someone to help you

code:
string s[201], a, b;
char c;
int cur = 1;
int main(){
    cin>>s[1];
    while(getchar() == ' ')
        cin>>s[++cur];
    cin>>a>>b;
    for(int i = 1;i <= cur;i++){
        if(s[i] == a)cout<<b;
        else cout<<s[i];
        cout<<' ';
    }
    return 0;
}

*/

/*
B2136 素数回文数的个数

题目描述

求 111111 到 nnn 之间（包括 nnn），既是素数又是回文数的整数有多少个。
输入格式

一个大于 111111 小于 100001000010000 的整数 nnn。
输出格式

111111 到 nnn 之间的素数回文数个数。
输入输出样例
输入 #1

23

输出 #1

1

说明/提示

回文数指左右对称的数，如：111111，121211212112121。

code:
int n,ans;
bool check1(int x){
	for(int i=2;i<=x-1;i++)
		if(x%i==0)
			return false;
	return true;			
}
bool check2(int x){
	int t=0,m=0,a[15],b[15];
	while(x!=0)
		t++,a[t]=x%10,x/=10;
	for(int i=t;i>=1;i--)
		m++,b[m]=a[i];
	for(int i=1;i<=t;i++)
		if(a[i]!=b[i])
			return false;
	return true;		
}
int main(){
	cin>>n;
	for(int i=11;i<=n;i++)
		if(check1(i)&&check2(i))
			ans++;
	cout<<ans;
	return 0;		
}

*/

/*
B2137 判决素数个数

题目描述

求 XXX，YYY 之间的素数个数（包括 XXX 和 YYY）。
输入格式

两个整数 XXX 和 YYY（1≤X,Y≤1051 \le X,Y \le 10^51≤X,Y≤105）。
输出格式

输出一个整数，表示 XXX，YYY 之间的素数个数（包括 XXX 和 YYY）。
输入输出样例
输入 #1

1 100

输出 #1

25

code:
int x,y,ans;
bool check(int n){
	if(n<=1)return false;
	for(int i=2;i*i<=n;i++)
		if(n%i==0) 
            return false;
	return true;
}
int main(){
	cin>>x>>y;
	if(x>y) swap(x,y);
	for(int i=x;i<=y;i++)
		if(check(i))
			ans++;
	cout<<ans;
	return 0;
}

*/

/*
B2138 最大质因子序列

题目描述

任意输入两个正整数 m,nm,nm,n（1≤m≤n≤50001\le m\le n\le50001≤m≤n≤5000），依次输出 mmm 到 nnn 之间每个数的最大质因子（包括 mmm 和 nnn；如果某个数本身是质数，则输出这个数自身）。
输入格式

一行，包含两个正整数 mmm 和 nnn，其间以单个空格间隔。
输出格式

一行，每个整数的最大质因子，以逗号间隔。
输入输出样例
输入 #1

5 10

输出 #1

5,3,7,2,3,5

code:
int check(int i){
	for(int j=i;;j--)
        if(i%j==0){
            bool flag=1;
            for(int k=2;k<=sqrt(j);k++)
                if(j%k==0){
                    flag=0;
                    break;
                }
            if(flag)return j;
        }
}
int main(){
	int n,m;
	cin >> n >> m;
	for(int i=n;i<=m;i++)
		if(i==m)cout << check(i);
		else cout << check(i) << ",";
	return 0;
}

*/

/*
B2139 区间内的真素数

题目描述

找出正整数 MMM 和 NNN 之间（NNN 不小于 MMM）的所有真素数。

真素数的定义：如果一个正整数 PPP 为素数，且其反序也为素数，那么 PPP 就为真素数。

例如，111111，131313 均为真素数，因为 111111 的反序还是为 111111，131313 的反序为 313131 也为素数。
输入格式

输入两个数 MMM 和 NNN，空格间隔。
输出格式

按从小到大输出 MMM 和 NNN 之间（包括 MMM 和 NNN）的真素数，逗号间隔。如果之间没有真素数，则输出 No。
输入输出样例
输入 #1

10 35

输出 #1

11,13,17,31

说明/提示

1≤M≤N≤1000001 \le M \le N \le 1000001≤M≤N≤100000

code:
int vis[100001],ans[100001],m,n,cnt;
int backwards(int a){
	string s;
	while(a) 
        s+=char(a%10+'0'),a/=10;
	int b=0;
	for(int i=0;i<s.size();i++)
		b*=10,b+=s[i]-'0';
	return b;
}
int main(){
	cin>>m>>n;
	for(int i=2;i<1000;i++)
		if(!vis[i])
			for(int j=i;j<100001/i;j++)
				vis[i*j]=1;
	for(int i=m;i<=n;i++)
		if((!vis[i])&&(!vis[backwards(i)]))
			ans[++cnt]=i;
	if(!cnt) cout<<"No";
	else {
		for(int i=1;i<cnt;i++) cout<<ans[i]<<',';
		cout<<ans[cnt];
	}
}

*/

/*
B2140 二进制分类

题目描述

若将一个正整数化为二进制数，在此二进制数中，我们将数字 111 的个数多于数字 000 的个数的这类二进制数称为 AAA 类数，否则就称其为 BBB 类数。

例如：

(13)10=(1101)2(13)_{10}=(1101)_2(13)10?=(1101)2?，其中 111 的个数为 333，000 的个数为 111，则称此数为 AAA 类数；

(10)10=(1010)2(10)_{10}=(1010)_2(10)10?=(1010)2?，其中 111 的个数为 222，000 的个数也为 222，称此数为 BBB 类数；

(24)10=(11000)2(24)_{10}=(11000)_2(24)10?=(11000)2?，其中 111 的个数为 222，000 的个数为 333，则称此数为 BBB 类数；

程序要求：求出 1~n 之中（1≤n≤10001 \le n \le 10001≤n≤1000），全部 A,BA,BA,B 两类数的个数。
输入格式

输入 nnn。
输出格式

一行，包含两个整数，分别是 AAA 类数和 BBB 类数的个数，中间用单个空格隔开。
输入输出样例
输入 #1

7

输出 #1

5 2

code:
int A, B, L, R, n, t, temp;
int main() {
	cin >> n;
	for (int i = 1; i <= n; i++) {
		L = 0, R = 0;
		t = i;
		while (t) {
			temp = t & 1;
			t = t >> 1;
			if (temp) R++;
			else L++;
		}
		R > L ? A++ : B++;
	}
	cout << A << ' ' << B;
}

*/

/*
B2141 确定进制

题目描述

6 ×9=426\ \times 9=426 ×9=42 对于十进制来说是错误的，但是对于 131313 进制来说是正确的。即 6(13) ×9(13)=42(13)6_{(13)}\ \times 9_{(13)}=42_{(13)}6(13)? ×9(13)?=42(13)?，而 42(13)=4 ×131+2 ×130=54(10)42_{(13)}=4\ \times 13^1+2\ \times 13^0=54_{(10)}42(13)?=4 ×131+2 ×130=54(10)?。

你的任务是写一段程序读入三个整数 p,qp,qp,q 和 rrr，然后确定一个进制 B(2≤B≤16)B(2 \le B \le 16)B(2≤B≤16) 使得 p ×q=rp\ \times q=rp ×q=r。如果 BBB 有很多选择，则输出最小的一个。

例如：p=11,q=11,r=121p=11,q=11,r=121p=11,q=11,r=121，则有 11(3) ×11(3)=121(3)11_{(3)}\ \times 11_{(3)}=121_{(3)}11(3)? ×11(3)?=121(3)?，因为 11(3)=1 ×31+1 ×30=4(10)11_{(3)}=1\ \times 3^1+1\ \times 3^0=4_{(10)}11(3)?=1 ×31+1 ×30=4(10)? 和 121(3)=1 ×32+2 ×31+1 ×30=16(10)121_{(3)}=1\ \times 3^2+2\ \times 3^1+1\ \times 3^0=16_{(10)}121(3)?=1 ×32+2 ×31+1 ×30=16(10)?。对于进制 10,10,10, 有 11(10) ×11(10)=121(10)11_{(10)}\ \times 11_{(10)}=121_{(10)}11(10)? ×11(10)?=121(10)?。这种情况下，应该输出 333。如果没有合适的进制，则输出 000。
输入格式

一行，包含三个整数 p,q,rp,q,rp,q,r，相邻两个整数之间用单个空格隔开。
输出格式

一个整数：即使得 p×q=rp \times q=rp×q=r 成立的最小的 BBB。如果没有合适的 BBB，则输出 000。
输入输出样例
输入 #1

6 9 42

输出 #1

13

说明/提示

p,q,rp,q,rp,q,r 的所有位都是数字，并且 1≤p,q,r≤1061 \le p,q,r \le 10^61≤p,q,r≤106。

code:
long long i,k;
char p[1005],q[1005],r[1005],c[20] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
int achar(char x[],char y[],char z[]){ 
    int pp = strlen(x),qq = strlen(y),rr = strlen(z),m = 0,n,i;
    for(i = 0; i < pp; i++)n = int(x[i] - 48),m = max(n,m);
    for(i = 0; i < qq; i++)n = int(y[i] - 48),m = max(n,m);
    for(i = 0; i < rr; i++)n = int(z[i] - 48),m = max(n,m);
    return (c[m] - 48);
}
long long anyu(char s[],int b){
    int n = strlen(s);
	long long x = 0;
    for(int i = 0; i < n; i++)
        for(int j = 0; j <= 15; j++) 
            if(s[i] == c[j]){
                x += j * pow(b,n - i - 1);
                break;
            }
    return x;
}
int main(){
    cin >> p>> q >> r;
    k = achar(p,q,r);
    for(i = max(k + 1,2ll); i <= 16; i++)
        if(anyu(p,i) * anyu(q,i) == anyu(r,i)){
            cout<< i << endl;
            return 0; 
        }
    cout<< 0 ;
    return 0;
}

*/

/*
B2142 求 1+2+3+...+N 的值

题目描述

用递归的方法求 1+2+3+1+2+3+1+2+3+ …… +N+N+N 的值。
输入格式

输入 NNN。
输出格式

输出和。
输入输出样例
输入 #1

5

输出 #1

15

说明/提示

N≤200N\le 200N≤200

code:
int main(){
    int n;
    cin>>n;
    cout<<1.0*(1+n)*n/2;
    return 0;
}

*/

/*
B2143 进制转换

题目描述

用递归算法将一个十进制数 XXX 转换成任意进制数 MMM（M≤16M\le16M≤16）。
输入格式

一行两个数，第一个十进制数 XXX，第二个为进制 MMM。
输出格式

输出结果。
输入输出样例
输入 #1

31 16 

输出 #1

1F

说明/提示

样例解释。

将十进制 313131 转化为十六进制数。

code:
string c="0123456798ABCDEF";
void f(int x,int m){
	if(x/m) f(x/m,m);
	cout<<c[x%m];
}
int main(){
	int x,m;
	cin>>x>>m;
	f(x,m);
	return 0;
}

*/

/*
B2144 阿克曼(Ackmann)函数

题目描述

阿克曼 (Ackmann)(Ackmann)(Ackmann) 函数 A(m,n)A(m,n)A(m,n) 中，m，nm，nm，n 定义域是非负整数 (m≤3,n≤10)(m \le 3,n \le 10)(m≤3,n≤10)，函数值定义为：

akm(m,n)=n+1akm(m,n)=n+1akm(m,n)=n+1；(m=0m=0m=0 时 )。

akm(m,n)=akm(m?1,1)akm(m,n)=akm(m-1,1)akm(m,n)=akm(m?1,1)；(m>0,n=0m>0,n=0m>0,n=0 时 )。

akm(m,n)=akm(m?1,akm(m,n?1))akm(m,n)=akm(m-1,akm(m,n-1))akm(m,n)=akm(m?1,akm(m,n?1))；（m,n>0m,n>0m,n>0 时 )。
输入格式

mmm 和 nnn。
输出格式

函数值。
输入输出样例
输入 #1

2 3

输出 #1

9

code:
int ackmann(int a, int b){
    if (a == 0) return b + 1;
    if (b == 0) return ackmann(a - 1, 1);
    return ackmann(a - 1, ackmann(a, b - 1));
}
int main(){
    int a, b;
    cin >> a >> b;
    cout << ackmann(a, b);
    return 0;
}

*/

/*
B2145 digit 函数

题目描述

在程序中定义一函数 digit(n,k)digit(n,k)digit(n,k)，它能分离出整数 nnn 从右边数第 kkk 个数字。
输入格式

正整数 nnn 和 kkk。
输出格式

一个数字。
输入输出样例
输入 #1

31859 3

输出 #1

8

说明/提示

n≤109n \le 10^9n≤109。

k≤10k \le 10k≤10。

code:
long digit(int n,int k){
	k = k - 1;
	if(k == 0) return n % 10;
	else return digit(n / 10,k);
}
int main(){
	int n,k;
	cin >> n >> k;
	cout << digit(n,k);
	return 0;
}

*/

/*
B2146 Hermite 多项式

题目描述

求 Hermite 多项式的值。

hn(x)={1，n=02x，n=12xhn?1(x)?2(n?1)hn?2(x)，n>1h_n(x)=\left\{ \begin{aligned} 1&，&n=0\\ 2x&，&n=1\\ 2xh_{n-1}(x)-2(n-1)h_{n-2}(x)&，& n>1 \end{aligned} \right.
hn?(x)=????????12x2xhn?1?(x)?2(n?1)hn?2?(x)?，，，?n=0n=1n>1?

对给定的 xxx 和正整数 nnn，求多项式的值。
输入格式

输入 nnn 和 xxx 。
输出格式

求多项式的值。
输入输出样例
输入 #1

1 2

输出 #1

4

说明/提示

(n≤8，x≤8)(n \le 8，x \le 8)(n≤8，x≤8)

code:
int main(){
	int h[9],n,x;
    cin>>n>>x;
	h[0]=1;
    h[1]=2*x;
	for(int i=2;i<=n;i++)
		h[i]=2*x*h[i-1]-2*(i-1)*h[i-2];
    cout<<h[n];
	return 0;
}

*/

/*
B2147 求 f(x,n)

题目描述

已知 f(x,n)=n+(n?1)+(n?2)+...+2+1+xf(x,n)=\sqrt{n+\sqrt{(n-1)+\sqrt{(n-2)+\sqrt{...+2+\sqrt{1+x}}}}}f(x,n)=n+(n?1)+(n?2)+...+2+1+x
?
?
?
?

?。

计算 fff 的值。
输入格式

输入 xxx 和 nnn。
输出格式

函数值，保留两位小数。
输入输出样例
输入 #1

4.2 10

输出 #1

3.68

code:
double x;
int n;
double f(int n) {
	if(n > 1) return sqrt(n + f(n - 1));
	else return sqrt(1 + x);
}
int main() {//递归
    cin>>x>>n;
    printf("%.2lf", f( n));
	return 0;
}


int main() {//递推
	double x;
    int n;
    cin>>x>>n;
	double f[10001] = {0.0}; 
    f[1] = sqrt(1 + x);
    for(int i=2;i<=n;i++) 
        f[i] = sqrt(i + f[i - 1]);
    printf("%.2lf", f[n]);
	return 0;
}

*/

/*
B2148 再求 f(x,n)

题目描述

已知

f(x,n)=xn+x(n?1)+x(n?2)+?+x1+xf(x,n)=\frac{x}{n+\frac{x}{(n-1)+\frac{x}{(n-2)+\ddots+\frac{x}{1+x}}}}f(x,n)=n+(n?1)+(n?2)+?+1+xx?x?x?x?。

用递归函数求解。
输入格式

第一数是 xxx 的值，第二个数是 nnn 的值。（nnn 为整数）
输出格式

函数值，保留两位小数。
输入输出样例
输入 #1

1 2

输出 #1

0.40

code:
double x,n;
double ans(int i){
	if(i==1)return x/(i+x);
	return x/(i+ans(i-1));
}
int main(){//递归
	cin>>x>>n;
    printf("%.2f",ans(n));
    return 0;
}


double f[1000001];
int main(){//递推
    double x;
    int n;
    cin>>x>>n;
    f[1]=x/(1+x);
    for(int i=2; i<=n; ++i) 
        f[i]=x/(i+f[i-1]);
    printf("%.2f",f[n]);
    return 0;
}

*/