#include <bits/stdc++.h>
#include <initializer_list>
#include <unordered_map>
#include <bits/stdc++.h>
#include <stdexcept>
#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <fstream>
#include <sstream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <vector>
#include <memory>
#include <string>
#include <ctime>
#include <cmath>
#include <deque>
#include <list>
#include <map>
#include <cctype>

using namespace std;

/*
P1002 [NOIP2002 普及组] 过河卒

题目描述

棋盘上 AAA 点有一个过河卒，需要走到目标 BBB 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 CCC 点有一
对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。


棋盘用坐标表示，AAA 点 (0,0)(0, 0)(0,0)、BBB 点 (n,m)(n, m)(n,m)，同样马的位置坐标是需要给出
。

现在要求你计算出卒从 AAA 点能够到达 BBB 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马
一步。 输入格式

一行四个正整数，分别表示 BBB 点坐标和马的坐标。
输出格式

一个整数，表示所有的路径条数。
输入输出样例
输入 #1

6 6 3 3

输出 #1

6

说明/提示

对于 100%100 \%100% 的数据，1≤n,m≤201 \le n, m \le 201≤n,m≤20，0≤0 \le0≤ 马的坐标 ≤20\le 20≤20。


【题目来源】

NOIP 2002 普及组第四题

code:
bool b[110][110];
long long a[110][110];
int dx[8]={2,1,-1,-2,-2,-1,1,2};
int dy[8]={1,2,2,1,-1,-2,-2,-1};
int n,m,x,y,k,l;
int main(){
	cin>>n>>m>>x>>y;
	memset(b,0,sizeof(b));
	b[x][y]=1;
	for(int i=0;i<=7;i++)if(x+dx[i]>=0&&x+dx[i]<=n&&y+dy[i]>=0&&y+dy[i]<=m)	b[x+dx[i]][y+dy[i]]=1;
	while(!b[k][0]&&k<=n)a[k++][0]=1;
	while(!b[0][l]&&l<=m)a[0][l++]=1;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=m;j++)
			if(b[i][j])	a[i][j]=0;
			else a[i][j]=a[i-1][j]+a[i][j-1];
	cout<<a[n][m];
	return 0;
}

*/

/*
P1003 [NOIP2011 提高组] 铺地毯

题目描述

为了准备一个独特的颁奖典礼，组织者在会场的一片矩形区域（可看做是平面直角坐标系的第一象限）铺上一些矩形地毯。一共有 nnn 张地毯，编号从 111 到 nnn。现在将这些地毯按照编号从小到大的顺序平行于坐标轴先后铺设，后铺的地毯覆盖在前面已经铺好的地毯之上。

地毯铺设完成后，组织者想知道覆盖地面某个点的最上面的那张地毯的编号。注意：在矩形地毯边界和四个顶点上的点也算被地毯覆盖。
输入格式

输入共 n+2n + 2n+2 行。

第一行，一个整数 nnn，表示总共有 nnn 张地毯。

接下来的 nnn 行中，第 i+1i+1i+1 行表示编号 iii 的地毯的信息，包含四个整数 a,b,g,ka ,b ,g ,ka,b,g,k，每两个整数之间用一个空格隔开，分别表示铺设地毯的左下


的坐标 (a,b)(a, b
(a,b) 以及地毯在 xxx 轴和 yyy 轴方向的长度。


第 n+2n + 2n+2 行包含两个整数 xxx 和 yyy，表示所求的地面的点的坐标 (x,y)(x, y)(x,y)。
 输出格式

输出共 111 行，一个整数，表示所求的地毯的编号；若此处没有被地毯覆盖则输出 -1。
输入输出样例
输入 #1

3
1 0 2 3
0 2 3 3
2 1 3 3
2 2

输出 #1

3

输入 #2

3
1 0 2 3
0 2 3 3
2 1 3 3
4 5

输出 #2

-1

说明/提示

【样例解释 1】

如下图，111 号地毯用实线表示，222 号地毯用虚线表示，333 号用双实线表示，覆盖点 (2,2)(2,2)(2,2) 的最上面一张地毯是 333 号地毯。




【数据范围】

对于 30%30\%30% 的数据，有 n≤2n \le 2n≤2。
对于 50%50\%50% 的数据，0≤a,b,g,k≤1000 \le a, b, g, k \le 1000≤a,b,g,k≤100。
对于 100%100\%100% 的数据，有 0≤n≤1040 \le n \le 10^40≤n≤104, 0≤a,b,g,k≤1050 \le a, b, g, k \le {10}^50≤a,
 ,g,k≤105。

noip2011 提高组 day1 第 111 题。

code:
int main(){
    int n,x,y;cin>>n;
    int data[n][4]={0};
    for(int i=0;i<n;i++)for(int j=0;j<4;j++)cin>>data[i][j];
    cin>>x>>y;
    for(int i=n-1;0<=i;i--){
    if(data[i][0]<=x && x<=(data[i][0]+data[i][2]) &&
		data[i][1]<=y && y<=(data[i][1]+data[i][3])){
		cout<<i+1;
		return 0;
        }
	}
	cout<<"-1";
	return 0;
}

*/

/*
P1007 独木桥

题目背景

战争已经进入到紧要时间。你是运输小队长，正在率领运输部队向前线运送物资。运输任务像做题一样的无聊。你希望找些刺激，于是命令你的士兵们到前方的一座独木桥上欣赏风景，而你留在桥下欣赏士兵们。士兵们十分愤怒，因为这座独木桥十分狭窄，只能容纳111个人通过。假如有222个人相向而行在桥上相遇，那么他们222个人将无法绕过对方，只能有111个人回头下桥，让另一个人先通过。但是，可以有多个人同时呆在同一个位置。
题目描述

突然，你收到从指挥部发来的信息，敌军的轰炸机正朝着你所在的独木桥飞来！为了安全，你的部队必须撤下独木桥。独木桥的长度为LLL，士兵们只能呆在坐标为整数的地方。所有士兵的速度都为111，但一个士兵某一时刻来到了坐标为000或L+1L+1L+1的位置，他就离开了独木桥。

每个士兵都有一个初始面对的方向，他们会以匀速朝着这个方向行走，中途不会自己改变方向。但是，如果两个士兵面对面相遇，他们无法彼此通过对方，于是就分别转身，继续行走。转身不需要任何的时间。

由于先前的愤怒，你已不能控制你的士兵。甚至，你连每个士兵初始面对的方向都不知道。因此，你想要知道你的部队最少需要多少时间就可能全部撤离独木桥。另外，总部也在安排阻拦敌人的进攻，因此你还需要知道你的部队最多需要多少时间才能全部撤离独木桥。
输入格式

第一行：一个整数LLL，表示独木桥的长度。桥上的坐标为111…LLL

第二行：一个整数NNN，表示初始时留在桥上的士兵数目

第三行：有NNN个整数，分别表示每个士兵的初始坐标。
输出格式

只有一行，输出222个整数，分别表示部队撤离独木桥的最小时间和最大时间。222个整数由一个空格符分开。
输入输出样例
输入 #1

4
2
1 3

输出 #1

2 4

说明/提示

初始时，没有两个士兵同在一个坐标。

数据范围N≤L≤5000N \le L \le 5000N≤L≤5000。

code:
int main(){
    int l,n,p,mins=0,maxs=0;
    cin>>l>>n;
    for(int i=0;i<n;i++){
    cin>>p;
    maxs=max(maxs,max(l-p+1,p));
    mins=max(mins,min(l-p+1,p));
    }
    cout<<mins<<" "<<maxs;
    return 0;
}

*/

/*
P1008 [NOIP1998 普及组] 三连击

题目背景

本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。
题目描述

将 1,2,…,91, 2, \ldots , 91,2,…,9 共 999 个数分成 333 组，分别组成 333 个三位数，且使这 333 个三位数构成 1:2:31 
 2 : 31:2:3 的比例，试求出所有满足条件的 333 个三位数。
 输入格式

无
输出格式

若干行，每行 333 个数字。按照每行第 111 个数字升序排列。
输入输出样例
输入 #1

无

输出 #1

192 384 576
* * *
...

* * *
（剩余部分不予展示）

code:
int main(){
    int a,b,c;bool t=0;
    for(int i=123;i<=333;i++){
    a=i;b=i*2;c=i*3;
    if((a/100+a%100/10+a%10+b/100+b%100/10+b%10+c/100+c%100/10+c%10)==45 &&
    ((a/100)*(a%100/10)*(a%10)*(b/100)*(b%100/10)*(b%10)*(c/100)*(c%100/10)*(c%10))==362880)
    cout<<a<<" "<<b<<" "<<c<<endl;
    }
	return 0;
}

*/

/*
P1009 [NOIP1998 普及组] 阶乘之和

题目描述

用高精度计算出 S=1!+2!+3!+?+n!S = 1! + 2! + 3! + \cdots + n!S=1!+2!+3!+?+
!（n≤50n \le 50n≤50）。

其中“!”表示阶乘，例如：5!=5×4×3×2×15! = 5 \times 4 \times 3 \times 2 \times 15!=5×4×3×2×1。
 输入格式

一个正整数 nnn。
输出格式

一个正整数 SSS，表示计算结果。
输入输出样例
输入 #1

3

输出 #1

9

说明/提示

【数据范围】

对于 100%100 \%100% 的数据，1≤n≤501 \le n \le 501≤n≤50。

【其他说明】

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 n≤20n \le 20n≤20，使用书中的代码无法通过本题。




如果希望通过本题，请继续学习第八章高精度的知识。

code:int n,a[90],b[90],c[90],f[90],d=0,len_a,len_b=1,len_c=1,len_ans,m=1;
string s;
int main(){
    cin>>n;
    b[0]=1;
    for(int i=1;i<=n;i++){
        len_a=0;
        int p=i;
        while(p>0)a[len_a++]=p%10,p/=10;
        for(int j=0;j<len_a;j++)for(int k=0;k<=len_b;k++)c[j+k]+=a[j]*b[k];
        for(int j=0;j<len_c;j++)if(c[j]>9)c[j+1]+=c[j]/10,c[j]%=10;
        if(c[len_c])len_c++;
        len_ans=len_b,len_b=len_c,m=max(m,len_c);
        for(int k=len_c-1;k>=0;k--)b[k]=c[k];
        len_c=len_a+len_ans;
        memset(c,0,sizeof(c));
        for(int j=0;j<m;j++){
            f[j]+=b[j];
            if(f[j]>9)
f[j+1]+=f[j]/10,f[j]%=10;//进位，注意不要写成f[j+1]++，f[j]-=10;就因为这里wa了一个点
        }
    }
    while(!f[m]&&m>0) m--;
    for(int i=m;i>=0;i--) cout<<f[i];
    return 0;
}
//或者打表
// #include<iostream>
// using namespace std;
// string
// a[60]={"0","1","3","9","33","153","873","5913","46233","409113","4037913","43954713","522956313","6749977113","93928268313","1401602636313","22324392524313","378011820620313","6780385526348313","128425485935180313","2561327494111820313","53652269665821260313","1177652997443428940313","27029669736328405580313","647478071469567844940313","16158688114800553828940313","419450149241406189412940313","11308319599659758350180940313","316196664211373618851684940313","9157958657951075573395300940313","274410818470142134209703780940313","8497249472648064951935266660940313","271628086406341595119153278820940313","8954945705218228090637347680100940313","304187744744822368938255957323620940313","10637335711130967298604907294846820940313","382630662501032184766604355445682020940313","14146383753727377231082583937026584420940313","537169001220328488991089808037100875620940313","20935051082417771847631371547939998232420940313","836850334330315506193242641144055892504420940313","34289376947494122614363304694584807557656420940313","1439295494700374021157505910939096377494040420940313","61854558558074209658512637979453093884758552420940313","2720126133346522977702138448994068984204397080420940313","122342346998826717539665299944651784048588130840420940313","5624964506810915667389970728744906677010239883800420940313","264248206017979096310354325882356886646207872272920420940313","12678163798554051767172643373255731925167694226950680420940313","620960027832821612639424806694551108812720525606160920420940313","31035053229546199656252032972759319953190362094566672920420940313"};
// int main()
// {
//     int n;
//     cin>>n;
//     cout<<a[n];
// }
//需要选中之后ctrl+/取消或者选择注释

*/

/*
P1010 [NOIP1998 普及组] 幂次方

题目描述

任何一个正整数都可以用 222 的幂次方表示。例如 137=27+23+20137=2^7+2^3+2^0 137=27+23+20。



同时约定方次用括号来表示，即 aba^bab 可表示为 a(b)a(b)a(b)。

由此可知，137137137 可表示为 2(7)+2(3)+2(0)2(7)+2(3)+2(0)2(7)+2(3)+2(0)

进一步：

7=22+2+207= 2^2+2+2^07=22+2+20 ( 212^121 用 222 表示)，并且 3=2+203=2+2
03=2+20。

所以最后 137137137 可表示为 2(2(2)+2+2(0))+
(2+2(0))+2(0)2(2(2)+2+2(0))+2(2+2(0))+2(0)2(2(2)+2+2(0))+2(2+2(0))+2(0)。

又如 1315=210+28+25+2+11315=2^{10} +2^8 +2^5 +2+11315=210+28+25+2+1

所以 131513151315 最后可表示为 2(2(2+2(0))+2)+
(2(2+2(0)))+2(2(2)+2(0))+2+2(0)2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)。
输入格式

一行一个正整数 nnn。
输出格式

符合约定的 nnn 的 0,20, 20,2 表示（在表示中不能有空格）。
输入输出样例
输入 #1

1315

输出 #1

2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)

说明/提示

【数据范围】

对于 100%100\%100% 的数据，1≤n≤2×1041 \le n \le 2 \times {10}^41≤n≤2×104。

code:
int main(){
    int n,i;cin>>n;
    string s[16]={"2(0)","2","2(2)","2(2+2(0))","2(2(2))","2(2(2)+2(0))","2(2(2)+2)","2(2(2)+2+2(0))","2(2(2+2(0)))","2(2(2+2(0))+1)","2(2(2+2(0))+2)","2(2(2+2(0))+2+2(0))","2(2(2+2(0))+2(2))","2(2(2+2(0))+2(2)+2(0))","2(2(2+2(0))+2(2)+2)","2(2(2+2(0))+2(2)+2+2(0))"};
    bool t=0;
    for(i=16;0<=i;i--)
        if(n>=pow(2,i)){
            if(t==0){cout<<s[i];t=1;}
            else cout<<"+"<<s[i];
            n-=pow(2,i);
        }
    return 0;
}

*/

/*
P1011 [NOIP1998 提高组] 车站

题目描述

火车从始发站（称为第 111 站）开出，在始发站上车的人数为 aaa，然后到达第 222 站，在第 222 站有人上、下车，但上、下车的人数相同，因此在第 222 站开出时（即在到达第 333 站之前）车上的人数

 持为 aaa 人。从第 333 站起（包括第 333 站）上、下车的人数有一定规律：上车的人
都是前
站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站（第 (n?

)(n-1)(n?1) 站），都满足此规律。现给出的条件是：共有 nnn 个车站，始发站上车的人数为 aaa ，最后一站下车的人数是 mmm（全部下车）。试
 xxx 站开出时车上的人数是多少？





 输入格式

输入只有一行四个整数，分别表示始发站上车人数 aaa，车站数 nnn，终点站下车人数 mmm 和所求的站点编号 xxx。
 输出格式

输出一行一个整数表示答案：从 xxx 站开出时车上的人数。
输入输出样例
输入 #1

5 7 32 4

输出 #1

13

说明/提示

对于全部的测试点，保证 1≤a≤201 \leq a \leq 201≤a≤20，1≤x≤n≤201 \leq x \leq n \leq 201≤x≤n≤20，1≤m≤2×1041 \leq m \le
 2 \times 10^41≤m≤2×104。

code:
int main(){
    int sum1[25]={0},sum2[25]={0},a,n,m,x;
    cin>>a>>n>>m>>x;
    sum1[2]=1,sum1[3]=2;
    for(int i=4;i<n;i++)sum1[i]=sum1[i-1]+sum1[i-2]-1,sum2[i]=sum2[i-1]+sum2[i-2]+1;
    cout<<a*sum1[x]+(m-a*sum1[n-1])/sum2[n-1]*sum2[x];
    return 0;
}

*/

/*
P1012 [NOIP1998 提高组] 拼数

题目描述

设有 nnn 个正整数 a1…ana_1 \dots a_na1?…an?，将它
联接成一排，相邻数字首尾相接，组成一个最大的整数。
输入格式

第一行有一个整数，表示数字个数 nnn。

第二行有 nnn 个整数，表示给出的 nnn 个整数 aia_iai?。
输出格式

一个正整数，表示最大的整数
输入输出样例
输入 #1

3
13 312 343

输出 #1

34331213

输入 #2

4
7 13 4 246

输出 #2

7424613

说明/提示

对于全部的测试点，保证 1≤n≤201 \leq n \leq 201≤n≤20，1≤ai≤1091 \leq a_i \leq 10^91≤ai?≤109。


code:
bool cmp(string a,string b){
    return a+b>b+a;
}
int main(){
    int n;
    cin>>n;
    string a[n];
    for(int i=0;i<n;i++)
        cin>>a[i];
    sort(a,a+n,cmp);
    for(int i=0;i<n;i++)
        cout<<a[i];
    return 0;
}

*/

/*
P1015 [NOIP1999 普及组] 回文数

题目描述

若一个数（首位不为零）从左向右读与从右向左读都一样，我们就将其称之为回文数。

例如：给定一个十进制数 565656，将 565656 加 656565（即把 565656 从右向左读），得到 121121121 是一个回文数。


又如：对于十进制数 878787：

STEP1：87+78=16587+78=16587+78=165
STEP2：165+561=726165+561=726165+561=726
STEP3：726+627=1353726+627=1353726+627=1353
STEP4：1353+3531=48841353+3531=48841353+3531=4884

在这里的一步是指进行了一次 NNN 进制的加法，上例最少用了 444 步得到回文数 488448844884。


写一个程序，给定一个 NNN（2≤N≤102 \le N \le 102≤N≤10 或 N=16N=16N=16）进制数 MMM（100100100 位之内），求最少经过几步可以得到回文数。如果在 3
3030 步以内（包含 303030 步）不可能得到回文数，则输出 Impossible!。
 输入格式

两行，分别是 NNN，MMM。
输出格式

如果能在 303030 步以内得到回文数，输出格式形如 STEP=ans，其中 ansansans 为最少得到回文数的步数。


否则输出 Impossible!。
输入输出样例
输入 #1

10
87

输出 #1

STEP=4

code:
int main(){
    int n,step=0,a[401]={0},top=0;
    char s[201];bool judge=1;
    cin>>n>>s;
    top=strlen(s)-1;
    for (int i=0;i<=top;++i)
        if (s[i]>='0'&&s[i]<='9')a[top-i]=s[i]-'0';
        else a[top-i]=s[i]-55;
    while (judge){
        judge=0;
        int t=top/2;
        for(int i=0;i<=t;++i)if(a[i]!=a[top-i])judge=1;
        if (step>30) {cout<<"Impossible!";return 0;}
        for (int i=0;i<=top;++i)
            if (top-i>=i) a[i]+=a[top-i];
            else a[i]=a[top-i];
        for (int i=0;i<=top;++i) if (a[i]>=n) a[i+1]++,a[i]-=n;
        if (a[top+1])top++;
        step++;
    }
    cout<<"STEP="<<step-1;
    return 0;
}

*/

/*
P1028 [NOIP2001 普及组] 数的计算

题目描述

我们要求找出具有下列性质数的个数(包含输入的正整数 nnn)。

先输入一个正整数 nnn(n≤1000n \le 1000n≤1000),然后对此正
数按照如下方法进行处理：

    不作任何处理；

    在它的左边加上一个正整数,但该正整数不能超过原数的一半；

    加上数后,继续按此规则进行处理,直到不能再加正整数为止。

输入格式

111 个正整数 nnn(n≤1000n \le 1000n≤1000)
输出格式

111 个整数，表示具有该性质数的个数。
输入输出样例
输入 #1

6

输出 #1

6

说明/提示

满足条件的数为

6，16，26，126，36，136

【题目来源】

NOIP 2001 普及组第一题

code
int main(){
    int n;cin>>n;
    int f[n+1]={0};
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i/2;j++)f[i]+=f[j];
        f[i]++;
    }
    cout<<f[n];
    return 0;
}

*/

/*
P1029 [NOIP2001 普及组] 最大公约数和最小公倍数问题

题目描述

输入两个正整数 x0,y0x_0, y_0x0?,y0?，求出满足下列条件的 P,QP, QP,Q 的个数：

    P,QP,QP,Q 是正整数。

    要求 P,QP, QP,Q 以 x0x_0x0? 为最大公约数，以 y0y_0y0? 为最小公倍数。

试求：满足条件的所有可能的 P,QP, QP,Q 的个数。
输入格式

一行两个正整数 x0,y0x_0, y_0x0?,y0?。
输出格式

一行一个数，表示求出满足条件的 P,QP, QP,Q 的个数。
输入输出样例
输入 #1

3 60

输出 #1

4

说明/提示

P,QP,QP,Q 有 444 种：

    3,603, 603,60。
    15,1215, 1215,12。
    12,1512, 1512,15。
    60,360, 360,3。

对于 100%100\%100% 的数据，2≤x0,y0≤1052 \le x_0, y_0 \le {10}^52≤x0?,y0?≤105。

【题目来源】

NOIP 2001 普及组第二题

code:
long long gcd(long long a,long long b){
    long long da = max(a,b),xiao = min(a,b);
    if(da % xiao == 0) return xiao;
    else return gcd(xiao, da % xiao);
}
long long lcm(long long a,long long b){
    return a*b / gcd(a, b);
}
int main(){
    long long n,m;cin>>n>>m;
    int sum=0;
    for(long long i=n;i<=m;i++){
        long long p=i,q=n*m/p;
        if((p*q)==(n*m))if((gcd(p,q)==n)&&(lcm(p,q)==m))sum++;
    }
    cout<<sum;
}

/*
//参考代码
long long gcd(long long x,long long y){
    if(y==0)return x;
    return gcd(y,x%y);
}
int main(){
    long long m,n,ans=0,flag=0;
    cin>>n>>m;
    for(long long i=1;i<=sqrt(m*n);i++){
        if((n*m)%i==0&&gcd(i,(n*m)/i)==n){
            ans++;
            if(i*i==n*m)flag=1;
        }
    }
    cout<<ans*2-flag;
    return 0;
}
*/

/*
P1030 [NOIP2001 普及组] 求先序排列

题目描述

给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，长度≤8 \le 8≤8）。
输入格式

222行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。
输出格式

111行，表示一棵二叉树的先序。
输入输出样例
输入 #1

BADC
BDCA

输出 #1

ABCD

说明/提示

【题目来源】

NOIP 2001 普及组第三题

code:
string in_str,post_str;
void build(int l1,int r1,int l2,int r2){
    if(l1>r1) return;                  
    cout << post_str[r2];                 
    int p = l1;                                
    while(in_str[p] != post_str[r2]) p++;  
    int cnt = p-l1;                        
    build(l1,p-1,l2,l2+cnt-1);                
    build(p+1,r1,l2+cnt,r2-1);
}
int main(){
    cin  >> in_str >> post_str;
    build(0,in_str.length()-1,0,in_str.length()-1);                            
}

*/

/*
P1031 [NOIP2002 提高组] 均分纸牌

题目描述

有NNN堆纸牌，编号分别为 1,2,…,N1,2,…,N1,2,…,N。每堆上有若干张，但纸牌总数必为NNN的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为111堆上取的纸牌，只能移到编号为222的堆上；在编号为NNN的堆上取的纸牌，只能移到编号为N?1N-1N?1的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如N=4N=4N=4，444堆纸牌数分别为：

①999②888③171717④666

移动333次可达到目的：

从 ③ 取444张牌放到 ④ （9,8,13,109,8,13,109,8,13,10）-> 从 ③ 取333张牌放到 ②（9,11,10,109,11,10,109,11,10,10）-> 从 ② 取111张牌放到①（10,10,10,1010,10,10,1010,10,10,10）。
输入格式

两行

第一行为：NNN（NNN 堆纸牌，1≤N≤1001 \le N \le 1001≤N≤100）

第二行为：A1,A2,…,AnA_1,A_2, … ,A_nA1?,A2?,…,An? （NNN堆纸牌，每堆纸牌初始数，1≤Ai≤100001 \le A_i \le 100001≤Ai?≤10000）
输出格式

一行：即所有堆均达到相等时的最少移动次数。
输入输出样例
输入 #1

4
9 8 17 6

输出 #1

3

说明/提示

【题目来源】

NOIP 2002 提高组第一题

code:
int main(){
    int n,step=0,sum=0,t,p;
    cin>>n;
    int a[n];    
    for(int i=0;i<n;i++)
        cin>>a[i];  
    for(int i=0;i<n;i++)
        sum+=a[i];
    sum=sum/n;
    for(int i=0;i<n;i++)
        a[i]-=sum;  
    for(int i=0;i<n;i++){
        if(a[i]==0)continue;
        a[i+1]+=a[i];step++;
    }
    cout<<step;
 }

*/

/*
P1036 [NOIP2002 普及组] 选数

题目描述

已知 nnn 个整数 x1,x2,…,xnx_1,x_2,…,x_nx1?,x2?,…,xn?，以及111个整数kkk(k<nk<nk<n)。从nnn个整数中任选kkk个整数相加，可分别得到一系列的和。例如当n=4,k=3n=4,k=3n=4,k=3,444个整数分别为3,7,12,193,7,12,193,7,12,19时，可得全部的组合与它们的和为：

3+7+12=223+7+12=223+7+12=22

3+7+19=293+7+19=293+7+19=29

7+12+19=387+12+19=387+12+19=38

3+12+19=343+12+19=343+12+19=34。

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：3+7+19=293+7+19=293+7+19=29。
输入格式

键盘输入，格式为：

n,kn,kn,k(1≤n≤20,k<n1 \le n \le 20,k<n1≤n≤20,k<n)

x1,x2,…,xn(1≤xi≤5000000)x_1,x_2,…,x_n (1 \le x_i \le 5000000)x1?,x2?,…,xn?(1≤xi?≤5000000)
输出格式

屏幕输出，格式为： 111个整数（满足条件的种数）。
输入输出样例
输入 #1

4 3
3 7 12 19

输出 #1

1

说明/提示

【题目来源】

NOIP 2002 普及组第二题

code:
bool isprime(int n){
    for(int i=2;i<=sqrt(double(n));i++)if(n%i==0)return false;
    return true;
}
int rule(int f,int s,int start,int end,int x[]){
    if(f==0)return isprime(s);
    int sum=0;
    for(int i=start;i<=end;i++){
        sum+=rule(f-1,s+x[i],i+1,end,x);
    }
    return sum;
}
int main(){
    int n,k;
    cin>>n>>k;
    int x[n];
    for(int i =0;i<n;i++)cin>>x[i];
    cout<<rule(k,0,0,n-1,x);
    return 0;
}

*/

/*
P1042 [NOIP2003 普及组] 乒乓球

题目背景

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中111111分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白111111分制和212121分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。
题目描述

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在111111分制和212121分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中W表示华华获得一分，L表示华华对手获得一分）：

WWWWWWWWWWWWWWWWWWWWWWLW

在111111分制下，此时比赛的结果是华华第一局111111比000获胜，第二局111111比000获胜，正在进行第三局，当前比分111比111。而在212121分制下，此时比赛结果是华华第一局212121比000获胜，正在进行第二局，比分222比111。如果一局比赛刚开始，则此时比分为000比000。直到分差大于或者等于222，才一局结束。

你的程序就是要对于一系列比赛信息的输入（WLWLWL形式），输出正确的结果。
输入格式

每个输入文件包含若干行字符串，字符串有大写的WWW、LLL和EEE组成。其中EEE表示比赛信息结束，程序应该忽略E之后的所有内容。
输出格式

输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是111111分制下的结果，第二部分是212121分制下的结果，两部分之间由一个空行分隔。
输入输出样例
输入 #1

WWWWWWWWWWWWWWWWWWWW
WWLWE

输出 #1

11:0
11:0
1:1

21:0
2:1

说明/提示

每行至多25个字母，最多有2500行

【题目来源】

NOIP 2003 普及组第一题

code:
int main(){
    int n=0,m=0;
    string c,b;
    while(cin>>c)b=b+c;
    for(int i=0;i<b.length();i++){
        if(b[i]=='E')cout<<n<<':'<<m<<endl<<endl;
        if(b[i]=='W')n++;
        if(b[i]=='L')m++;
        if(abs(n-m)>=2&&((n>=11)||(m>=11))){
            cout<<n<<':'<<m<<endl;
            n=0;m=0;
        }
    }
    n=0;m=0;
    for(int i=0;i<b.length();i++){
        if(b[i]=='E')cout<<n<<':'<<m<<endl;
        if(b[i]=='W')n++;
        if(b[i]=='L')m++;
        if(abs(n-m)>=2&&((n>=21)||(m>=21))){
            cout<<n<<':'<<m<<endl;
            n=0;m=0;
        }
    }
}

*/

/*
P1044 [NOIP2003 普及组] 栈

题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。
题目描述

宁宁考虑的是这样一个问题：一个操作数序列，1,2,…,n1,2,\ldots ,n1,2,…,n（图示为 1 到 3 的情况），栈 A 的深度大于 nnn。

现在可以进行两种操作，

    将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
    将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 1 2 3 生成序列 2 3 1 的过程。

（原始状态如上图所示）

你的程序将对给定的 nnn，计算并输出由操作数序列 1,2,…,n1,2,\ldots,n1,2,…,n 经过操作可能得到的输出序列的总数。
 输入格式

输入文件只含一个整数 nnn（1≤n≤181 \leq n \leq 181≤n≤18）。
输出格式

输出文件只有一行，即可能输出序列的总数目。
输入输出样例
输入 #1

3

输出 #1

5

说明/提示

【题目来源】

NOIP 2003 普及组第三题

code:
long long n,f[50][50];          //方法一：递归/记忆化搜索：
long long dfs(int i,int j){     //i表示操作个数，j表示栈内个数
    if(f[i][j]) return f[i][j]; //有值就返回
    if(i==0)return 1;           //数都在栈内了
    if(j>0) f[i][j]+=dfs(i,j-1);//栈内有，出1
    f[i][j]+=dfs(i-1,j+1);      //栈内有，进1出1
    return f[i][j];
}
int main(){
    cin>>n;
    cout<<dfs(n,0);
    return 0;
}

方法二：
int main(){
    long long n,f[20][20]={0};          //递推 DP(动态规划)
    cin>>n;
    for(int i=0;i<=n;i++)
        f[0][i]=1;//i表示队列数，j表示出栈数，f[][]表示情况数 
    for(int i=1;i<=n;i++) 
        for(intj=i;j<=n;j++)
            if(i==j)f[i][j]=f[i-1][j];
            else f[i][j]=f[i][j-1]+f[i-1][j];
    cout<<f[n][n];
    return 0;
}

方法三：
int main(){
    long long n,f[20]={0};
    cin>>n;
    f[0]=f[1]=1;
        for(int i=2;i<=n;i++)
            for(int j=0;j<i;j++)
                f[i]+=f[j]*f[i-j-1];
    cout<<f[n];
    //另一个方法
    // f[0]=f[1]=1;
    //     cin>>n;
    // for(int i=2;i<=n;i++)
    //     f[i]+=f[i-1]*(4*i-2)/(i+1);
    // cout<<f[n];
    //另另一个方法
    // for(int i=1;i<=2*n;i++){
    //     f[i][0]=f[i][i]=1;
    //     for(int j=1;j<i;j++)f[i][j]=f[i-1][j]+f[i-1][j-1];
    // }
    // cout<<f[2*n][n]/(n+1);
    //另另另外一个方法
    // for(int i=1;i<=2*n;i++){
    //     f[i][0]=f[i][i]=1;
    //     for(int j=1;j<i;j++)f[i][j]=f[i-1][j]+f[i-1][j-1];
    // }
    // cout<<f[2*n][n]-f[2*n][n-1];
    return 0;
}

方法四：
#define MAX_N 110                   //高精度打表
int f[MAX_N][MAX_N],c[MAX_N];
inline int len(int a[]){
    int i;
    for(i=60;i>=0;i--)if(a[i]!=0) break;
    return i;
}
inline void add(int a[],int b[],int w){
    int lena=len(a),lenb=len(b);
    for(int i=0;i<=max(lena,lenb);i++)f[w][i]=a[i]+b[i];
        for(int i=0;i<=max(lena,lenb)+1;i++){
            f[w][i+1]+=f[w][i]/10;
            f[w][i]%=10;
        }
}
inline void Catalan(int a[],int b[]){
    memset(c, 0, sizeof(c));
    int lena=len(a),lenb=len(b);
    for (int i=0;i<=lena;i++)for (int j=0;j<=lenb;j++)c[i+j]+=a[i]*b[j];
        for (int i=0;i<=lena+lenb+1;i++){
        c[i+1]+=c[i]/10;
        c[i]%=10;
        }
}
int main(){
    freopen("Catalan.txt","w"stdin);//文件操作
    f[0][0]=f[1][0]=1;
    for (int i=2;i<=100;i++){
        for (int j=0;j<i;j++){
            Catalan(f[j], f[i-j-1]);
            add(f[i],c,i);
        }
    }
    for(int i=1;i<=100;i++){
        for (int j=len(f[i]);j>=0;j--)putchar((char)f[i][j]+'0');
        printf("\n");
    }
    return 0;
}

*/

/*
P1048 [NOIP2005 普及组] 采药

题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是辰辰，你能完成这个任务吗？
输入格式

第一行有 222 个整数 TTT（1≤T≤10001 \le T \le 10001≤T≤1000）和 MMM（1≤M≤1001 \le M \le 1001≤M≤100），用一个空格隔开，TTT 代表总
 能够用来采药的时间，MMM 代表山洞里的草药的数目。




接下来的 MMM 行每行包括两个在 111 到 100100100 之间（包括 111 和 100100100）的整数，分别表示采摘某株草药的时间和这株草药的价值。
 输出格式

输出在规定的时间内可以采到的草药的最大总价值。
输入输出样例
输入 #1

70 3
71 100
69 1
1 2

输出 #1

3

说明/提示

【数据范围】

    对于 30%30\%30% 的数据，M≤10M \le 10M≤10；
    对于全部的数据，M≤100M \le 100M≤100。

【题目来源】

NOIP 2005 普及组第三题

code:
int main(){//一维dp
    int t,m;
    cin>>t>>m;//t代表背包容量 m代表有多少物品
    int w[m+1]={0}, val[m+1]={0},dp[t+1]={0};
    for(int i=1;i<=m;i++)cin>>w[i]>>val[i];//w代表所需容量 val代表物品价值
    for(int i=1;i<=m;i++)
        for(int j=t;j>=0;j--)
            if(j>=w[i])
                dp[j]=max(dp[j-w[i]]+val[i], dp[j]);//如果放得下,就取 
                                                    //放得下这次的方式和不放这次方式的最大值
    cout<<dp[t];//输出当t容量的时候,价值的最大值
    return 0;
}

int main(){//二维dp
    int t,m;cin>>t>>m;
    int w[m+1]={0},val[m+1]={0},dp[m+1][1005]={0};
    for(int i=1;i<=m;i++)cin>>w[i]>>val[i];
    for(int i=1;i<=m;i++) 
        for(int j=t;j>=0;j--)
            if(j>=w[i]) dp[i][j]=max(dp[i-1][j-w[i]]+val[i],dp[i-1][j]);//如果放得下,就取 放得下这次的方式和不放这次方式的最大值
            else dp[i][j]=dp[i-1][j];//如果放不下就顺延上一次的最大值
    cout<<dp[m][t];//输出前m个物体、t容量的时候,价值的最大值
    return 0;
}

*/

/*
P1049 [NOIP2001 普及组] 装箱问题

题目描述

有一个箱子容量为VVV（正整数，0≤V≤200000 \le V \le 200000≤V≤20000），同时有nnn个物品（0<n
 300<n \le
300<n≤30，每个物品有一个体积（正整数）。


要求nnn个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。
输入格式

111个整数，表示箱子容量

111个整数，表示有nnn个物品

接下来nnn行，分别表示这nnn个物品的各自体积
输出格式

111个整数，表示箱子剩余空间。
输入输出样例
输入 #1

24
6
8
3
12
7
9
7

输出 #1

0

说明/提示

【题目来源】

NOIP 2001 普及组第四题

code:
int main(){
    int m,n;cin>>m>>n;
    int f[m+1]={0},w[n]={0};
    for(int i=0;i<n;i++)cin>>w[i];
    for(int i=0;i<n;i++)
        for(int j=m;j>=w[i];j--)
            if(f[j]<f[j-w[i]]+w[i])f[j]=f[j-w[i]]+w[i];
    cout<<m-f[m];
    return 0;
}

*/

/*
P1051 [NOIP2005 提高组] 谁拿了最多奖学金

题目描述

某校的惯例是在每学期的期末考试之后发放奖学金。发放的奖学金共有五种，获取的条件各自不同：

    院士奖学金，每人800080008000元，期末平均成绩高于808080分（>80>80>80），并且在本学期内发表111篇或111篇以上论文的学生均可获得；
    五四奖学金，每人400040004000元，期末平均成绩高于858585分（>85>85>85），并且班级评议成绩高于808080分（>80>80>80）的学生均可获得；
    成绩优秀奖，每人200020002000元，期末平均成绩高于909090分（>90>90>90）的学生均可获得；
    西部奖学金，每人100010001000元，期末平均成绩高于858585分（>85>85>85）的西部省份学生均可获得；
    班级贡献奖，每人850850850元，班级评议成绩高于808080分（>80>80>80）的学生干部均可获得；

只要符合条件就可以得奖，每项奖学金的获奖人数没有限制，每名学生也可以同时获得多项奖学金。例如姚林的期末平均成绩是878787分，班级评议成绩828282分，同时他还是一位学生干部，那么他可以同时获得五四奖学金和班级贡献奖，奖金总数是485048504850元。

现在给出若干学生的相关数据，请计算哪些同学获得的奖金总数最高（假设总有同学能满足获得奖学金的条件）。
输入格式

第一行是111个整数N(1≤N≤100)N(1 \le N \le 100)N(1≤N≤100)，表示学生的总数。

接下来的NNN行每行是一位学生的数据，从左向右依次是姓名，期末平均成绩，班级评议成绩，是否是学生干部，是否是西部省份学生，以及发表的论文数。姓名是由大小写英文字母组成的长度不超过202020的字符串（不含空格）；期末平均成绩和班级评议成绩都是000到100100100之间的整数（包括000和100100100）；是否是学生干部和是否是西部省份学生分别用111个字符表示，YYY表示是，NNN表示不是；发表的论文数是000到101010的整数（包括000和101010）。每两个相邻数据项之间用一个空格分隔。
输出格式

包括333行。

第111行是获得最多奖金的学生的姓名。

第222行是这名学生获得的奖金总数。如果有两位或两位以上的学生获得的奖金最多，输出他们之中在输入文件中出现最早的学生的姓名。

第333行是这NNN个学生获得的奖学金的总数。
输入输出样例
输入 #1

4
YaoLin 87 82 Y N 0
ChenRuiyi 88 78 N Y 1
LiXin 92 88 N N 0
ZhangQin 83 87 Y N 1

输出 #1

ChenRuiyi
9000
28700

说明/提示

【题目来源】

NOIP 2005 提高组第一题

code:
int main(){
    int n,sum=0,grade=0,maxgrade=0,g,a,b;cin>>n;
    string c,d;
    char e,f;
    for(int i=0;i<n;i++){
        grade=0;
        cin>>c>>a>>b>>e>>f>>g;
        if(a>80 && g>0)grade+=8000;
        if(a>85 && b>80)grade+=4000;
        if(a>90)grade+=2000;
        if(a>85 && f=='Y')grade+=1000;
        if(b>80 && e=='Y')grade+=850;
        sum+=grade;
        if(grade>maxgrade)maxgrade=grade,d=c;
    }
    cout<<d<<endl<<maxgrade<<endl<<sum;
    return 0;
}

*/

/*
P1055 [NOIP2008 普及组] ISBN 号码

题目描述

每一本正式出版的图书都有一个ISBN号码与之对应，ISBN码包括999位数字、111位识别码和333位分隔符，其规定格式如x-xxx-xxxxx-x，其中符号-就是分隔符（键盘上的减号），最后一位是识别码，例如0-670-82162-4就是一个标准的ISBN码。ISBN码的首位数字表示书籍的出版语言，例如000代表英语；第一个分隔符-之后的三位数字代表出版社，例如670670670代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。

识别码的计算方法如下：

首位数字乘以111加上次位数字乘以222……以此类推，用所得的结果?mod?11 \bmod 11mod11，所得的余数即为识别码，如果余数为101010，则识别码为大写字母XXX。例如ISBN号码0-670

82162-4中的识别码444是这样得到的：对067082162这999个数字，从左至右，分别乘以1,2,...,91,2,...,91,2,...,9再求和，即0×1+6×2+……+2×9=1580×1+6×2+……+2×9=1580×1+6×2+……+2×9=158，然后取158?mod?11158 \bmod 11158mod11的结果444作为识别码。



你的任务是编写程序判断输入的ISBN号码中识别码是否正确，如果正确，则仅输出Right；如果错误，则输出你认为是正确的ISBN号码。
输入格式

一个字符序列，表示一本书的ISBN号码（保证输入符合ISBN号码的格式要求）。
输出格式

一行，假如输入的ISBN号码的识别码正确，那么输出Right，否则，按照规定的格式，输出正确的ISBN号码（包括分隔符-）。
输入输出样例
输入 #1

0-670-82162-4

输出 #1

Right

输入 #2

0-670-82162-0

输出 #2

0-670-82162-4

说明/提示

2008普及组第一题

code:
int main(){
    int a,b,c,g,p;char f;
    char d;
    cin>>a>>f>>b>>f>>c>>f>>d;
    if(d=='X')p=10;
    else p=int(d)-int('0');
    g=a*1+(b/100)*2+((b/10)%10)*3+(b%10)*4+(c/10000)*5+((c/1000)%10)*6+((c/100)%10)*7+((c/10)%10)*8+(c%10)*9;
    if(g%11 == p)cout<<"Right";
    else if(g%11 == 10)cout<<a<<f<<b<<f<<c<<f<<'X';
    else cout<<a<<f<<b<<f<<c<<f<<g%11;
    return 0;
}

*/

/*
P1060 [NOIP2006 普及组] 开心的金明

题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过NNN元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的NNN元。于是，他把每件物品规定了一个重要度，分为555等：用整数1?51-51?5表示，第555等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过NNN元（可以等于NNN元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第jjj件物品的价格为v[j]v[j]v[j]，重要度为w[j]w[j]w[j]，共选中了kkk件物品，编号依次为j1,j2,…,jkj_1,j_2,…,j_kj1?,j2?,…,jk?，则所求的总和为：

v[j1]×w[j1]+v[j2]×w[j2]+…+v[jk]×w[jk]v[j_1] \times w[j_1]+v[j_2] \times w[j_2]+ …+v[
 _k] \times w[j_k]
[j1?]×w[j1?]+v[j2?]×w[j2?]+…+v[jk?]×w[jk?]。

请你帮助金明设计一个满足要求的购物单。
输入格式

第一行，为222个正整数，用一个空格隔开：n,mn,mn,m（其中N(<30000)N(<30000)N(<30000)表示总钱数，m(<25)m(<25)m(<25)为希望购买物品的个数。）

从第222行到第m+1m+1m+1行，第jjj行给出了编号为j?1j-1j?1的物品的基本数据，每行有222个非负整数vp v pvp（其中vvv表示该物品的价格(v≤10000)(v \le 10000)(v≤10000)，ppp表示该物品的重要度(1?5



 -51?5) 输出格式

111个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值(<100000000)(<100000000)(<100000000)。
输入输出样例
输入 #1

1000 5
800 2
400 5
300 5
400 3
200 2

输出 #1

3900

说明/提示

NOIP 2006 普及组 第二题

code:
int main(){
    int n,m;
    cin>>m>>n;
    int w[n]={0},v[n]={0},f[m+1]={0};
    for(int i=0;i<n;i++){
        cin>>v[i]>>w[i];
        w[i]*=v[i];
    }
    for(int i=0;i<n;i++)
        for(int j=m;j>=v[i];j--)
            if(j>=v[i])
                f[j]=max(f[j],f[j-v[i]]+w[i]);
    cout<<f[m-1]<<endl;
    return 0;
}

*/

/*
P1067 [NOIP2009 普及组] 多项式输出

题目描述

一元nnn次多项式可用如下的表达式表示：

f(x)=anxn+an?1xn?1+?+a1x+a0,an≠0f(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots +a_1x+a
0,a_n\ne 0 f(x)=an?xn+an?1?xn?1+?+a1?x+a0?,an?=0

其中，aixia_ix^iai?xi称为iii次项，aia_iai? 称为iii次项的系数。给出一个一元多项
各项的次数和系数，请按照如下规定的格式要求输出该多项式：

    多项式中自变量为x xx，从左到右按照次数递减顺序给出多项式。

    多项式中只包含系数不为000的项。

    如果多项式nnn次项系数为正，则多项式开头不出现“+”号，如果多项式nnn次项系数为负，则多项式以“-”号开头。

对于不是最高次的项，以“+”号或者“-”号连接此项与前一项，分别表示此项系数为正或者系数为负。紧跟一个正整数，表示此项系数的绝对值（如果一个高于000次的项，其系数的绝对值为111，则无需输出 111）。如果xxx的指数大于111，则接下来紧跟的指数部分的形式为“xbx^bxb”，其中 bb b为 xx x的指数；如果 xxx的指数为1 11，则接下来紧跟的指数部分形式为“xxx”；如果 xxx 的指数为0 00，则仅需输出系数即可。




多项式中，多项式的开头、结尾不含多余的空格。
输入格式

输入共有 222 行

第一行1 11 个整数，nnn，表示一元多项式的次数。

第二行有 n+1n+1 n+1个整数，其中第i i i个整数表示第n?i+1 n-i+1n?i+1 次项的系数，每两个整数之间用空格隔开。
 输出格式

输出共 111 行，按题目所述格式输出多项式。
输入输出样例
输入 #1

5
100 -1 1 -3 0 10

输出 #1

100x^5-x^4+x^3-3x^2+10

输入 #2

3
-50 0 0 1

输出 #2

-50x^3+1

说明/提示

NOIP 2009 普及组 第一题

对于100%数据，0≤n≤1000 \le n \le 1000≤n≤100,?100≤-100 \le ?100≤系数≤100 \le 100≤100

code:
int main(){
    int n,a;
    cin>>n;
    for(int i=n;i>=0;i--){
        cin>>a;
        if(a){
            if(i!=n&&a>0)cout<<"+";
            if(abs(a)>1||i==0)cout<<a;
            if(a==-1&&i)cout<<"-";
            if(i>1)cout<<"x^"<<i;
            if(i==1)cout<<"x";
        }
    }
    return 0;
}

*/

/*
P1068 [NOIP2009 普及组] 分数线划定

题目描述

世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，AAA市对
有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的150%150\%150%划定，即如果计划录取mmm名志愿者，则面试分数线为排名第m×150%m \times 150\%m×150%（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。





现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。
输入格式

第一行，两个整数 n,m(5≤n≤5000,3≤m≤n)n,m(5 ≤ n ≤ 5000,3 ≤ m ≤ n)n,m(5≤n≤5000,3≤m≤n)，中间用一个空格隔开

其中nnn表示报名参加笔试的选手总数，mmm表示计划录取的志愿者人数。输入数据保证 m×150%m \times 150\%m×150%向下取整后小于等于 nnn。



第二行到第 n+1n+1n+1 行，每行包括两个整
，中间用一个空格隔开，分别是选手的报名号 k(1000≤k≤9999)k(1000 ≤ k ≤ 9999)k(1000≤k≤9999)和该选手的笔试成绩s(1≤s≤100) s(1
 ≤ s ≤ 100
s(1≤s≤100)。数据保证选手的报名号各不相同。 输出格式

第一行，有222个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。

从第二行开始，每行包含222个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。
输入输出样例
输入 #1

6 3
1000 90
3239 88
2390 95
7231 84
1005 95
1001 88

输出 #1

88 5
1005 95
2390 95
1000 90
1001 88
3239 88

说明/提示

【样例说明】

m×150%=3×150%=4.5m \times 150\% = 3 \times150\% =
4.5m×150%=3×150%=4.5，向下取整后为444。保证444个人进入面试的分数线为888888，但因为888888有重分，所以所有成绩大于等于888888 的选手都可以进入面试，故最终有555个人进入面试。



NOIP 2009 普及组 第二题

code:
int k[5001],s[5001],sub[5001];
bool cmp(int a,int b){
    if(s[a]==s[b])return k[a]<k[b];
    return s[a]>s[b];
}
int main(){
    int i,n,m;
    cin>>n>>m;
    for(i=1;i<=n;i++)
        cin>>k[sub[i]=i]>>s[i];
    sort(sub+1,sub+n+1,cmp);
    int f=s[sub[int(m*1.5)]];
    for(i=1;s[sub[i]]>=f;i++)
        ;
    cout<<f<<" "<<i-1<<endl;
    for(i=1;s[sub[i]]>=f;i++)
        cout<<k[sub[i]]<<" "<<s[sub[i]]<<endl;
}

*/

/*
P1079 [NOIP2012 提高组] Vigenère 密码

题目描述

16 世纪法国外交家 Blaise de Vigenère 设计了一种多表密码加密算法 Vigenère 密码。Vigenère 密码的加密解密算法简单易用，且破译难度比较高，曾在美国南北
争中为南军所广泛使用。


在密码学中，我们称需要加密的信息为明文，用 MMM 表示；称加密后的信息为密文，用 CCC 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 kkk。 在 Vigenère 密码中，密钥 k
k 是
个字母串，k=k1,k2,…,knk=k_1,k_2,…,k_nk=k1?,k2?,…,kn?。当明文 M=m1,m2,…,mnM=m_1,m_2,…,m_nM=m1?,m2?,…,mn? 时，得到的密文 C=c1,c2,…,cnC=c_1,c_2,…
c_nC=c1?,c2?,…,cn?，其中 cic_ici?=mim_imi??kik
iki?，运算?的规则如下表所示：




Vigenère 加密在操作时需要注意：

    ?运算忽略参与运算的字母的大小写，并保持字母在明文 MMM 中的大小写形式；

    当明文 MMM 的长度大于密钥 kkk 的长度时，将密钥 kkk 重复使用。

例如，明文 M=HelloworldM=\texttt{Helloworld}M=Helloworld，密钥 k=abck=\texttt{
bc}k=abc 时，密文 C=HfnlpyosndC=\texttt{H
nlpyosnd}C=Hfnlpyosnd。

输入格式

共 2 行。

第一行为一个字符串，表示密钥 kkk，长度不超过 100100100，其中仅包含大小写字母。

第二行为一个字符串，表示经加密后的密文，长度不超过 100010001000，其中仅包含大小写字母。
 输出格式

一个字符串，表示输入密钥和密文所对应的明文。
输入输出样例
输入 #1

CompleteVictory
Yvqgpxaimmklongnzfwpvxmniytm

输出 #1

Wherethereisawillthereisaway

说明/提示

对于 100%100\%100% 的数据，输入的密钥的长度不超过 100100100，输入的密文的长度不超过 10001000100
，且都仅包含英文字母。

NOIP 2012 提高组 第一天 第一题

code:
int main() {
	string k,c;
	cin>>k>>c;
	for (int i=0;i<c.length();i++) {
		int t=(k[i%k.length()]&31)-1;
		c[i]=(c[i]&31)-t>0?c[i]-t:c[i]-t+26;
	}
	cout<<c<<endl;
	return 0;
}

*/

/*
P1086 [NOIP2004 普及组] 花生采摘

题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！DD熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图111）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

     从路边跳到最靠近路边（即第一行）的某棵花生植株；

     从一棵植株跳到前后左右与之相邻的另一棵植株；

     采摘一棵植株下的花生；

     从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于(2,5),(3,7),(4,2),(5,4)(2, 5), (3, 7), (4, 2), (5, 4)(2,5),(3,7),(4,2),(5,4)的植
 下长有花生，个数分别为13,7,15,913, 7, 15, 913,7,15,9。沿着图示的路线，多多
212121个单位时间内，最多可以采到373737个花生。

输入格式

第一行包括三个整数，M,NM, NM,N和KKK，用空格隔开；表示花生
的大小为M×N(1≤M,N≤20)M \times N(1 \le M, N \le 20)M×N(1≤M,N
20)，多多采花生的限定时间为K(0≤K≤1000)K(0 \le K \le 1000)
(0≤K≤1000)个单位时间。接下来的MMM行，每行包括NNN个非负整数，也用空格隔开；第i+1i + 1i+1行的第jjj个整数Pij(0≤Pij≤500)P_{ij
 (0 \le P_{ij} \le
500)Pij?(0≤Pij?≤500)表示花生田里植株(i,j)(i, j)(i,j)下花生的数目，000表示该植株下
有花生。


 输出格式

一个整数，即在限定时间内，多多最多可以采到花生的个数。
输入输出样例
输入 #1

6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0

输出 #1

37

输入 #2

6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0

输出 #2

28

说明/提示

noip2004普及组第2题

code:
int m,n,t,i,j,k=1,u,ans;
struct peanuts{
    int x,y,time,w;
}p[401];
int a[21][21];
int main(){
    cin>>m>>n>>t;
    for(i=1;i<=m;i++)
       for(j=1;j<=n;j++){
          cin>>a[i][j];
             if(a[i][j]>0) {
                 p[k].w=a[i][j];
                 p[k].x=i;
                 p[k].y=j;
                 k++;
                }
        }
    for(i=1;i<k;i++)
       for(j=i+1;j<=k;j++)
          if(p[i].w<p[j].w)
            swap(p[i],p[j]);
    for(i=1;i<=k;i++){
        u=p[i].x;
        if(i==1)
            p[i].time=p[i].x+1;
        else
        p[i].time=p[i-1].time+abs(p[i].x-p[i-1].x)+abs(p[i].y-p[i-1].y)+1;
        if (p[i].time+u<=t) ans+=p[i].w;
        else if (p[i].time+u>t) break;
    }
    cout<<ans;
    return 0;
}

*/

/*
P1087 [NOIP2004 普及组] FBI 树

题目描述

我们可以把由“000”和“111”组成的字符串分为三类：全“000”串称为BBB串，全“111”串称为I串，既含“000”又含“111”的串则称为F串。

FBIFBIFBI树是一种二叉树，它的结点类型也包括FFF结点，BBB结点和I结点三种。由一个长度为2N2^N2N的“010101”串S可以构造出一棵FBIFBIFBI树TTT，递归的构造方法如下：

    TTT的根结点为RRR，其类型与串SSS的类型相同；
    若串SSS的长度大于111，将串SSS从中间分开，分为等长的左右子串S1S_1S1?和S2S_2S2?；由左子串S1S_1S1?构造R的左子树T1T_1T1?，由右子串S2S_2S2?构造RRR的右子树T2T_2T2?。

现在给定一个长度为2N2^N2N的“010101”串，请用上述构造方法构造出一棵FBIFBIFBI树，并输出它的后序遍历序列。
输入格式

第一行是一个整数N(0≤N≤10)N(0 \le N \le 10)N(0≤N≤10)，

第二行是一个长度为2N2^N2N的“010101”串。
输出格式

一个字符串，即FBIFBIFBI树的后序遍历序列。
输入输出样例
输入 #1

3
10001011

输出 #1

IBFBBBFIBFIIIFF

说明/提示

对于40%的数据，N≤2N \le 2N≤2；

对于全部的数据，N≤10N \le 10N≤10。

noip2004普及组第3题

code:
char FBI(string s){
    if (s.length() > 1)	cout << FBI(s.substr(0, s.length()/2))<<FBI(s.substr(s.length()/2, s.length()/2));
    if (s == string(s.length(), '0')) return 'B';
    else if (s == string(s.length(), '1')) return 'I';
    else return 'F';
}
int main(){
    int n;
    string s;
    cin >> n >> s;
    cout << FBI(s);
    return 0;
}

*/

/*
P1093 [NOIP2007 普及组] 奖学金

题目描述

某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前5名学生发奖学金。期末，每个学生都有3门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。




任务：先根据输入的3门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前5名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:




777 279279279
555 279279279

这两行数据的含义是:总分最高的两个同学的学号依次是777号、555号。这两名同学的总分都是 279279279 (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为777的学生语文成绩更高一些。如果你的前两名的输出数据是:







555 279279279
777 279279279

则按输出错误处理，不能得分。
输入格式

共n+1行。

第111行为一个正整数n(≤300)n( \le 300)n(≤300)，表示该校参加评选的学生人数。

第222到n+1n+1n+1行，每行有333个用空格隔开的数字，每个数字都在000到100100100之间。第jjj行的333个数字依次表示学号为j?1j-1j?1的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为1 n1~n1 n（恰好是输入数据的行号减111）。




所给的数据都是正确的，不必检验。

//感谢 黄小U饮品 修正输入格式
输出格式

共5行，每行是两个用空格隔开的正整数，依次表示前555名学生的学号和总分。
输入输出样例
输入 #1

6
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98

输出 #1

6 265
4 264
3 258
2 244
1 237

输入 #2

8
80 89 89
88 98 78
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98

输出 #2

8 265
2 264
6 264
1 258
5 258

code:
int main(){
    int n,a,b,c;;cin>>n;
    long long sum[n]={0};
    for(int i=0;i<n;i++){
        cin>>a>>b>>c;//222-yuwen3-xuehao3
        sum[i]=(a+b+c)*1000000+a*1000+1000-i-1;
    }
    sort(sum,sum+n);
    for(int i=n-1;i>(n-1-5);i--)cout<<1000-sum[i]%1000<<"
"<<sum[i]/1000000<<endl; return 0;
}

*/

/*
P1094 [NOIP2007 普及组] 纪念品分组

题目描述

元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内
完所有纪念品，乐乐希望分组的数目最少。


你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。
输入格式

共 n+2n+2n+2 行：

第一行包括一个整数 www，为每组纪念品价格之和的上上限。

第二行为一个整数 nnn，表示购来的纪念品的总件数 GGG。

第 3?n+23\sim n+23?n+2 行每行包含一个正整数 PiP_iPi? 表示所对应纪念品的价格。
 输出格式

一个整数，即最少的分组数目。
输入输出样例
输入 #1

100
9
90
20
20
30
50
60
70
80
90

输出 #1

6

说明/提示

50%50\%50% 的数据满足：1≤n≤151\le n\le151≤n≤15。

100%100\%100% 的数据满足：1≤n≤3×1041\le n\le3\times10^41≤n≤3×104，80≤w≤20080\le w\le20080≤w≤200，5≤Pi≤w5 \le
P_i \le w5≤Pi?≤w。

code:
int main(){
    int w,n;cin>>w>>n;
    int a[n]={0};
    for(int i=0;i<n;i++)
        cin>>a[i];
    sort(a,a+n);
    int left=0,right=n-1,sum=0;
    while(left<=right){
        if(left==right){
            sum++;
            break;
            }
        if(a[left]+a[right]>w){
            sum++;
            right--;
            }
        else {
            sum++;
            left++;
            right--;
        }
    }
    cout<<sum<<endl;
    return 0;
}

*/

/*
P1097 [NOIP2007 提高组] 统计数字

题目背景

#警告：数据可能存在加强
题目描述

某次科研调查时得到了nnn个自然数，每个数均不超过1500000000(1.5×109)1500000000(1.5 \times 10^9)1500000000(1.5×109)。已知不相同的数不超过10
 001000
10000个，现在需要统计这些自然数各自出现的次数，并按照自然数从小到大的顺序输出统计结果。
输入格式

共n+1n+1n+1行。

第一行是整数nnn，表示自然数的个数；

第222至n+1n+1n+1每行一个自然数。
输出格式

共mmm行（mmm为nnn个自然数中不相同数的个数），按照自然数从小到大的顺序输出。

每行输出222个整数，分别是自然数和该数出现的次数，其间用一个空格隔开。
输入输出样例
输入 #1

8
2
4
2
4
5
100
2
100

输出 #1

2 3
4 2
5 1
100 2

说明/提示

40%40\%40%的数据满足：1≤n≤10001 \le n \le 10001≤n≤1000

80%80\%80%的数据满足：1≤n≤500001 \le n \le 500001≤n≤50000

100%100\%100%的数据满足：1≤n≤2000001 \le n \le 2000001≤n≤20000
，每个数均不超过1500000000(1.5×109)1500 000 000(1.5 \times 109)1500000000(1
5×109)


NOIP 2007 提高第一题

code:
int main(){
    int n,number=0;cin>>n;
    long long a[n]={0};
    for(int i=0;i<n;i++)
        cin>>a[i];
    sort(a,a+n);
    long long data=a[0];
    for(int i=0;i<n;i++){
        if(data==a[i])
            number++;
        else {
            cout<<data<<" "<<number<<endl;
            data=a[i];
            number=1;
        }
    }
    if(number!=0)
        cout<<data<<" "<<number;
    return 0;
}
//巨佬通用代码
int main() {
    map <int,int> a;
    set <int> b;
    int n,i,q;
    cin>>n;
    for(i=1; i<=n; i++) {
        cin>>q;
        a[q]++;
        b.insert(q);
    }
    for(set<int>::iterator it=b.begin(); it!=b.end(); it++)
        cout<<*it<<" "<<a[*it]<<endl;
}

*/

/*
P1098 [NOIP2007 提高组] 字符串的展开

题目描述

在初赛普及组的“阅读程序写结果”的问题中，我们曾给出一个字符串展开的例子：如果在输入的字符串中，含有类似于“d-h”或者“4-8”的字串，我们就把它当作一种简写，输出时，用连续递增的字母或数字串替代其中的减号，即，将上面两个子串分别输出为“defgh”和“45678"。在本题中，我们通过增加一些参数的设置，使字符串的展开更为灵活。具体约定如下：

(1)
遇到下面的情况需要做字符串的展开：在输入的字符串中，出现了减号“-”，减号两侧同为小写字母或同为数字，且按照ASCII码的顺序，减号右边的字符严格大于左边的字符。

(2)
参数p1p_1p1?：展开方式。p1=1p_1=1p1?=1时，对于字母子串，填充小写字母；p1=2p_1=2p1?=2时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同。p1=3p_1=3p1?=3时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号“*”来填充。

(3)
参数p2p_2p2?：填充字符的重复个数。p2=kp_2=kp2?=k表示同一个字符要连续填充k个。例如，当p2=3p_2=3p2?=3时，子串“d-h”应扩展为“deeefffgggh”。减号两边的字符不变。

(4)
参数p3p_3p3?：是否改为逆序：p3=1p3=1p3=1表示维持原来顺序，p3=2p_3=2p3?=2表示采用逆序输出，注意这时候仍然不包括减号两端的字符。例如当p1=1p_1=1p1?=1、p2=2p_2=2p2?=2、p3=2p_3=2p3?=2时，子串“d-h”应扩展为“dggffeeh”。

(5)
如果减号右边的字符恰好是左边字符的后继，只删除中间的减号，例如：“d-e”应输出为“de”，“3-4”应输出为“34”。如果减号右边的字符按照ASCII码的顺序小于或等于左边字符，输出时，要保留中间的减号，例如：“d-d”应输出为“d-d”，“3-1”应输出为“3-1”。
输入格式

共两行。

第111行为用空格隔开的333个正整数，依次表示参数p1,p2,p3p_1,p_2,p_3p1?,p2?,p3?。

第222行为一行字符串，仅由数字、小写字母和减号“?-?”组成。行首和行末均无空格。
输出格式

共一行，为展开后的字符串。
输入输出样例
输入 #1

1 2 1
abcs-w1234-9s-4zz

输出 #1

abcsttuuvvw1234556677889s-4zz

输入 #2

2 3 2
a-d-d

输出 #2

aCCCBBBd-d

说明/提示

40%40\%40%的数据满足：字符串长度不超过555

100%100\%100%的数据满足：1≤p1≤3,1≤p2≤8,1≤p3≤21 \le p_1 \le 3,1 \le p_2 \le 8,1 \le p_3 \le 21≤p1?≤3,1≤
 2?≤8,1≤p3?≤
。字符串长度不超过100100100

NOIP 2007 提高第二题

code:
int main() {
    int p1,p2,p3,i=0,k;
    char ch[300],be,af,f,j,p;
    cin>>p1>>p2>>p3>>ch;
    while(ch[i]){
        be=ch[i-1];af=ch[i+1];f=ch[i];
        if(f=='-'&&af>be&&(be>='0'&&af<='9'||be>='a'&&af<='z')){
            for(p3==1?j=be+1:j=af-1; p3==1?j<af:j>be;p3==1?j++:j--){
                p=j;
                if(p1==2)p=(p>='a')?p-32:p;
                else if(p1==3) p='*';
                for(k=0;k<p2; k++)
                    cout<<p;
            }
        }
        else cout<<f;
        i++;
    }
    return 0;
}

*/

/*
P1100 高低位交换

题目描述

给出一个小于2322^{32}232的正整数。这个数可以用一个323232位的二进制数表示（不足323232位用000补足）。我们称这个二进制数的前161616位为“高位”，后161616位为“低位”。将它的高低位交换，我们可以得到一个新的数。试问这个新的数是多少（用十进制表示）。

例如，数131452013145201314520用二进制表示为000000000001010000001110110110000000 0000 0001 0100 0000 1
 10 1101 100000000000000101000
00111011011000（添加了111111个前导000补足为323232位），其中前161616位为高位，即00000000000101000000 0000 0001 01000000000000010100；后161616位为低位，
00001110110110000000  110
1101
10000000111011011000。将它的高低位进行交换，我们得到了一个新的二进制数0000111011011000000000000001010
0000
1110 1101 1000 0000 0000 0001
010000001110110110000000000000010100。它即是十进制的249036820249036820249036820。


输入格式

一个小于2322^{32}232的正整数
输出格式

将新的数输出
输入输出样例
输入 #1

1314520

输出 #1

249036820

code:
int main() {
    long long n;
    cin>>n;
    cout<<(((n&0xffff0000)>>16)|((n&0x0000ffff)<<16));
    return 0;
}

*/

/*
P1101 单词方阵

题目描述

给一n×nn \times nn×n
字母方阵，内可能蕴含多个“yizhong”单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 888 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用*代替，以突出显示单词。例如：



输入：
    8                     输出：
    qyizhong              *yizhong
    gydthkjy              gy******
    nwidghji              n*i*****
    orbzsfgz              o**z****
    hhgrhwth              h***h***
    zzzzzozo              z****o**
    iwdfrgng              i*****n*
    yyyygggg              y******g

输入格式

第一行输入一个数nnn。(7≤n≤1007 \le n \le 1007≤n≤100)。

第二行开始输入n×nn \times nn×n的字母矩阵。
输出格式

突出显示单词的n×nn \times nn×n矩阵。
输入输出样例
输入 #1

7
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa

输出 #1

*******
*******
*******
*******
*******
*******
*******

输入 #2

8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg

输出 #2

*yizhong
gy******
n*i*****
o**z****
h***h***
z****o**
i*****n*
y******g

code:
int c[10000][2],d=0,n,i,j,o,x[9]={0,1,0,1,-1,0,-1,1,-1},y[9]={0,0,1,1,0,-1,-1,-1,1};
char a[103][103],b,k[9]=" yizhong";
bool s[102][102];
bool f(int i,int j,int m,int n,int next){
    if(next>=8 || (a[i+m][j+n]==k[next] && f(i+m,j+n,m,n,next+1))){
        s[i][j]=1;
        return 1;
    }
    return 0;
}
int main(){
    cin>>n;
    for(i=1;i<=n;i++)
        for(j=1;j<=n;j++){
            cin>>b;
            if(b=='y')c[++d][0]=i,c[d][1]=j;
            a[i][j]=b;
        }
    while(d){
        i=c[d][0];
        j=c[d][1];
        for(o=1;o<=8;o++)
           if(a[i+x[o]][j+y[o]]=='i')
              if(f(i+x[o],j+y[o],x[o],y[o],3))
                 s[i][j]=1;
        d--;
    }
    for(i=1;i<=n;i++){
        for(j=1;j<=n;j++)
            if(s[i][j])cout<<a[i][j];
            else cout<<"*";
        cout<<endl;
    }
    return 0;
}

*/

/*
P1102 A-B 数对

题目描述

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！



好吧，题目是这样的：给出一串数以及一个数字 CCC，要求计算出所有 A?B=CA - B = CA?B=C 的数对的个数（不同位置的数字一样的数对算不同的数对）。
 输入格式

输入共两行。

第一行，两个整数 N,CN, CN,C。

第二行，NNN 个整数，作为要求处理的那串数。
输出格式

一行，表示该串数中包含的满足 A?B=CA - B = CA?B=C 的数对的个数。
输入输出样例
输入 #1

4 1
1 1 2 3

输出 #1

3

说明/提示

对于 75%75\%75% 的数据，1≤N≤20001 \leq N \leq 20001≤N≤2000。

对于 100%100\%100% 的数据，1≤N≤2×1051 \leq N \leq 2 \times 10^51≤N≤2×105。

保证所有输入数据都在 323232 位带符号整数范围内。

2017/4/29 新添数据两组

code:
map<long long,long long> m;
int main() {
    long long n,c,ans=0;
    cin >> n >> c;
    long long a[n+1];
    for(int i=1;i<=n;i++) {
        cin >> a[i];
        m[a[i]]++;
        a[i]-=c;
    }
    for(int i=1;i<=n;i++) ans+=m[a[i]];
    cout << ans << endl;
    return 0;
}

*/

/*
P1104 生日

题目描述

cjf君想调查学校OI组每个同学的生日，并按照从大到小的顺序排序。但cjf君最近作业很多，没有时间，所以请你帮她排序。
输入格式

有222行，

第111行为OI组总人数nnn；

第222行至第n+1n+1n+1行分别是每人的姓名sss、出生年yyy、月mmm、日ddd。
输出格式

有nnn行，

即nnn个生日从大到小同学的姓名。(如果有两个同学生日相同,输入靠后的同学先输出)
输入输出样例
输入 #1

3
Yangchu 1992 4 23
Qiujingya 1993 10 13
Luowen 1991 8 1

输出 #1

Luowen
Yangchu
Qiujingya

说明/提示

数据规模

1<n<1001<n<1001<n<100

length(s)<20length(s)<20length(s)<20

code:
int main() {
    int n,a,b,c;cin>>n;
    string d[n];
    long long e[n],f[n];
    bool g[n]={0};
    for(int i=0;i<n;i++){
        cin>>d[i]>>a>>b>>c;
        e[i]=f[i]=a*10000+b*100+c;
    }
    sort(e,e+n);
    for(int i=0;i<n;i++)
        for(int j=n-1;0<=j;j--)
            if(e[i]==f[j] && !g[j]){
            cout<<d[j]<<endl;
            g[j]=1;
        }
    return 0;
}

*/

/*
P1105 平台

题目描述

空间中有一些平台。给出每个平台的位置，请你计算从每一个平台的边缘落下之后会落到哪一个平台上。注意，如果某两个平台的某个两边缘横坐标相同，物体从上面那个平台落下之后将不会落在下面那个平台上。平台不会重叠，不会有两个平台的边缘碰在一起。

如果有两个平台的高度相同且都可以被落到的话，那么会落到编号靠前的那个平台。
输入格式

第一行有一个数 NNN 表示平台的个数;

接下来 NNN 行每行三个整数 分别是平台的高度 HiH_iHi?，左端点的 XXX 坐标 LiL_iLi?，右端点的 XXX 坐标 RiR_iRi?。



其中，1≤N≤1031 \le N \le {10}^31≤N≤103，0≤H,L,R≤2×1040 \le H,L,R \le 2 \times {10}^40≤H,L,R≤2×104。
 输出格式

输出共 NNN 行，每行两个数，分别表示：

从第 iii 个平台的左边缘落下后到达的平台序号和右边缘落下以后到达的平台序号。

输入数据中第一个平台的序号是 111。如果某个平台的某个边缘下面没有平台了，输出 000。
 输入输出样例 输入 #1

5
2 0 2
4 1 3
3 1 3
5 3 4
1 1 5

输出 #1

0 5
1 5
1 5
5 5
0 0

code:
int ans[20202],n;
struct o{
    int no,h,l,r,ansl,ansr;
}a[1001];
    //no代表编号，h代表高度，l，ansl分别代表左边缘坐标、下落到的平台编号，r,ansr同理代表右边的。
bool cmp1(o x,o y){
    if (x.h==y.h){
        return x.no>y.no;
        }
    return x.h<y.h;
}
bool cmp2(o x,o y){
    return x.no<y.no;
}
int main(){
    cin>>n;
    for (int i=0;i<n;i++){
        a[i].no=i+1;
        cin>>a[i].h>>a[i].l>>a[i].r;
    }
    sort(a,a+n,cmp1);//按高度排序。
    for (int i=0;i<n;i++){
        a[i].ansr=ans[a[i].r];
        a[i].ansl=ans[a[i].l];
        for (int j=a[i].l+1;j<=a[i].r-1;j++)
            ans[j]=a[i].no;
    }
    sort(a,a+n,cmp2);//按序号排序
    for (int i=0;i<n;i++)
        cout<<a[i].ansl<<" "<<a[i].ansr<<endl;
    return 0;
}

*/

/*
P1109 学生分组

题目描述

有N组学生，给出初始时每组中的学生个数，再给出每组学生人数的上界RRR和下界L(L≤R)L(L \le R)L(L≤R)，每次你可以在某组中选出一个学生把他安排到另外一组中，问最少要多少次才可以使NNN组学生的人数都在[L,R][L,


][L
R]中。
输入格式

第一行一个整数NNN，表示学生组数； n≤50n \le 50n≤50

第二行NNN个整数，表示每组的学生个数；

第三行两个整数L,R L,RL,R，表示下界和上界。
输出格式

一个数，表示最少的交换次数，如果不能满足题目条件输出?1-1?1
输入输出样例
输入 #1

2
10 20
10 15

输出 #1

5

code:
int main(){
    int n,a,b;cin>>n;
    long long sum=0,c[n]={0};
    for(int i=0;i<n;i++){
    cin>>c[i];
    sum+=c[i];
    }
    cin>>a>>b;
    if(sum>n*b || sum<n*a)cout<<"-1";
    else {
        sort(c,c+n);
        long long p=0;
        for(int i=0;i<n;i++)
            if(c[i]<a)p+=(a-c[i]);
        long long q=0;
        for(int i=0;i<n;i++)
            if(c[i]>b)q+=(c[i]-b);
        cout<<max(p,q);
    }
    return 0;
}

*/

/*
P1115 最大子段和

题目描述

给出一个长度为 nnn 的序列 aaa，选出其中连续且非空的一段使得这段和最大。
输入格式

第一行是一个整数，表示序列的长度 nnn。

第二行有 nnn 个整数，第 iii 个整数表示序列的第 iii 个数字 aia_iai?。
 输出格式

输出一行一个整数表示答案。
输入输出样例
输入 #1

7
2 -4 3 -1 2 -4 3

输出 #1

4

说明/提示
样例 1 解释

选取 [3,5][3, 5][3,5] 子段 {3,?1,2}\{3, -1, 2\}{3,?1,2}，其和为 444。
数据规模与约定

    对于 40%40\%40% 的数据，保证 n≤2×103n \leq 2 \times 10^3n≤2×103。
    对于 100%100\%100% 的数据，保证 1≤n≤2×1051 \leq n \leq 2 \times 10^51≤n≤2×105，?104≤a
 ≤104-10^4 \leq a_i \leq 10^4?104≤ai?≤104。

code:
int main(){
    int n,j,sum,maxx;
    cin>>n>>maxx;
    sum=maxx;
    while(--n){
        cin>>j;
        if(sum<=0)sum=0;
        sum+=j;
        maxx=max(maxx,sum);
    }
    cout<<maxx;
    return 0;
}

*/

/*
P1125 [NOIP2008 提高组] 笨小猴

题目描述

笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！

这种方法的具体描述如下：假设maxn是单词中出现次数最多的字母的出现次数，minn是单词中出现次数最少的字母的出现次数，如果maxn-minn是一个质数，那么笨小猴就认为这是个Lucky Word，这样的单词很可能就是正确的答案。
 输入格式

一个单词，其中只可能出现小写字母，并且长度小于100100100。
输出格式

共两行，第一行是一个字符串，假设输入的的单词是Lucky Word，那么输出“Lucky Word”，否则输出“No Answer”；



第二行是一个整数，如果输入单词是Lucky Word，输出maxn-minn的值，否则输出000。
输入输出样例
输入 #1

error

输出 #1

Lucky Word
2

输入 #2

olympic

输出 #2

No Answer
0

说明/提示

【输入输出样例1解释】

单词error中出现最多的字母rrr出现了333次，出现次数最少的字母出现了111次，3?1=23-1=23?1=2，222是质数。

【输入输出样例2解释】

单词olympic中出现最多的字母iii出现了111次，出现次数最少的字母出现了111次，1?1=01-1=01?1=0，000不是质数。

（本处原题面错误已经修正）

noip2008提高第一题

code:
int main(){
    int n=0,a[27]={0};
    string c;cin>>c;
    for(int i=0;i<c.length();i++)a[c[i]-'a']++;
    int minn=100,maxn=0;
    for(int i=0;i<27;i++){
        if(a[i]){
        maxn=max(maxn,a[i]);
        minn=min(minn,a[i]);
        }
    }
    int
prime[25]={2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97};
    for(int i=0;i<25;i++){
        if(prime[i]==(maxn-minn)){
        cout<<"Lucky Word"<<endl<<maxn-minn;
        return 0;
        }
    }
    cout<<"No Answer"<<endl<<"0";
    return 0;
}

*/

/*
P1130 红牌

题目描述

某地临时居民想获得长期居住权就必须申请拿到红牌。获得红牌的过程是相当复杂 ，一共包括NNN个步骤。每一步骤都由政府的某个工作人员负责检查你所提交的材料是否符合条件。为了加快进程，每一步政府都派了MMM个工作人员来检查


料。不幸的是，并不是每一个工作人员效率都很高。尽管如此，为了体现“公开政府”的政策，政府部门把每一个工作人员的处理一个申请所花天数都对外界公开。

为了防止所有申请人都到效率高的工作人员去申请。这M×NM \times NM×N个工作人员被分成MMM个小组。每一组在每一步都有一个工作人员。申请人可以选择任意一个小组


可以更换小组。但是更换小组是很严格的，一定要相邻两个步骤之间来更换，而不能在某一步骤已经开始但还没结束的时候提出更换，并且也只能从原来的小组I更换到小组I+1I+1I+1,当然从小组MMM可以更换到小组111。对更换小组的次数没有限制。

例如：下面是333个小组，每个小组444个步骤工作天数：

小组111 : 2,6,1,82, 6 ,1 ,82,6,1,8

小组222 : 3,6,2,63,6, 2, 63,6,2,6

小组333 : 4,2,3,6 4, 2 ,3 ,64,2,3,6

例子中，可以选择小组111来完成整个过程一共花了2+6+1+8=172+6+1+8=172+6+1+8=17天，也可以从小组222开始第一步，然后第二步更换到小组3，第三步到小组111，第四步再到小组222，这样一共花了3+2+1+6=123+2+1+6=123+2+1+6=12天。你可以发现没有比这样效率更高的选择。

你的任务是求出完成申请所花最少天数。
输入格式

第一行是两个正整数NNN和MMM,表示步数和小组数。接下来有MMM行，每行NNN个非负整数，第i+1(1≤i≤M)i+1(1 \le i \le M)i+1(1≤i≤M)行的第j个数表示小组iii完成第j步所花的天数，天数都不超过1000000100000010000




0。

输出格式

一个正整数，为完成所有步所需最少天数。
输入输出样例
输入 #1

4 3
2 6 1 8
3 6 2 6
4 2 3 6

输出 #1

12

说明/提示

【数据规模与约定】

对于100%100\%100%的数据，有N≤2000,M≤2000N ≤ 2000, M ≤ 2000N≤2000,M≤2000。

code:#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m,ans=2147483647;
    cin>>n>>m;
    int a[m][n];
    for (int i=0;i<m;i++)
        for (int j=0;j<n;j++)
            cin>>a[i][j];
    for (int j=n-2;j>=0;j--)
        for (int i=0;i<m;i++)
            a[i][j]=min(a[(i+1)%m][j+1],a[i][j+1])+a[i][j];
    for (int i=0;i<m;i++)
        ans=min(ans,a[i][0]);
    cout<<ans;
    return 0;
}

*/

/*
P1138 第k小整数

题目描述

现有nnn个正整数，n≤10000n≤10000n≤10000，要求出这nnn个正整数中的第kkk个最小整数（相同大小的整数只计算一次），k≤1000k≤1000k≤1000，正整数均小于300003000030000。
输入格式

第一行为nnn和kkk; 第二行开始为nnn个正整数的值，整数间用空格隔开。
输出格式

第kkk个最小整数的值；若无解，则输出“NO RESULT”。
输入输出样例
输入 #1

10 3
1 3 3 7 2 5 1 2 4 6

输出 #1

3

说明/提示

n≤10000n≤10000n≤10000

code:
int main(){
    int n,k,sum=1;cin>>n>>k;
    int a[n];
    for(int i=0;i<n;i++)cin>>a[i];
    sort(a,a+n);
    for(int i=1;i<n;i++){
        if(sum==k){
        cout<<a[i-1];
        return 0;
        }
        if(a[i-1]!=a[i])sum++;
    }
    cout<<"NO RESULT";
    return 0;
}

*/

/*
P1141 01迷宫

题目描述

有一个仅由数字000与111组成的n×nn \times nn×n格迷宫。若你位于一格000上，那么你
以移动到相邻444格中的某一格111上，同样若你位于一格111上，那么你可以移动到相邻444格中的某一格000上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。
输入格式

第111行为两个正整数n,mn,mn,m。

下面nnn行，每行nnn个字符，字符只可能是000或者111，字符之间没有空格。

接下来mmm行，每行222个用空格分隔的正整数i,ji,ji,j，对应了迷宫中第iii行第jjj列的一个格子，询问从这一格开始能移动到多少格。
输出格式

mmm行，对于每个询问输出相应答案。
输入输出样例
输入 #1

2 2
01
10
1 1
2 2

输出 #1

4
4

说明/提示

所有格子互相可达。

对于20%20\%20%的数据，n≤10n≤10n≤10；

对于40%40\%40%的数据，n≤50n≤50n≤50；

对于50%50\%50%的数据，m≤5m≤5m≤5；

对于60%60\%60%的数据，n≤100,m≤100n≤100,m≤100n≤100,m≤100；

对于100%100\%100%的数据，n≤1000,m≤100000n≤1000,m≤100000n≤1000,m≤100000。

code:
//DFS深搜
int n,m,ans[100002],x,y,f[1002][1002];
char s[1002][1002];
void dfs(int r,int c,int z,int lll){
    if (r<0 || r>=n || c<0 || c>=n || f[r][c]!=-1 || s[r][c]-'0'!=z)return;
    f[r][c]=lll;ans[lll]++;
    dfs(r-1,c,!z,lll);dfs(r+1,c,!z,lll);dfs(r,c-1,!z,lll);dfs(r,c+1,!z,lll);
}
int main(){
    cin>>n>>m;
    for (int i=0;i<n;i++)cin>>s[i];
    memset(f,-1,sizeof(f));
    for (int i=0;i<m;i++){
        cin>>x>>y;x--;y--;
        if (f[x][y]==-1)dfs(x,y,s[x][y]-'0',i);
        else ans[i]=ans[f[x][y]];
        cout<<ans[i]<<endl;
    }
    return 0;
}

*/

/*
P1143 进制转换

题目描述

请你编一程序实现两种不同进制之间的数据转换。
输入格式

共三行，第一行是一个正整数，表示需要转换的数的进制n(2≤n≤16)n(2≤n≤16)n(2≤n≤16)，第二行是一个n进制数，若n>10n>10n>10则用大写字母A?FA-FA?F表示数码10?1510-1510?15，并且该nnn进制数对应的十进制的值不超过100000000010000000001000000000，第三行也是一个正整数，表示转换之后的数的进制m(2≤m≤16)m(2≤m≤16)m(2≤m≤16)。
输出格式

一个正整数，表示转换之后的mmm进制数。
输入输出样例
输入 #1

16
FF
2

输出 #1

11111111

code:
//stl解式
int main(){
    int b,m;
    char s[40],t[40];
    cin>>b>>s>>m;
    to_chars(t,t+40,strtol(s,NULL,b),m);
    //如果把上面一行改成itoa(strtol(s,NULL,b),t,m)，应该就能使用Dev-C++，C++11编译通过
    auto& f=use_facet<ctype<char>>(locale());
    f.toupper(t,t+40);
    cout<<t;
    return 0;
}

//常规解式
int main(){
    string a;
    int c[1000],d,e,f,g=0,sum=0,ans=0;
    cin>>d>>a>>f;
    for(int x=0;x<a.size();x++)
        if(a[x]<'A')e=pow(d,a.size()-x-1),e*=(a[x]-'0'),sum+=e;
        else e=pow(d,a.size()-1-x),e*=(a[x]-'A'+10),sum+=e;
    while(sum>0)c[g++]=sum%f,sum/=f;
    for(int x=g-1;x>=0;x--){
        if(c[x]>=10)cout<<char(c[x]+'A'-10);
        else cout<<c[x];
    }
    return 0;
}

*/

/*
P1145 约瑟夫

题目描述

nnn 个人站成一圈，从某个人开始数数，每次数到 mmm 的人就被杀掉，然后下一个人重新开始数，直到最后只剩一个人。现在有一圈人，kkk

个好人站在一起，kkk 个坏人站在一起。从第一个好人开始数数。你要确定一个最小的 mmm，使得在第一个好人被杀死前，kkk 个坏人先被杀死。


 输入格式

一行一个整数 kkk。
输出格式

一行一个整数 mmm。
输入输出样例
输入 #1

3

输出 #1

5

输入 #2

4

输出 #2

30

说明/提示

0<k<140\lt k\lt 140<k<14。

code:
int main(){
    int k,i,m;
    while (cin>>k){
        int m=k;
        while (1){
            m++;
            int cursor=0;
            for (i=0; i<k; i++){
                cursor=(cursor+m-1)%(2*k-i);
                if (cursor<k)break;
                if (i==k-1){
                    cout<<m<<endl;
                    return 0;
                }
            }
        }
    }
    return 0;
}

*/

/*
P1147 连续自然数和

题目描述

对一个给定的自然数MMM，求出所有的连续的自然数段，这些连续的自然数段中的全部数之和为MMM。

例子：1998+1999+2000+2001+2002=100001998+1999+2000+2001+2002 = 10000
998+1999+2000+2001+2002=10000，所以从199819981998到200220022002的一个自然数段为M=10000M=10000M=10000的一个解。
输入格式

包含一个整数的单独一行给出M的值（10≤M≤2,000,00010 \le M \le 2,000,00010≤M≤2,000,000）。
 输出格式

每行两个自然数，给出一个满足条件的连续自然数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。
输入输出样例
输入 #1

10000

输出 #1

18 142
297 328
388 412
1998 2002

code:
int main(){
    int up=1,down=0,n,sum=0;cin>>n;
    for(int i=1;i<n;i++){
        if(sum==n)cout<<up<<" "<<down<<endl;
        sum+=i;down++;
        while(sum>n){
            sum-=up;
            up++;
        }
    }
    return 0;
}

*/

/*
P1149 [NOIP2008 提高组] 火柴棒等式

题目描述

给你n根火柴棍，你可以拼出多少个形如“A+B=CA+B=CA+B=C”的等式？等式中的AAA、BBB、CCC是用火柴棍拼出的整数（若该数非零，则最高位不能是000）。用火柴棍拼数字0?90-90?9的拼法如图所示：

注意：

    加号与等号各自需要两根火柴棍

    如果A≠BA≠BA=B，则A+B=CA+B=CA+B=C与B+A=CB+A=CB+A=C视为不同的等式(A,B,C>=0A,B,C>=0A,B,C>=0)

    nnn根火柴棍必须全部用上

输入格式

一个整数n(n<=24)n(n<=24)n(n<=24)。
输出格式

一个整数，能拼成的不同等式的数目。
输入输出样例
输入 #1

14

输出 #1

2

输入 #2

18

输出 #2

9

说明/提示

【输入输出样例1解释】

222个等式为0+1=10+1=10+1=1和1+0=11+0=11+0=1。

【输入输出样例2解释】

999个等式为：

0+4=4
0+11=11
1+10=11
2+2=4
2+7=9
4+0=4
7+2=9
10+1=11
11+0=11

code:
int main(){
    int a[2001]={6},b,c[10]={6,2,5,5,4,5,6,3,7,6},s=0;
    cin>>b;
    for(int i=1;i<=2000;i++){
        int j=i;
        while(j>=1)a[i]=a[i]+c[j%10],j=j/10;
    }
    for(int i=0;i<=1000;i++)
        for(int j=0;j<=1000;j++)
            if(a[i]+a[j]+a[i+j]+4==b)
                s++;
    cout<<s;
    return 0;
}

*/

/*
P1157 组合的输出

题目描述

排列与组合是常用的数学方法，其中组合就是从nnn个元素中抽出rrr个元素(不分顺序且r≤n)r \le n)r≤n)，我们可以简单地将nnn个元素理解为自然数1,2,…,n1,2,…,n1,2,…,n，从中任取rrr个数。



现要求你输出所有组合。

例如n=5,r=3n=5,r=3n=5,r=3，所有组合为：

123,124,125,134,135,145,234,235,245,34512 3 , 1 2 4 , 1 2 5 , 1 3 4 ,1 3 5 , 1 4
5 , 2 3 4 , 2 3 5 , 2 4 5 , 3 4 5123,124,125,134,135,145,234,235,245,345
输入格式

一行两个自然数n,r(1<n<21,0≤r≤n)n,r(1<n<21,0 \le r \le n)n,r(1<n<21,0≤r≤n)。
输出格式

所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，每个元素占三个字符的位置，所有的组合也按字典顺序。

**注意哦!输出时，每个数字需要333个场宽，pascal可以这样：

write(ans:3);
输入输出样例
输入 #1

5 3

输出 #1

  1  2  3
  1  2  4
  1  2  5
  1  3  4
  1  3  5
  1  4  5
  2  3  4
  2  3  5
  2  4  5
  3  4  5


code:
void dfs(int k, int n,int r,int a[]){
    int i;
    if(k>r){
        for(i=1;i<=r;i++)cout<<setw(3)<<a[i];
        cout<<endl;
        return ;
    }
    for(i=a[k-1]+1;i<=n;i++){
        a[k]=i;
        dfs(k+1,n,r,a);
    }
}
int main(){
    int n,r;
    cin>>n>>r;
    int a[n+1]={0};
    dfs(1,n,r,a);
    return 0;
}

*/

/*
P1162 填涂颜色

题目描述

由数字000组成的方阵中，有一任意形状闭合圈，闭合圈由数字111构成，围圈时只走上下左右444个方向。现要求把闭合圈内的所有空间都填写成222.例如：6×66 \times 66×6的方阵（n=6n=6n=6），涂色前和涂色后的方阵如下：


0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1

0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1

输入格式

每组测试数据第一行一个整数n(1≤n≤30)n(1 \le n \le 30)n(1≤n≤30)

接下来nnn行，由000和111组成的n×nn \times nn×n的方阵。

方阵内只有一个闭合圈，圈内至少有一个000。

//感谢黄小U饮品指出本题数据和数据格式不一样. 已修改(输入格式)
输出格式

已经填好数字222的完整方阵。
输入输出样例
输入 #1

6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1

输出 #1

0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1

说明/提示

1≤n≤301 \le n \le 301≤n≤30

code:
int a[32][32],b[32][32],dx[5]={0,-1,1,0,0},dy[5]={0,0,0,-1,1},n,i,j;
void dfs(int p,int q){
    int i;
    if (p<0||p>n+1||q<0||q>n+1||a[p][q]!=0) return;
    a[p][q]=1;
    for (i=1;i<=4;i++) dfs(p+dx[i],q+dy[i]);
}
int main(){
    cin>>n;
    for (i=1;i<=n;i++)
        for (j=1;j<=n;j++){
            cin>>b[i][j];
            if (b[i][j]==0) a[i][j]=0;
            else a[i][j]=2;
        }
    dfs(0,0);
    for (i=1;i<=n;i++){
        for (j=1;j<=n;j++)
        if (a[i][j]==0) cout<<2<<' ';
        else cout<<b[i][j]<<' ';
        cout<<endl;
    }
}

*/

/*
P1163 银行贷款

题目描述

当一个人从银行贷款后，在一段时间内他(她)将不得不每月偿还固定的分期付款。这个问题要求计算出贷款者向银行支付的利率。假设利率按月累计。
输入格式

三个用空格隔开的正整数。

第一个整数表示贷款的原值，第二个整数表示每月支付的分期付款金额，第三个整数表示分期付款还清贷款所需的总月数。
输出格式

一个实数，表示该贷款的月利率(用百分数表示)，四舍五入精确到0.1%0.1\%0.1%。
输入输出样例
输入 #1

1000 100 12

输出 #1

2.9

code:
void solve(double l,double r,double m,double y,int t){
    double k=(l+r)/2,u=r-l,a=m;
    if(u<0.0001) {printf("%.1f",k*100);return ;}
    for(int i=1;i<=t;i++) a=a*(1+k)-y;
    if(a>0) solve(l,k,m,y,t);
    if(a<0) solve(k,r,m,y,t);
    if(a==0) {printf("%.1f",k*100);return ;}
}
int main(){
double m,y,s;
int t;
    cin>>m>>y>>t;
    solve(0,5,m,y,t);
}

*/

/*
P1164 小A点菜

题目背景

uim神哪玫搅uoi的ra（镭牌）后，立刻拉着基友小A到了一家……餐馆，很低端的那种。

uim指着墙上的价目表（太低级了没有菜单），说：“随便点”。
题目描述

不过uim由于买了一些辅（e）辅（ro）书，口袋里只剩MMM元(M≤10000)(M \le 10000)(M≤10000)。


餐馆虽低端，但是菜品种类不少，有NNN种(N≤100)(N \le 100)(N≤100)，第iii种卖aia_iai?元(ai≤1000
(a_i \le 1000)(ai?≤1000)。由于是很低端的餐馆，所以每种菜只有一份。


小A奉行“不把钱吃光不罢休”，所以他点单一定刚好吧uim身上所有钱花完。他想知道有多少种点菜方法。

由于小A肚子太饿，所以最多只能等待111秒。
输入格式

第一行是两个数字，表示NNN和MMM。

第二行起NNN个正数aia_iai?（可以有相同的数字，每个数字均在100010001000以内）。
输出格式

一个正整数，表示点菜方案数，保证答案的范围在intintint之内。
输入输出样例
输入 #1

4 4
1 1 2 2

输出 #1

3

说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

code:
int main(){
    int n,m;cin>>n>>m;
    int a[n+1],f[n+1][1001]={0};
    for(int i=1;i<=n;i++)cin>>a[i];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            if(j==a[i])f[i][j]=f[i-1][j]+1;
            if(j>a[i]) f[i][j]=f[i-1][j]+f[i-1][j-a[i]];
            if(j<a[i]) f[i][j]=f[i-1][j];
        }
    cout<<f[n][m];
}

*/

/*
P1165 日志分析

题目描述

MMM 海运公司最近要对旗下仓库的货物进出情况进行统计。目前他们所拥有的唯一记录就是一个记录集装箱进出情况的日志。该日志记录了两类操作：第一类操作为集装箱入库操作，以及该次入库的集装箱重量；第二类操作为集装箱的出库操作。这些记录都严格按时间顺序排列。集装箱入库和出库的规则为先进后出，即每次出库操作出库的集装箱为当前在仓库里所有集装箱中最晚入库的集装箱。

出于分析目的，分析人员在日志中随机插入了若干第三类操作DD查询操作。分析日志时，每遇到一次查询操作，都要报告出当前仓库中最大集装箱的重量。
输入格式

包含N+1N+1N+1 行：

第一行为111 个正整数NNN，对应于日志内所含操作的总数。

接下来的NN N行，分别属于以下三种格式之一：

格式111: 0X0 X0X //一次集装箱入库操作，正整数XXX表示该次入库的集装箱的重量

格式222: 111 //一次集装箱出库操作，（就当时而言）最后入库的集装箱出库

格式333: 222 //一次查询操作，要求分析程序输出当前仓库内最大集装箱的重量

当仓库为空时你应该忽略出库操作，当仓库为空查询时你应该输出000。
输出格式

输出行数等于日志中查询操作的次数。每行为一个正整数，表示查询结果。
输入输出样例
输入 #1

13
0 1
0 2
2
0 4
0 2
2
1
2
1
1
2
1
2

输出 #1

2
4
4
1
0

说明/提示

对于20%20\%20%的数据，有N≤10N≤10N≤10；

对于40%40\%40%的数据，有N≤1000N≤1000N≤1000；

对于100%100\%100%的数据，有N≤200000,X≤108N≤200000,X≤10^8N≤200000,X≤108。

code:
int main(){   
    int f[200001],n,x,y,t=0;   
    cin>>n;   
    f[0]=0;   
    for (int i=1; i<=n; i++){   
        cin>>x;   
        if (x==0){   
            cin>>y;   
            t++;   
            f[t]=max(f[t-1],y);   
        }   
        if (x==1) if (t!=0) t--;   
        if (x==2) cout<<f[t]<<endl;   
    }   
    return 0;   
}

*/

/*
P1170 兔八哥与猎人

题目描述

兔八哥躲藏在树林旁边的果园里。果园有 M×NM \times NM×N 棵树，组成一个 MMM 行 NNN 列的矩阵，水平或垂直相邻的两棵树的距离为 111。兔八哥在一棵果树下。

猎人背着猎枪走进了果园，他爬上一棵果树，准备杀死兔八哥。

如果猎人与兔八哥之间没有其它的果树，猎人就可以看到兔八哥。

现己知猎人和兔八哥的位置，编写程序判断兔子所在的位置是否安全.
输入格式

第一行为 nnn，表示有 nnn 组数据，每组数据的第一行为两个正整数 axa_xax? 和 aya_yay?，表示猎人的位置，第二行为两个正整数 bxb_xbx? 和 byb_yby?，表示兔八哥的位置。
输出格式

共有 nnn 行，每行为 yes 或 no 表示兔八哥的位置是否安全。
输入输出样例
输入 #1

1
1 1
1 2

输出 #1

no

说明/提示

1≤n≤1051\le n \le 10^51≤n≤105，1≤ax,ay,bx,by≤1081 \le a_x, a_y, b_x, b_y \le 10^81≤ax?,ay?,bx?,by?≤108。

code:
inline int abs(int a){return a<0?-a:a;}
int gcd(int x,int y){return y?(x%y?gcd(y,x%y):y):-1;}
int main(){
    int t,ax,ay,bx,by;
    cin>>t;
    while(t--){
        cin>>ax>>ay>>bx>>by;
        if(gcd(abs(ax-bx),abs(ay-by))==1)cout<<"no"<<endl;
        else cout<<"yes"<<endl;
    }
    return 0;
}

*/

/*
P1176 路径计数2

题目描述

一个N×NN \times NN×N
网格，你一开始在(1,1)(1,1)(1,1)，即左上角。每次只能移动到下方相邻的格子或者右方相邻的格子，问到达(N,N)(N,N)(N,N)，即右下角有多少种方法。

但是这个问题太简单了，所以现在有MMM个格子上有障碍，即不能走到这MMM个格子上。
输入格式

输入文件第111行包含两个非负整数N,MN,MN,M，表示了网格的边长与障碍数。

接下来MMM行，每行两个不大于NNN的正整数x,yx, yx,y。表示坐标(x,y)(x, y)(x,y)上有障碍不能通过，且有1≤x,y≤n1≤x, y≤n1≤x,y≤n，
x,yx, yx,y至少有一个大于111，并请注意障碍坐标有可能相同。
 输出格式

一个非负整数，为答案?mod?100003 \bmod 100003mod100003后的结果。
输入输出样例
输入 #1

3 1
3 1

输出 #1

5

说明/提示

对于20%20\%20%的数据，有N≤3N≤3N≤3；

对于40%40\%40%的数据，有N≤100N≤100N≤100；

对于40%40\%40%的数据，有M=0M=0M=0；

对于100%100\%100%的数据，有N≤1000,M≤100000N≤1000,M≤100000N≤1000,M≤100000。

code:
int dp[1005][1005],tag[1005][1005];
const int mod=100003;
int main(){
    int n,m,x,y;
    while(cin>>n>>m){
        memset(dp,0,sizeof(dp));
        memset(tag,0,sizeof(tag));
        dp[0][1]=1;
        for(int i=0;i<m;i++){
            cin>>x>>y;
            tag[x][y]=1;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                dp[i][j]=(dp[i-1][j]+dp[i][j-1])%mod;
                if(tag[i][j]==1) dp[i][j]=0;
            }
        }
        cout<<dp[n][n]<<endl;
    }
}

*/

/*
P1177 【模板】快速排序

题目描述

利用快速排序算法将读入的 NNN 个数从小到大排序后输出。

快速排序是信息学竞赛的必备算法之一。对于快速排序不是很了解的同学可以自行上网查询相关资料，掌握后独立完成。（C++C++C++ 选手请不要试图使用 STL，虽然你可以使用 sort 一遍过，但是你并没有掌握快速排序算法的精髓。）



 输入格式

第 111 行为一个正整数 NNN，第 222 行包含 NNN 个空格隔开的正整数 aia_iai?，为你需要进行排序的数，数据保证了 AiA_iAi? 不超过 1091

 ^9109。 输出格式

将给定的 NNN 个数从小到大输出，数之间空格隔开，行末换行且无空格。
输入输出样例
输入 #1

5
4 2 4 5 1

输出 #1

1 2 4 4 5

说明/提示

对于 20%20\%20% 的数据，有 N≤103N\leq 10^3N≤103；

对于 100%100\%100% 的数据，有 N≤105N\leq 10^5N≤105。

code:
int n, a[100001];
void qsort(int l, int r) { //经典快排
    int mid = a[(l + r) / 2], i = l, j = r;
    do {
        while (a[i] < mid)i++;
        while (a[j] > mid)j--;
        if (i <= j) {
            swap(a[i], a[j]);
            i++;
            j--;
        }
    } while (i <= j);
    if (l < j)qsort(l, j);
    if (i < r)qsort(i, r);
}
int main() {
    cin >> n;
    for (int i = 1; i <= n; i++)cin >> a[i];
    qsort(1, n);
    for (int i = 1; i <= n; i++)cout << a[i] << " ";
}

*/

/*
P1178 到天宫做客

题目描述

有一天，我做了个梦，梦见我很荣幸的接到了猪八戒的邀请，到天宫陪他吃酒。我犹豫了。天上一日，人间一年啊！当然，我是个闲人，一年之中也没有多少时日是必须在人间的，因此，我希望选一个最长的空闲时间段，使我在天上待的时间尽量长。记住，今年是400040004000年。天上一天也是242424小时，每小时606060分，每分606060秒。
输入格式

第一行是一个非负整数 N，表示4000年中必须呆在人间的天数。

以下共NNN行，每行两个用空格隔开的正整数，即日期（月,日），输入文件保证无错误，日期无重复。
输出格式

一个非负整数，即在天上的时间(四舍五入精确到111秒)。
输入输出样例
输入 #1

2
3 8
12 2

输出 #1

63266

code:
int num[50000],ans;
double k;
int f[13]={0,0,31,60,91,121,152,182,213,244,274,305,335};
int main(){
    int i,a,b,n;cin>>n;
    for (i=1; i<=n; i++){
        cin>>a>>b;
        num[i]+=f[a];
        num[i]+=b;
    }
    sort(num+1,num+n+1);
    num[n+1]=367;
    for (i=1; i<=n+1; i++)ans=max(num[i]-num[i-1]-1,ans);
    k=(ans*1.0*24*3600/366)+0.5;
    cout<<int(k);
    return 0;
}

*/

/*
P1181 数列分段 Section I

题目描述

对于给定的一个长度为NNN的正整数数列AiA_iAi?，现要将其分成连续的若干段，并且每段和不超过MMM（可以等于MMM），问最少能将其分成多少段使得满足要求。
输入格式

第1行包含两个正整数N,MN,MN,M，表示了数列AiA_iAi?的长度与每段和的最大值，第222行包含NNN个空格隔开的非负整数AiA_iAi?，如题目所述。
输出格式

一个正整数，输出最少划分的段数。
输入输出样例
输入 #1

5 6
4 2 4 5 1

输出 #1

3

说明/提示

对于20%20\%20%的数据，有N≤10N≤10N≤10；

对于40%40\%40%的数据，有N≤1000N≤1000N≤1000；

对于100%100\%100%的数据，有N≤100000,M≤109N≤100000,M≤10^9N≤100000,M≤109，MMM大于所有数的最小值，AiA_iAi?之和不超过10910^9109。

将数列如下划分：

[4][24][51][4][2 4][5 1][4][24][51]

第一段和为444，第222段和为666，第333段和为666均满足和不超过M=6M=6M=6，并可以证明333是最少划分的段数。

code:
int main(){
    int n,m;
    cin>>n>>m;
    int a[100002],ans=n+1;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        if(a[i]+a[i-1]<=m){
            a[i]+=a[i-1];
            ans--;
        }
    }
    cout<<ans;
    return 0;
}

*/

/*
P1184 高手之在一起

题目背景

高手是可以复活的，这点我们大家都知道。
题目描述

高手列出了一个详尽的日程表，这次他要追求的则是一个心灵纯洁的小萝莉。他和她都是要上课的，但是也会有时间空闲，于是高手决定无时无刻都要跟着她。为了她，高手决定转学到一年级。现在高手已经花重金买下了她的日程表，每一天都会有她的行踪。现在列出了高手方便去的地方，以及不方便去的地方。其中方便去的地方可以去无限次，不方便去的地方不能去，一共有 nnn 个方便去的地点， mmm 天。高手想知道他在这 mmm 天中，最多能和她在一起多久。不方便去的地方是不会列出的。



 输入格式

第一行两个整数 n,mn,mn,m。

接下来 nnn 行，每行一个地名，高手方便去的地方。

接下来 mmm 行，每行一个地名，她这一天在的地方。

地名中可能有空格。
输出格式

一个整数，他们在同一个地方的天数。
输入输出样例
输入 #1

1
2
WC
CLASS
WC

输出 #1

1

说明/提示

1≤m≤10000001 \leq m \leq 10000001≤m≤1000000，1≤n≤201 \leq n \leq 201≤n≤20。

code:
int main(){
    string input;
    set<string>qwq;
    int n,m,ans=0;
    scanf("%d%d",&n,&m);
    getline(cin,input);
    for (register int i=1;i<=n;i++)	{
        getline(cin,input);
        if (input[input.size()-1]!=(char)13)//最后一个是否是' '
            input=input+char(13);
        qwq.insert(input);
    }
    for (register int i=1;i<=m;i++){
        getline(cin,input);
        if (input[input.size()-1]!=(char)13)//最后一个是否是' '
            input=input+char(13);
        if (qwq.find(input)!=qwq.end())ans++;
    }
    cout<<ans;
    return 0;
}

*/

/*
P1187 3D模型

题目描述

一座城市建立在规则的 n×mn \times mn×m 网格上，并且网格均由 1×11 \times 11×1 正方形构成。在每个网格上都可以有一个建筑，建筑由若干个 1×1×11 \times 1
 \times
11×1×1 的
方体搭建而成（也就是所有建筑的底部都在同一平面上的）。几个典型的城市模型如下图所示：



现在给出每个网格上建筑的高度，即每个网格上建筑由多少个立方体搭建而成，要求这个建筑模型的表面积是多少。
输入格式

第 111 行包含 222 个正整数 n,mn,mn,m，为城市模型的长与宽。

接下来 nnn 行，每行 mmm 个数字字符，描述了网格每个
子高度（可见所有建筑高度都大于等于 000 且小于等于 999）。
 输出格式

一个非负整数，为城市模型的表面积。
输入输出样例
输入 #1

3 3
111
212
111

输出 #1

38

输入 #2

3 4
1000
0010
0000

输出 #2

12

说明/提示

    20%20\%20%的数据满足：n,m≤10n, m \leq 10n,m≤10；
    40%40\%40%的数据满足：n,m≤100n, m \leq 100n,m≤100；
    100%100\%100%的数据满足：1≤n,m≤10001 \leq n, m \leq 10001≤n,m≤1000。


code:
int main(){
    int ans=0,n,m;
    char input;
    cin>>n>>m;
    int p[n][m];
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            cin>>input;
            p[i][j]=input-'0';
        }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(p[i][j]>0)
                ans+=1;
    for(int j=1;j<=m;j++){
        ans+=p[1][j];
        for(int i=2;i<=n;i++)
            if(p[i][j]>p[i-1][j])
                ans+=(p[i][j]-p[i-1][j]);
    }
    for(int i=1;i<=n;i++){
        ans+=p[i][1];
        for(int j=2;j<=m;j++)
            if(p[i][j]>p[i][j-1])
                ans+=(p[i][j]-p[i][j-1]);
    }
    cout<<(ans)*2;
    return 0;
}

*/

/*
P1190 [NOIP2010 普及组] 接水问题

题目描述

学校里有一个水房，水房里一共装有mmm个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为1 11。




现在有n n n名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 111到n n n编号，ii i号同学的接水量为 wiw_iwi?。接水开始时，11 1到m mm 号同学各占一个水龙头，并同时打开水龙头接水



 当其中某名同学j j j完成其接水量要求wj w_jwj?后，下一名排队等候接水的同学 kkk马上接替 
 jj
同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 jj 同学第 xxx 秒
 束时完成接水，则k kk 同学第 x+1x+1x+1 秒立刻开始接水。若当前接水人数 nnn’不足 mmm，则只有 nnn’个龙头供水，其它 m?nm-n
 ?n’个龙头关闭。




现在给出 nnn 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。
输入格式

第 111 行2 22 个整数 nnn 和 mmm，用一个空格隔开，分别表示接水人数和龙头个数。

第 222 行 nnn 个整数w1,w2,…,wn w_1,w_2,…,w
nw1?,w2?,…,wn?，每两个整数之间用一个空格隔开，wiw_iwi?表示i i i号同学的接水量。
 输出格式

111 个整数，表示接水所需的总时间。
输入输出样例
输入 #1

5 3
4 4 1 2 1

输出 #1

4

输入 #2

8 4
23 71 87 32 70 93 80 76

输出 #2

163

说明/提示

【输入输出样例 1 说明】

第 111 秒，33 3人接水。第 11 1秒结束时，1,2,31,2,3 1,2,3号同学每人的已接水量为 1,31,3 1,3号同学接完水，44 4号同学接替 333 号同学开始接水。




第 222 秒，33 3人接水。第2 22 秒结束时，1,21,2 1,2号同学每人的已接水量为 2,42,4 2,4号同学的已接水量为1 11。




第 333 秒，33 3人接水。第3 33 秒结束时，1,21,21,2 号同学每人的已接水量为 3,43,43,4 号同学的已接水量为 2。444 号同学接完水，555 号同学接替4 4 4


同学开始接水。


第4 44 秒，33 3人接水。第 44 4秒结束时，1,21,21,2 号同学每人的已接水量为 4,54,5 4,5号同学的已接水量为1 11。1,2,51,2,51,2,5 号同学接完水，即所有人完成接


的总接水时间为 444 秒。


【数据范围】

1≤n≤10000,1≤m≤1001≤n≤10000,1≤m≤1001≤n≤10000,1≤m≤100 且m≤n m≤nm≤n；

1≤wi≤1001≤w_i≤1001≤wi?≤100。

code:
int main(){
    int ans,n,m;
    cin>>n>>m;
    int s[n+m]={0};
    for(int i=0;i<n;i++) cin>>s[i];
    int t=m;
    while(t<n+m){
        for(int i=0;i<m;i++){
            s[i]--;
            if(s[i]==0){
                s[i]=s[t];
                t++;
            }
        }
        ans++;
    }
    cout<<ans;
    return 0;
}

*/

/*
P1192 台阶问题

题目描述

有NNN级的台阶，你一开始在底部，每次可以向上迈最多KKK级台阶（最少111级），问到达第NNN级台阶有多少种不同方式。
输入格式

两个正整数N，K。
输出格式

一个正整数，为不同方式数，由于答案可能很大，你需要输出ans?mod?100003ans \bmod 100003ansmod100003后的结果。
 输入输出样例 输入 #1

5 2

输出 #1

8

说明/提示

对于20%20\%20%的数据,有N≤10,K≤3N ≤ 10, K ≤ 3N≤10,K≤3;

对于40%40\%40%的数据，有N≤1000N ≤ 1000N≤1000;

对于100%100\%100%的数据，有N≤100000,K≤100N ≤ 100000,K ≤ 100N≤100000,K≤100。

code:
int main(){
    int n,m;
    cin>>n>>m;
    int a[n+1]={0};
    a[0]=a[1]=1;
    for(int i=2;i<=n;i++){
        if(i<=m) a[i]=a[i-1]*2%100003;
        else a[i]=a[i-1]*2-a[i-m-1],a[i]%=100003;//出负数的主因
    }
    cout<<(a[n]+100003)%100003;//会出负数，所以加模
    return 0;
}

*/

/*
P1201 [USACO1.1]贪婪的送礼者Greedy Gift Givers

题目描述

对于一群 nnn 个要互送礼物的朋友，GY 要确定每个人送出的钱比收到的多多少。在这一个问题中，每

人都准备了一些钱来送礼物，而这些钱将会被平均分给那些将收到他的礼物的人。

然而，在任何一群朋友中，有些人将送出较多的礼物(可能是因为有较多的朋友)，有些人有准备了较多的钱。

给出一群朋友，没有人的名字会长于 141414 字符，给出每个人将花在送礼上的钱，和将收到他的礼物的人的列表，

确定每个人收到的比送出的钱多的数目。
输入格式

第一行一个正整数 nnn，表示人数。 接下来nnn 行，每行一个字符串表示人名。

接下来有 LLL 段内容，对于每一段： 第一行是将会送出礼物人的名字。
第二行包含二个非负整数，第一个是原有的钱的数目 ( ∈[0,2000]\in [0,2000]∈[0,2000] )，第二个 gig_igi? 是将收到这个人礼物的人的个数 如果 gi≠0g_i \neq 0gi

 =0, 在下面 gig_igi? 行列出礼物的接受者
名字，一个名字一行。

 输出格式

输出共 nnn 行，每行输
一个人的名字和该人收到的钱比送出的钱多的数目。名字的顺序应该与输入第 2 2 2 行至 n+1 n+1 n+1 行的顺序相同。



送出的钱永远是整数，即假设送礼人一次向 m m m 人送出 n n n 元，每个人应该得到 ?n/m? \lfloor n/m \rfloor ?n/m? 元。剩余未送出的钱应返还给送礼者。
 输入输出样例
输入 #1

5
dave
laura
owen
vick
amr
dave
200 3
laura
owen
vick
owen
500 1
dave
amr
150 2
vick
owen
laura
0 2
amr
vick
vick
0 0

输出 #1

dave 302
laura 66
owen -359
vick 141
amr -150

说明/提示

【数据范围】
1≤n≤101\le n \le 101≤n≤10

题目翻译来自NOCOW。

USACO Training Section 1.1

code:
struct person{
    string name;
    int money;
}a[12];
string name_out,name_in;
int n,mout,num,sum;
int main(){
    cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i].name;
    for(int i=1;i<=n;i++){
        sum=1;
        cin>>name_out>>mout>>num;
        if(!num||!mout) continue;
        for(int j=1;j<=num;j++){
            cin>>name_in;
            for(int k=1;k<=n;k++){
                if(sum&&a[k].name==name_out){
                    sum--;
                    a[k].money-=mout/num*num;
                }
                if(a[k].name==name_in) a[k].money+=mout/num;
            }
        }
    }
    for(int i=1;i<=n;i++) cout<<a[i].name<<" "<<a[i].money<<endl;
}

*/

/*
P1202 [USACO1.1]黑色星期五Friday the Thirteenth

题目描述

131313 号又是一个星期五，那么 131313号在星期五比在其他日子少吗？

为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 nnn 年的一个周期，要求计算 190019001900 年 111 月 111 日至 1900+n?11900+n-11900+n?1 年 121212
月 313131 日中十三号落在周一到周日的次数。


这里有一些你要知道的:

1、190019001900 年 111 月 111 日是星期一。

2、4,6,114,6,114,6,11 和 999 月有 303030 天，其他月份除了 222 月都有 313131 天，闰年 222 月有 292929 天，平年 222 月
 282828 天。

3、年份可以被 444 整除的为闰年 ( 1992=4?4981992=4*4981992=4?498 所以 199219921992 年是闰年，但是 1990199019
0 年不是闰年 )。

4、以上规则不适合于世纪年。可以被 400400400 整除的世纪年为闰年，否则为平年。所以，1700,1800,19
0,21001700,1800,1900,21001700,1800,1900,2100 年是平年，而 200020002000 年是闰年。
 输入格式

一个正整数 nnn。
输出格式

依次输出周六、日、一、二、三、四、五在 131313 日出现的次数。
输入输出样例
输入 #1

20

输出 #1

36 33 34 33 35 35 34

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤n≤4001\le n \le 4001≤n≤400。

题目翻译来自NOCOW。

USACO Training Section 1.1

code:
int main(){
    int d[13]= {31,31,28,31,30,31,30,31,31,30,31,30};
    int n,last=3;cin>>n;n=1900+n;
    int sum[7]={0};
    for(int i=1900;i<n;i++){
        d[2]=28;
        if(((i%4==0) && (i%100!=0)) || (i%400==0))d[2]=29;
        for(int j=0;j<12;j++){
            last=(last+d[j])%7;
            sum[last]++;
        }
    }
    cout<<sum[6]<<" ";
    for(int i=0;i<6;i++)cout<<sum[i]<<" ";
}

*/

/*
P1203 [USACO1.1]坏掉的项链Broken Necklace

题目描述

你有一条由 nnn 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。 这里是 n=29n=29n=29 的两个例子:



第一和第二个珠子在图片中已经被作记号。

图片 A 中的项链可以用下面的字符串表示：

brbrrrbbbrrrrrbrrbbrbbbbrrrrb

假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事(颜色可能与在这之前收集的不同)。 确定应该在哪里打破项链来收集到最大数目的珠子。



例如，在图片 A 中的项链中，在珠子 999 和珠子 101010 或珠子 242424 和珠子 252525 之间打断项链可以收集到 888 个珠子。



白色珠子什么意思?

在一些项链中还包括白色的珠子(如图片B) 所示。

当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。

表现含有白珠项链的字符串将会包括三个符号 r，b，w 。

写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。
输入格式

第一行一个正整数 nnn ，表示珠子数目。 第二行一串长度为 nnn 的字符串, 每个字符是 r ， b 或 w。
 输出格式

输出一行一个整数，表示从给出的项链中可以收集到的珠子的最大数量。
输入输出样例
输入 #1

29
wwwbbrwrbrbrrbrbrwrwwrbwrwrrb

输出 #1

11

说明/提示

【数据范围】
对于 100%100\%100% 的数据，3≤n≤3503\le n \le 3503≤n≤350

题目翻译来自NOCOW。

USACO Training Section 1.1

code:
int main(){
    int n,a=0, b=0, w=0, ans=0;cin>>n;
    char s[n<<1],c;cin>>s;
    memcpy(s+n,s,n);//将字符串拉长一倍
    for(int i = 0; i < n<<1; i++) {
        if(s[i] == 'w') b++,w++;
        else if(s[i] ==  c ) b++,w=0;
        else ans=max(ans,a+b),a=b-w,b=w+1,w=0,c=s[i];
    }//c：当前处理的字符 a：从i向左最长的长度 b：从i向右最长的长度 w：当前w个数
    cout<<min(n,max(ans,a+b));
    return 0;
}

*/

/*
P1204 [USACO1.2]挤牛奶Milking Cows

题目描述

三个农民每天清晨 555 点起床，然后去牛棚给三头牛挤奶。

第一个农民在 300300300 秒 (从 555 点开始计时) 给他的牛挤奶，一直到 100010001000 秒。第二个农民在 700700700 秒开始，在 120012001200 秒结束。第三个农民在 150015001500 秒开始，210021002100 秒结束。

期间最长的至少有一个农民在挤奶的连续时间为 900900900 秒 (从 300300300 秒到 120012001200 秒)，而最长的无人挤奶的连续时间(从挤奶开始一直到挤奶结束)为 300300300 秒 (从 120012001200 秒到 150015001500 秒)。

你的任务是编一个程序，读入一个有 nnn 个农民挤 nnn 头牛的工作时间列表，计算以下两点(均以秒为单位):

最长至少有一人在挤奶的时间段。

最长的无人挤奶的时间段。（从有人挤奶开始算起）
输入格式

第一行一个正整数 nnn

接下来 nnn 行，每行两个非负整数 l,rl,rl,r，表示一个农民的开始时刻与结束时刻。
输出格式

一行，两个整数，即题目所要求的两个答案。
输入输出样例
输入 #1

3
300 1000
700 1200
1500 2100

输出 #1

900 300

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤n≤50001\le n \le 50001≤n≤5000，0≤l≤r≤1060 \le l \le r \le 10^60≤l≤r≤106。

题目翻译来自NOCOW。

USACO Training Section 1.2

code:
int main(){
    int n,minn=1000000,maxn=0,a,b;cin>>n;
    bool num[1000001]={0};
    for(int i=0;i<n;i++){
        cin>>a>>b;
        minn=min(minn,a);
        maxn=max(maxn,b);
        for(int j=a;j<b;j++)
            num[j]=1;
    }
    int peopledo=0,peoplelie=0,domax=0,liemax=0;
    for(int i=minn;i<maxn;i++){
        if(num[i]){
        liemax=max(liemax,peoplelie);
        peopledo++;
        peoplelie=0;
        }
        else {
        domax=max(domax,peopledo);
        peopledo=0;
        peoplelie++;
        }
    }
    if(domax==0 ||n==1)cout<<maxn-minn<<" "<<liemax;
    else cout<<domax<<" "<<liemax;
}

*/

/*
P1205 [USACO1.2]方块转换 Transformations

题目描述

一块 n×nn \times nn×n 正方形的黑白瓦片的图案要被转换成新的正方形图案。写一个程序来找出将原始图案按照以下列转换方法转换成新图案的最小方式：

    转 90°90\degree90°：图案按顺时针转 90°90\degree90°。

    转 180°180\degree180°：图案按顺时针转 180°180\degree180°。

    转 270°270\degree270°：图案按顺时针转 270°270\degree270°。

    反射：图案在水平方向翻转（以中央铅垂线为中心形成原图案的镜像）。

    组合：图案在水平方向翻转，然后再按照 1?31 \sim 31?3 之间的一种再次转换。

    不改变：原图案不改变。

    无效转换：无法用以上方法得到新图案。

如果有多种可用的转换方法，请选择序号最小的那个。

只使用上述 777 个中的一个步骤来完成这次转换。
输入格式

第一行一个正整数 nnn。

然后 nnn 行，每行 nnn 个字符，全部为 @ 或 -，表示初始的正方形。

接下来 nnn 行，每行 nnn 个字符，全部为 @ 或 -，表示最终的正方形。
输出格式

单独的一行包括 1?71 \sim 71?7 之间的一个数字（在上文已描述）表明需要将转换前的正方形变为转换后的正方形的转换方法。
输入输出样例
输入 #1

3
@-@
---
@@-
@-@
@--
--@

输出 #1

1

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤n≤101\le n \le 101≤n≤10。

题目翻译来自NOCOW。

USACO Training Section 1.2

code:
string right90(string first,int n){
    string second=first;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            second[j*n+n-i-1]=first[i*n+j];
    return second;
}
string fanshe(string first,int n){
    string second=first;
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            second[i*n+j]=first[i*n+n-j-1];
    return second;
}
int main(){
    int n;cin>>n;
    string first,second,c;
    for(int i=0;i<n;i++){
        cin>>c;
        first+=c;
    }
    for(int i=0;i<n;i++){
        cin>>c;
        second+=c;
    }
    if(right90(first,n)==second)cout<<"1";
    else if(right90(right90(first,n),n)==second)cout<<"2";
    else if(right90(right90(right90(first,n),n),n)==second)cout<<"3";
    else if((c=fanshe(first,n))==second)cout<<"4";
    else if((right90(right90(right90(c,n),n),n)==second) || (right90(right90(c,n),n)==second) || (right90(c,n)==second))cout<<"5";
    else if(first==second)cout<<"6";
    else cout<<"7";
    return 0;
}

*/

/*
P1206 [USACO1.2]回文平方数 Palindromic Squares

题目描述

回文数是指从左向右念和从右向左念都一样的数。如 123211232112321 就是一个典型的回文数。

给定一个用十进制表示的正整数 BBB，输出所有 [1,300][1,300][1,300] 中，它的平方用 BBB 进制表示时是回文数的数。
输入格式

共一行，一个单独的正整数 BBB。
输出格式

每行两个 BBB 进制的符合要求的数字，第二个数是第一个数的平方，且第二个数是回文数。

注意大于 999 的数，用字母表示。如用 A 表示 101010，B 表示 111111，用第 nnn 个大写字母表示 n+9n+9n+9。
输入输出样例
输入 #1

10

输出 #1

1 1
2 4
3 9
11 121
22 484
26 676
101 10201
111 12321
121 14641
202 40804
212 44944
264 69696

说明/提示

【数据范围】
对于 100%100\%100% 的数据，2≤B≤202 \le B \le 202≤B≤20

题目翻译来自NOCOW。

USACO Training Section 1.2

code:
int s[301];
void zhuanhuan(int a,int b){
    int r=0;
    while(a)s[++r]=a%b,a/=b;
    s[0]=r;
}
bool panduan(){
    for(int i=1;i<=s[0];i++)
        if(s[i]!=s[s[0]+1-i])return false;
    return true;
}
void print (){
    for(int i=s[0];i>=1;i--)
        if(s[i]<=9)cout<<s[i];
        else cout<<(char)(s[i]-10+'A');
}
int main(){
    int n;cin>>n;
    for(int i=1;i<=300;i++){
        zhuanhuan(i*i,n);
        if(panduan()){
            zhuanhuan(i,n);
            print();
            cout<<" ";
            zhuanhuan(i*i,n);
            print();
            cout<<endl;
        }
    }
    return 0;
}

*/

/*
P1207 [USACO1.2]双重回文数 Dual Palindromes

题目背景

如果一个数从左往右读和从右往左读都是一样，那么这个数就叫做“回文数”。例如，123211232112321 就是一个回文数，而 777787777877778 就不是。当然，回文数的首和尾都应是非零的，因此 022002200220 就不是回文数。

事实上，有一些数（如 212121 ），在十进制时不是回文数，但在其它进制（如二进制时为 101011010110101 ）时就是回文数。
题目描述

给定两个十进制数 n,sn,sn,s，然后找出前 nnn 个满足大于 sss 且在不少于两种进制（二进制至十进制）上是回文数的十进制数，输出到文件上。

本问题的解决方案不需要使用大于 323232 位的整型数
输入格式

只有一行，用空格隔开的两个正整数 n,sn,sn,s。
输出格式

nnn 行, 每行一个满足上述要求的数，并按从小到大的顺序输出。
输入输出样例
输入 #1

3 25

输出 #1

26
27
28

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤n≤151\le n \le 151≤n≤15，1≤s≤99991\le s \le 99991≤s≤9999

题目翻译来自NOCOW。

USACO Training Section 1.2

code:
bool huiwen(int a,int b){//a的b进制是否回文判断
    short res[100]={0},p=0;
    while(a)res[p++]=a%b,a/=b;
    int i=0,j=p-1;
    while(i<j)if(res[i++]!=res[j--])return 0;
    return 1;
}
int main(){
    int a,b;
    cin>>a>>b;
    int ans=0;
    for(int i=b+1;ans<a;i++){
        int cnt=0;
        for(int j=2;j<=10 && cnt!=2;j++)
            if(huiwen(i,j))cnt++;
        if(cnt==2){
            cout<<i<<endl;
            ans++;
        }
    }
    return 0;
}

*/

/*
P1208 [USACO1.3]混合牛奶 Mixing Milk

题目描述

由于乳制品产业利润很低，所以降低原材料（牛奶）价格就变得十分重要。帮助 Marry 乳业找到最优的牛奶采购方案。



Marry
乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格是不同的。此外，就像每头奶牛每天只能挤出固定数量的奶，每位奶农每天能提供的牛奶数量是一定的。每天 Marry 乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。



给出 Marry 乳业每
对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。

注：每天所有奶农的总产量大于 Marry 乳业的需求量。
输入格式

第一行二个整数 n,mn,mn,m，表示需要牛奶的总量，和提供牛奶的农民个数。

接下来 mmm 行，每行两个整数 pi,aip_i,a_ipi?,ai?，表示第 iii 个农民牛奶的单价，和农民 iii 一天最多能卖出的牛奶量。
 输出格式

单独的一行包含单独的一个整数，表示 Marry 的牛奶制造公司拿到所需的牛奶所要的最小费用。
 输入输出样例 输入 #1

100 5
5 20
9 40
3 10
8 80
6 30

输出 #1

630

说明/提示

【数据范围】
对于 100%100\%100% 的数据：
0≤n,ai≤2×1060 \le n,a_i \le 2 \times 10^60≤n,ai?≤2×106，0≤m≤50000\le m \le 50000≤m≤5000，0≤pi
 10000 \le p_i \le 10000≤pi?≤1000

题目翻译来自 NOCOW。

USACO Training Section 1.3

code:
struct node{
    int one,sum;
}nd[5001];
bool cmp(node a,node b){
    if(a.one!=b.one)return a.one<b.one;//升序
    else return a.sum>b.sum;//降序
}
int main(){
    int n,m;cin>>n>>m;
    for(int i=0;i<m;i++)
        cin>>nd[i].one>>nd[i].sum;
    sort(nd,nd+m,cmp);
    int i=1,num=0;
    for(int i=0;i<m;i++)
        cout<<nd[i].one<<" "<<nd[i].sum<<endl;
    while(n){
        if(nd[i].sum>0)nd[i].sum--,num+=nd[i].one,n--;
        else i++;
    }
    cout<<num;
    return 0;
}
*/

/*
P1208 [USACO1.3]混合牛奶 Mixing Milk

题目描述

由于乳制品产业利润很低，所以降低原材料（牛奶）价格就变得十分重要。帮助 Marry 乳业找到最优的牛奶采购方案。



Marry
乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格是不同的。此外，就像每头奶牛每天只能挤出固定数量的奶，每位奶农每天能提供的牛奶数量是一定的。每天 Marry 乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。



给出 Marry 乳业每
对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。

注：每天所有奶农的总产量大于 Marry 乳业的需求量。
输入格式

第一行二个整数 n,mn,mn,m，表示需要牛奶的总量，和提供牛奶的农民个数。

接下来 mmm 行，每行两个整数 pi,aip_i,a_ipi?,ai?，表示第 iii 个农民牛奶的单价，和农民 iii 一天最多能卖出的牛奶量。
 输出格式

单独的一行包含单独的一个整数，表示 Marry 的牛奶制造公司拿到所需的牛奶所要的最小费用。
 输入输出样例 输入 #1

100 5
5 20
9 40
3 10
8 80
6 30

输出 #1

630

说明/提示

【数据范围】
对于 100%100\%100% 的数据：
0≤n,ai≤2×1060 \le n,a_i \le 2 \times 10^60≤n,ai?≤2×106，0≤m≤50000\le m \le 50000≤m≤5000，0≤pi
 10000 \le p_i \le 10000≤pi?≤1000

题目翻译来自 NOCOW。

USACO Training Section 1.3

code:
struct node{
    int one,sum;
}nd[50001];
bool cmp(node a,node b){
    if(a.one!=b.one)return a.one<b.one;
    else return a.sum>b.sum;//这句话其实对算法没有优化意义，但是会因双系同数而运行错误，遂加上
}
int main(){
    int n,m;cin>>n>>m;
    for(int i=0;i<m;i++)
        cin>>nd[i].one>>nd[i].sum;
    sort(nd,nd+m,cmp);
    int i=0,num=0;
    while(n){
        if(nd[i].sum!=0){
        nd[i].sum--,num+=nd[i].one,n--;
        if(!n)break;}
        else i++;
    }
    cout<<num;
    return 0;
}

*/

/*
P1211 [USACO1.3]牛式 Prime Cryptarithm 

题目描述

下面是一个乘法竖式，如果用我们给定的那 nnn 个数字来取代 *，可以使式子成立的话，我们就叫这个式子为牛式。



          ***
    x      **
   ----------
         ***
        ***
   ----------
        ****

数字只能取代 *，当然第一位不能为 000，况且给定的数字里不包括 000。

注意一下在美国的学校中教的“部分乘积”，第一部分乘积是第二个数的个位和第一个数的积，第二部分乘积是第二个数的十位和第一个数的乘积。

请计算出牛式的数量。
输入格式

第一行一个正整数 nnn，表示可用的数集。
第二行 nnn 个正整数 aia_iai?，表示可用的数。
输出格式

输出一行一个整数，表示牛式的总数。
输入输出样例
输入 #1

5
2 3 4 6 8

输出 #1

1

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤n≤91\le n \le 91≤n≤9，ai∈[1,9]∩Za_i \in [1,9] \cap \mathbb Zai?∈[1,9]∩Z 且 ai
 _iai? 不重复。

题目翻译来自NOCOW。

USACO Training Section 1.4

code:
bool p[15];
bool f(int n){
    while(n){
        if(p[n%10]==0)
            return 0;
        n/=10;
    }
    return 1;
}
bool check(int x,int y){
    int a=x*(y%10),b=x*(y/10),test=x*y;
    if(a>999 || b>999 || test>9999)
        return 0;
    if(f(x)==1 && f(y)==1 && f(a)==1 && f(b)==1 && f(test)==1) return 1;
    else return 0;
}
int main(){
    int n,key,ans=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>key;
        p[key]=true;
    }
    for(int i=100;i<1000;i++)
        for(int j=10;j<100;j++)
            if(check(i,j)==1)
                ans++;
    cout<<ans;
    return 0;
}

*/

/*
P1216 [USACO1.5][IOI1994]数字三角形 Number Triangles

题目描述

观察下面的数字金字塔。

写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5

在上面的样例中,从 7→3→8→7→57 \to 3 \to 8 \to 7 \to 57→3→8→7→5 的路径产生了最大
输入格式

第一个行一个正整数 rrr ,表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。
输出格式

单独的一行,包含那个可能得到的最大的和。
输入输出样例
输入 #1

5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5

输出 #1

30

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤r≤10001\le r \le 10001≤r≤1000，所有输入在 [0,100][0,100][0,100] 范围内。


题目翻译来自NOCOW。

USACO Training Section 1.5

IOI1994 Day1T1

code:
int main(){//经典dp
    int n;cin>>n;
    int a[n+1][n+1]={0},f[n+1][n+1]={0};
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            cin>>a[i][j];
            f[i][j]=a[i][j];
        }
    }
    for(int i=n-1;i>=1;i--)
        for(int j=1;j<=i;j++)
            f[i][j]=max(f[i+1][j],f[i+1][j+1])+a[i][j];
    cout<<f[1][1];
    return 0;
}

*/

/*
P1217 [USACO1.5]回文质数 Prime Palindromes

题目描述

因为 151 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 151 是回文质数。



写一个程序来找出范围 [a,b](5≤a<b≤100,000,000)[a,b] (5 \le a < b \le 100,000,000)[a,b](5≤a<b
 100,000,000)( 一亿)间的所有回文质数。 输入格式

第 1 行: 二个整数 a 和 b .
输出格式

输出一个回文质数的列表，一行一个。
输入输出样例
输入 #1

5 500

输出 #1

5
7
11
101
131
151
181
191
313
353
373
383

说明/提示

Hint 1: Generate the palindromes and see if they are prime.

提示 1: 找出所有的回文数再判断它们是不是质数（素数）.

Hint 2: Generate palindromes by combining digits properly. You might need more
than one of the loops like below.

提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。

题目翻译来自NOCOW。

USACO Training Section 1.5

产生长度为5的回文数:

for (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数
    for (d2 = 0; d2 <= 9; d2++) {
        for (d3 = 0; d3 <= 9; d3++) {
            palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 +
d1;//(处理回文数...)
        }
    }
}


code://注：一亿以内回文质数，需要简化，因此如下
bool tiaoguo(int x){//跳过，增速
    if((1000 <= x && x <= 9999) || (100000 <= x && x <= 999999))
        return 0;
    return 1;
}
bool huiwen(int x){//先测回文快
    int a[20], flag = 1;
    while (x > 0){
        a[flag] = x % 10;
        x /= 10;
        flag++;
    }
    for (int i = 1; i <= flag / 2; i++)
            if(a[i] != a[flag-i])
        return 0;
    return 1;
}
bool zhishu(int x){//测质数
    if(x == 2) return 1;
    for(int i = 2; i <= sqrt(x); i++)
        if(x % i == 0)
            return 0;
    return 1;
}
int main(){
    int l,r;cin>>l>>r;
    if(l==2)cout<<2<<endl;
    if(l%2==0)l++;//变成奇数
    r=min(9989899,r);
    for(int i=l;i<=r;i+=2){
        if(tiaoguo(i)==0)continue;//跳过区间
        if(huiwen(i)==0)continue;//跳过非回文
        if(zhishu(i)==0)continue;//跳过质数
        cout<<i<<endl;
    }
    return 0;
}

*/

/*
P1218 [USACO1.5]特殊的质数肋骨 Superprime Rib

题目描述

农民约翰的母牛总是产生最好的肋骨。你能通过农民约翰和美国农业部标记在每根肋骨上的数字认出它们。

农民约翰确定他卖给买方的是真正的质数肋骨，是因为从右边开始切下肋骨，每次还剩下的肋骨上的数字都组成一个质数。

举例来说：7 3 3 17\ 3\ 3\ 17 3 3 1 全部肋骨上的数字 733173317331 是质数；三根肋骨 733733733 是质数；二根
 骨 737373 是质数；当然,最后一根肋骨 777 也是质数。733173317331 被叫做长度 4
4 的特殊质数。


写一个程序对给定的肋骨的数目 nnn，求出所有的特殊质数。111 不是质数。
输入格式

一行一个正整数 nnn。
输出格式

按顺序输出长度为 nnn 的特殊质数,每行一个。
输入输出样例
输入 #1

4

输出 #1

2333
2339
2393
2399
2939
3119
3137
3733
3739
3793
3797
5939
7193
7331
7333
7393

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤n≤81\le n \le 81≤n≤8。

题目翻译来自NOCOW。

USACO Training Section 1.5

code:
int n,a[5]={1,3,5,7,9},b[4]={2,3,5,7};
bool prime(int x){
    if(x==1)return 0;
    if(x==2)return 1;
    for(int i=2;i<=sqrt(x);i++)
        if(x%i==0)
            return 0;
    return 1;
}
void DFS(int k,int sum,int n,int a[]){
    int p;
    if(sum==n){
        cout<<k<<endl;
        return ;
    }
    else {
        for(int i=0;i<5;i++){
            p=k*10+a[i];
            if(prime(p))
                DFS(p,sum+1,n,a);
        }
    }
}
int main(){
    cin>>n;
    for(int i=0;i<4;i++){
        DFS(b[i],1,n,a);
    }
    return 0;
}

*/

/*
P1223 排队接水

题目描述

有 nnn 个人在一个水龙头前排队接水，假如每个人接水的时间为 TiT_iTi?，请编程找出这 nnn 个人排队的一种顺序，使得 nnn 个人的平均等待时间最小。



 输入格式

第一行为一个整数 nnn。

第二行 nnn 个整数，第 iii 个整数 TiT_iTi? 表示第 iii 个人的等待时间 TiT_iTi?。
 输出格式

输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。
输入输出样例
输入 #1

10
56 12 1 99 1000 234 33 55 99 812

输出 #1

3 2 7 8 1 4 9 6 10 5
291.90

说明/提示

n≤1000,ti≤106n \leq 1000,t_i \leq 10^6n≤1000,ti?≤106，不保证 tit_iti? 不重复。



当 tit_iti? 重复时，按照输入顺序即可（sort 是可以的）

code:
int main(){
    int n;cin>>n;
    long long t,num[n];
    double sum=0;
    for(int i=0;i<n;i++){
        cin>>t;
        t=t*1000+i;
        num[i]=t;
    }
    sort(num,num+n);
    for(int i=0;i<n;i++){
    cout<<num[i]%1000+1<<" ";
    sum+=num[i]/1000*(n-i-1);
    }
    sum=sum/n;
    printf("\n%0.2lf",sum);
    return 0;
}

*/

/*
P1226 【模板】快速幂||取余运算

题目描述

给你三个整数 b,p,kb,p,kb,p,k，求 bp?mod?kb^p \bmod kbpmodk。
输入格式

输入只有一行三个整数，分别代表 b,p,kb,p,kb,p,k
输出格式

输出一行一个字符串 b^p mod k=s，其中 b,p,kb, p, kb,p,k 分别为题目给定的值， sss 为运算结果。
 输入输出样例 输入 #1

2 10 9

输出 #1

2^10 mod 9=7

说明/提示
样例输入输出 1 解释

210=10242^{10} = 1024210=1024，1024?mod?9=71024 \bmod 9 = 71024mod9=7。
数据规模与约定

    对于 100%100\%100% 的数据，保证 0≤b,p<2310\le b,p < 2^{31}0≤b,p<231，1
k<2311 \leq k \lt 2^{31}1≤k<231。

code:
int main(){//快速幂
    long long b,p,k,s=1;cin>>b>>p>>k;
    cout<<b<<"^"<<p<<" mod "<<k<<"=";
    while(p>0){
        if(p%2==1)//奇数多一次
            s=s*b%k;
        b=b*b%k;
        p=p>>1;
    }
    cout<<s%k;
    return 0;
}

*/

/*
P1244 [NOI2000] 青蛙过河

题目描述

有一条河，左边一个石墩（A 区）上有编号为 1,2,…,n1,2,\ldots ,n1,2,…,n 的 nnn 只青蛙，河中有 kkk 个荷叶（C 区），还有 hhh 个石墩（D 区），右边有一个石
 （B 区
，如下图所示。nnn 只青蛙要过河（从左岸石墩 A 到右岸石墩 B），规则为：


    石墩上可以承受任意多只青蛙，荷叶只能承受一只青蛙（不论大小）；
    青蛙可以：A→BA \to BA→B（表示可以从 A 跳到 B，下同），A→CA \to CA→C，A→DA \to DA→D，C→BC \to BC→B，D→BD \to BD→B，D→CD \to C
 →C，C→DC \to DC→D；
    当一个石墩上有多只青蛙时，则上面的青蛙只能跳到比它大一号的青蛙上面。

你的任务是对于给出的 h,kh,kh,k，计算并输出最多能有
少只青蛙可以根据以上规则顺利过河。 输入格式

输入两个整数 h,kh,kh,k。
输出格式

一个整数，表示最多能有多少只青蛙可以根据以上规则顺利过河。
输入输出样例
输入 #1

2 3

输出 #1

16

说明/提示

h≤20h \leq 20h≤20，k≤103k \leq 10^3k≤103。

code:
int main(){
    int h,k;
    cin>>h>>k;
    cout<<(k+1)*pow(2,h);
    return 0;
}

*/

/*
P1252 马拉松接力赛

题目描述

某城市冬季举办环城25km马拉松接力赛，每个代表队有5人参加比赛，比赛要求每个的每名参赛选手只能跑一次，一次至少跑1km、最多只能跑10km，而且每个选手所跑的公里数必须为整数，即接力的地方在整公里处。

刘老师作为学校代表队的教练，精心选择了5名长跑能手，进行了训练和测试，得到了这5名选手尽力连续跑1km、2km、…、10km的所用时间。现在他要进行一个合理的安排，让每个选手跑合适的公里数，使学校代表队跑完25km所用的时间最短。根据队员的情况，这个最短的时间是惟一的，但安排方案可能并不惟一。

根据测试情况及一般运动员的情况得知，连续跑1km要比连续跑2km速度快，连续跑2km又要比连续跑3km速度快……也就是说连续跑的路程越长，速度越慢，当然也有特殊的，就是速度不会变慢，但是绝不可能变快。
输入格式

5行数据，分别是1到5号队员的测试数据，每行的10个整数，表示某一个运动员尽力连续跑1km、2km、…、10km所用的时间。
输出格式

两行，第一行是最短的时间，第二行是五个数据，分别是1到5号队员各自连续跑的公里数。
输入输出样例
输入 #1

333 700 1200 1710 2240 2770 3345 3956 4778 5899
300 610 960 1370 1800 2712 3734 4834 5998 7682
298 612 990 1540 2109 2896 3790 4747 5996 7654
289 577 890 1381 1976 2734 3876 5378 6890 9876
312 633 995 1407 1845 2634 3636 4812 5999 8123

输出 #1

9905
6 5 5 4 5

说明/提示

@Jomoo 提供了修正后的数据

code:
int minx=2147483647,flag,ans;
int a[5][11],b[5][11],c[5];
int main(){
    c[0]=c[1]=c[2]=c[3]=c[4]=1;
    for(int i=0;i<5;i++){
        for(int j=1;j<11;j++){
            cin>>a[i][j];
            b[i][j]=a[i][j]-a[i][j-1];
        }
    }
    for(int i=0;i<20;i++){
        minx=2147483647;
        for(int j=0;j<5;j++){
            if(b[j][c[j]+1]<minx&&c[j]+1<=10)
                flag=j,minx=b[j][c[j]+1];
        }
        c[flag]++;
    }
    for(int i=0;i<5;i++)
        ans+=a[i][c[i]];
    printf("%d\n%d %d %d %d %d\n",ans,c[0],c[1],c[2],c[3],c[4]);
    return 0;
}

*/

/*
P1253 【错题待添加】

题目描述

磁带等存储介质存储信息时基本上都是一种线性存储的方式，线性存储方式虽然简单，但查询检索时往往要经过一些其它信息，不象磁盘等存储介质在目录区找到后可直接定位到某一区城，因此线性存储总有它的局限性。但是由于磁带等线性存储有简单、保存时间相对较长等优点，现在仍然在使用。

如果有n段信息资料要线性存储在某种存储介质上，它们的长度分别是L1，L2，…，Ln，存储介质能够保存下所有这些信息，假设它们的使用(查询检索)的频率分别是F1，F2，…，Fn，要如何存储这些信息资料才能使平均检索时间最短。

你的任务就是编程安排一种平均检索时间最短的方案。
输入格式

第一行是一个正整数n(n<10000)，接下来是n行数据，每行两个整数分别是第1段信息的长度(1到10000之间)和使用的频率(万分比，在0到9000之间)，总的频率之和为10000。

所输入数据均不要判错。
输出格式

依次存储信息段的编号。每个数据之间用一个空格隔开。
输入输出样例
输入 #1

5
10 4000
20 1000
30 1000
35 1500
12 2500

输出 #1

4 1 3 5 2

code://这题有问题!!!*/

/*
P1255 数楼梯

题目描述

楼梯有 NNN 阶，上楼可以一步上一阶，也可以一步上二阶。

编一个程序，计算共有多少种不同的走法。
输入格式

一个数字，楼梯数。
输出格式

输出走的方式总数。
输入输出样例
输入 #1

4

输出 #1

5

说明/提示

    对于 60%60\%60% 的数据，N≤50N \leq 50N≤50；
    对于 100%100\%100% 的数据，N≤5000N \leq 5000N≤5000。

code:
unsigned short int n,f[5002][5002],len=1;
void gaojing(int k){//高精度 计算加法
    for(int i=1;i<=len;i++)
        f[k][i]=f[k-1][i]+f[k-2][i];
    for(int i=1;i<=len;i++)
        if(f[k][i]>=10){
            f[k][i+1]+=f[k][i]/10;
            f[k][i]%=10;
            if(f[k][len+1])len++;
        }
}
int main(){
    cin>>n;
    f[1][1]=1;f[2][1]=2;
    for(int i=3;i<=n;i++)
        gaojing(i);
    for(int i=len;i>=1;i--)
        cout<<f[n][i];
    return 0;
}

*/

/*
P1256 显示图像

题目描述

古老的显示屏是由N×M个像素（Pixel）点组成的。一个像素点的位置是根据所在行数和列数决定的。例如P(2,1)表示第2行第1列的像素点。那时候，屏幕只能显示黑与白两种颜色，人们用二进制0和1来表示。0表示黑色，1表示白色。当计算机发出一个指令：P(x,y)=1，则屏幕上的第x行第y列的阴极射线管就开始工作，使该像素点显示白色，若P(x,y)=0，则对应位置的阴极射线管不工作，像素点保持黑色。在某一单位时刻，计算机以N×M二维01矩阵的方式发出显示整个屏幕图像的命令。

例如，屏幕是由3×4的 对应屏幕显示应为：

像素点组成，在某单位时刻，

计算机发出如下命令：

0001 0011 0110

假设放大后，一个格子表示一个像素点

由于未知的原因，显示黑色的像素点总是受显示白色的像素点的影响――可能是阴极射线管工作的作用。并且，距离越近，影响越大。这里的距离定义如下：设有像素点P1(x1,y1)和像素点P2(x2,y2)，则它们之间的距离D(P1,P2)：D(P1,P2)=|x1-x2|+|y1-y2| 在某一时刻，计算机发出显示命令后，科学家们期望知道，每个像素点和其最近的显示白色的像素点之间的最短距离是多少――科学家们保证屏幕上至少有一个显示白色的像素点。


上面的例子中，像素P(1,1)与最近的白色像素点之间的距离为3，而像素P(3,2)本身显示白色，所以最短距离为0。
输入格式

第一行有两个数字，N和M (1<=N,M<=182)，表示屏幕的规格。

以下N行，每行M个数字，0或1。为计算机发出的显示命令。
输出格式

输出文件有N行，每行M个数字，中间用1个空格分开。第i行第j列的数字表示距像素点P(i,j)最近的白色像素点的最短距离。
输入输出样例
输入 #1

3 4
0001
0011
0110

输出 #1

3 2 1 0
2 1 0 0
1 0 0 1

说明/提示

对于30%的数据：N*M<=10000；

对于100%的数据：N*M<=182^2。

code:
int n,m,d[1010][1010],dx[5]={0,0,0,-1,1},dy[5]={0,-1,1,0,0},tail,head;
struct MAP{
    int x,y;
}a[1000010];
bool f[1010][1010];
int main(){ //广度搜索,用深搜会爆
    memset(f,true,sizeof(f));
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        string s;
        cin>>s;
        for(int j=0;j<s.size();j++)
            if(s[j]=='0')
            f[i][j+1]=false;
            else{
                d[i][j+1]=0;
                f[i][j+1]=true;
                a[++tail].x=i;
                a[tail].y=j+1;
            }
    }
    for(head=1;head<=tail;head++)
        for(int i=1;i<=4;i++){
            int xx=a[head].x+dx[i],yy=a[head].y+dy[i];
            if(!f[xx][yy]){
                d[xx][yy]=d[a[head].x][a[head].y]+1;
                f[xx][yy]=true;
                a[++tail].x=xx;
                a[tail].y=yy;
            }
        }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++)
        cout<<d[i][j]<<" ";
        cout<<endl;
    }
    return 0;
}

*/

/*
P1257 平面上的最接近点对

题目描述

给定平面上 nnn 个点，找出其中的一对点的距离，使得在这 nnn 个点的所有点对中，该距离为所有点对中最小的。
输入格式

第一行一个整数 nnn，表示点的个数。

接下来 nnn 行，每行两个实数 x,yx,yx,y ，表示一个点的行坐标和列坐标。
输出格式

仅一行，一个实数，表示最短距离，四舍五入保留 444 位小数。
输入输出样例
输入 #1

3
1 1
1 2
2 2

输出 #1

1.0000

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 1≤n≤1041 \leq n \leq 10^41≤n≤104，0≤x,y≤1090 \leq x, y \leq 10^90≤x,y≤109，小数点后的数字个数不超过 666。

code:
const int N=2e5+50;
struct spot{
	double a[4];
}p[N];
double x,y,x_,y_,z,w,ans;
bool cmp(const spot &u,const spot &v){
	return u.a[0]<v.a[0];
}
int main(){//旋转角快排
	int n;cin>>n;
	z=sin(1),w=cos(1);  //旋转1弧度≈57°
	for(int i=1;i<=n;i++){
		scanf("%lf%lf",&x,&y);
		x_=x*w-y*z;
		y_=x*z+y*w;
		p[i].a[0]=x_;
		p[i].a[1]=y_;
		p[i].a[2]=x;
		p[i].a[3]=y;
	}
	sort(p+1,p+n+1,cmp);
	for(int i=n+1;i<=n+10;i++)
	p[i].a[0]=p[i].a[1]=-N-0.01;
	ans=2e9+0.01;
	for(int i=1;i<=n;i++)
        for(int j=1;j<=5;j++){
            x=p[i].a[2];y=p[i].a[3];
            x_=p[i+j].a[2];y_=p[i+j].a[3];
            z=sqrt((x-x_)*(x-x_)+(y-y_)*(y-y_));
            if(ans>z)
                ans=z;
        }
	printf("%.4lf\n",ans);
}

*/

/*
P1258 小车问题

题目描述

甲、乙两人同时从 A 地出发要尽快同时赶到 B 地。出发时 A 地有一辆小车，可是这辆小车除了驾驶员外只能带一人。已知甲、乙两人的步行速度一样，且小于车的速度。问：怎样利用小车才能使两人尽快同时到达。
输入格式

仅一行，三个实数，分别表示 AB 两地的距离 sss，人的步行速度 aaa，车的速度 bbb。
输出格式

两人同时到达 B 地需要的最短时间，保留 666 位小数。
输入输出样例
输入 #1

120 5 25

输出 #1

9.600000

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 0≤s,a,b≤1090 \leq s, a, b \leq 10^90≤s,a,b≤109。

code:
int main(){//二分算法
    double a,b,s,s1,s2,v1,v2,t1,t2,p;
    cin>>s>>v1>>v2;
    s1=0;s2=s;
    do{
        p=(s1+s2)/2.0;
        a=p/v2;
        b=(p-a*v1)/(v1+v2);
        t1=a+(s-p)/v1;
        t2=a+b+(s-(a+b)*v1)/v2;
        if(t1<t2)s2=p;          //对二分后查找二分
        else s1=p;
    }while(fabs(t1-t2)>1e-6);   //浮点绝对值
    printf("%.6f",t1);
    return 0;
}

*/

/*
P1271 【深基9.例1】选举学生会

题目描述

学校正在选举学生会成员，有 n(n≤999)n(n\le 999)n(n≤999) 名候选人，每名候选人编号分别从 1 到 nnn，现在收集到了 m(m<=2000000)m(m<=2000000)m(m<=2000000) 张选票，每张选票都写了一个候选人编号。现在想把这些堆积如山的选票按照投票数字从小到大排序。输入 nnn 和 mmm 以及 mmm 个选票上的数字，求出排序后的选票编号。
输入格式

无
输出格式

无
输入输出样例
输入 #1

5 10
2 5 2 2 5 2 2 2 1 2

输出 #1

1 2 2 2 2 2 2 2 5 5

code:
int main(){
    int n,m,p;
    cin>>n>>m;
    int person[n]={0};
    for(int i=0;i<m;i++){
        cin>>p;
        person[p-1]++;
    }
    for(int i=0;i<n;i++){
        while(person[i]){
            cout<<i+1<<" ";
            person[i]--;
        }
    }
    return 0;
}

*/

/*
P1276 校门外的树（增强版）

题目描述

校门外马路上本来从编号0到L，每一编号的位置都有1棵树。有砍树者每次从编号A到B处连续砍掉每1棵树，就连树苗也不放过（记 0 A B ，含A和B）；幸运的是还有植树者每次从编号C到D 中凡是空穴（树被砍且还没种上树苗或树苗又被砍掉）的地方都补种上树苗（记 1 C D，含C和D）；问最终校门外留下的树苗多少棵？植树者种上又被砍掉的树苗有多少棵？
输入格式

第一行L和N,表示校园外原来有L+1棵树，并有N次砍树或种树的操作。

以下N行，砍树或植树的标记和范围，每行3个整数。

L（1 <= L <= 10000）和 N（1 <= N <= 100）
输出格式

共两行。第1行校门外留下的树苗数目，第2行种上又被拔掉的树苗数目。
输入输出样例
输入 #1

10 3
0 2 6
1 1 8
0 5 7

输出 #1

3
2

code:
int a[10001],ans1,ans2;//ans1是拔去树苗的数量
int main(){
    int L,n;cin>>L>>n;
    memset(a,1,sizeof(a));
    for(int i=1;i<=n;i++){
        int k,t1,t2;
        cin>>k>>t1>>t2;
        if(k==0){
            for(int j=t1;j<=t2;j++){
                if(a[j]==2)
                    ans1++;
                a[j]=0;
            }
        }
        else{
            for(int j=t1;j<=t2;j++)
                if(a[j]==0)
                    a[j]=2;
        }
    }
    for(int i=0;i<=L;i++)
        if(a[i]==2)
            ans2++;
    cout<<ans2<<endl<<ans1;
    return 0;
}

*/

/*
P1287 盒子与球

题目描述

现有 rrr 个互不相同的盒子和 nnn 个互不相同的球，要将这 nnn 个球放入 rrr 个盒子中，且不允许有空盒子。请求出有多少种不同的放法。

两种放法不同当且仅当存在一个球使得该球在两种放法中放入了不同的盒子。
输入格式

输入只有一行两个整数，分别代表 nnn 和 rrr。
输出格式

输出一行一个整数代表答案。
输入输出样例
输入 #1

3 2

输出 #1

6

说明/提示
样例输入输出 1 解释

有两个盒子（编号为 1,21, 21,2）和三个球（编号为 1,2,31, 2, 31,2,3），共有六种方案，分别如下：
盒子编号 	方案 1 	方案 2 	方案 3 	方案 4 	方案 5 	方案 6
盒子 111 	小球 111 	小球 222 	小球 333 	小球 2,32, 32,3 	小球 1,31, 31,3 	小球 1,21, 21,2
盒子 222 	小球 2,32, 32,3 	小球 1,31, 31,3 	小球 1,21, 21,2 	小球 111 	小球 222 	小球 333
数据规模与约定

对于 100%100\%100% 的数据，保证 0≤r≤n≤100 \leq r \leq n \leq 100≤r≤n≤10，且答案小于 2312^{31}231。

code:
long long f(int n, int m){
    if (m <= 0 || n < m) return 0;
    if (n == m) return 1;
    else return f(n-1, m-1) + f(n-1, m) * m;
}
long long fac(int i){
    if (i == 1) return 1;
    else return i * fac(i - 1);
}
int main(){
    long long n, m;
    cin >> n >> m;
    cout<< f(n, m) * fac(m);
    return 0;
}

*/

/*
P1293 班级聚会

题目描述

毕业25年以后，我们的主人公开始准备同学聚会。打了无数电话后他终于搞到了所有同学的地址。他们有些人仍在本城市，但大多数人分散在其他的城市。不过，他发现一个巧合，所有地址都恰好分散在一条铁路线上。他准备出发邀请但无法决定应该在哪个地方举行宴会。最后他决定选择一个地点，使大家旅行的花费和最小。

不幸的是，我们的主人公既不擅长数学，也不擅长计算机。他请你帮忙写一个程序，根据他同学的地址，选择聚会的最佳地点。花费相同时优先取靠近莫斯科的城市。
输入格式

输入文件的每一行描述了一个城市的信息。

首先是城市里同学的个数，紧跟着是这个城市到Moscow（起点站）的距离（km），最后是城市的名称。最后一行描述的总是Moscow，它在铁路线的一端，距离为0。
输出格式

聚会地点城市名称和旅行费用（单程），两者之间用一空格隔开。每km花费一个卢布。
输入输出样例
输入 #1

7 9289 Vladivostok
5 8523 Chabarovsk
3 5184 Irkutsk
8 2213 Yalutorovsk
10 0 Moscow

输出 #1

Yalutorovsk 112125

说明/提示

城市数量<=150

距离<=10000

同学个数<=50

code:
long long o=1,minn=10000000,m;
struct pa{
    long long s;
    long long j;
    string n;
    long long cost;
}p[10005];
int main()
{
    while(cin>>p[o].s>>p[o].j>>p[o].n)
        o++;
    for(int i=1;i<o;i++)
    {
        for(int g=1;g<o;g++)
            p[i].cost+=abs(p[i].j-p[g].j)*p[g].s;
        if(p[i].cost<=minn)
        {
            minn=p[i].cost;
            m=i;
        }
    }
    cout<<p[m].n<<" "<<p[m].cost<<endl;
    return 0;
} 

*/

/*
P1303 A*B Problem

题目描述

求两数的积。
输入格式

两行，两个整数。
输出格式

一行一个整数表示乘积。
输入输出样例
输入 #1

1 
2

输出 #1

2

说明/提示

每个数字不超过 10200010^{2000}102000 ，需用高精。

code:
char a1[50001],b1[50001];
int a[50001],b[50001],i,x,len,j,c[50001];
int main (){
    cin >>a1 >>b1;
    a[0]=strlen(a1);b[0]=strlen(b1);
    for (i=1;i<=a[0];i++)
        a[i]=a1[a[0]-i]-'0';
    for (i=1;i<=b[0];i++)
        b[i]=b1[b[0]-i]-'0';
    for (i=1;i<=a[0];i++)
        for (j=1;j<=b[0];++j)
            c[i+j-1]+=a[i]*b[j];
    len=a[0]+b[0];
    for (i=1;i<len;i++)
        if (c[i]>9)
            c[i+1]+=c[i]/10,c[i]%=10;
    while (c[len]==0&& (len>1))//注意这里要大于1
        len--;
    for (i=len;i>=1;i--)cout <<c[i];
    return 0;
}

*/

/*
P1305 新二叉树

题目描述

输入一串二叉树，输出其前序遍历。
输入格式

第一行为二叉树的节点数 nnn。(1≤n≤261 \leq n \leq 261≤n≤26)

后面 nnn 行，每一个字母为节点，后两个字母分别为其左右儿子。

空节点用 * 表示
输出格式

二叉树的前序遍历。
输入输出样例
输入 #1

6
abc
bdi
cj*
d**
i**
j**

输出 #1

abdicj

code:
int n;
char a[26][3];
void f(char x,int c){//二叉树的先序深度搜索
    if(x!='*'){
        cout<<x;
        for(int i=c;i<=n;i++)//从c开始能减少循环,但是可能会多消耗空间(多传入c)
            if(a[i][0]==x){
                f(a[i][1],c+1);
                f(a[i][2],c+1);
            }
    }
    return;
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i][0]>>a[i][1]>>a[i][2];
    f(a[1][0],1);
    return 0;
}

*/

/*
P1308 [NOIP2011 普及组] 统计单词数

题目描述

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例1 ），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例2 ）。
输入格式

共222行。

第111行为一个字符串，其中只含字母，表示给定单词；

第222行为一个字符串，其中只可能包含字母和空格，表示给定的文章。
输出格式

一行，如果在文章中找到给定单词则输出两个整数，两个整数之间用一个空格隔开，分别是单词在文章中出现的次数和第一次出现的位置（即在文章中第一次出现时，单词首字母在文章中的位置，位置从000 开始）；如果单词在文章中没有出现，则直接输出一个整数?1-1?1。
输入输出样例
输入 #1

To
to be or not to be is a question

输出 #1

2 0

输入 #2

to
Did the Ottoman Empire lose its power at that time

输出 #2

-1

说明/提示

数据范围

1≤1≤ 1≤单词长度≤10≤10≤10。

1≤1≤ 1≤文章长度≤1,000,000≤1,000,000≤1,000,000。

noip2011普及组第2题
//注,这题样例过不了是enter的问题
code:
int main(){
    string a,b;
    getline(cin,a);
    getline(cin,b);
    for (int i=0;i<a.length();++i)
        a[i]=tolower(a[i]);
    for (int i=0;i<b.length();++i)
        b[i]=tolower(b[i]);
    a=' '+a+' ';
    b=' '+b+' ';
    int alpha=b.find(a);
    int beta=b.find(a),s=0;
    while (beta!=string::npos){//npos用法
        s++;
        beta=b.find(a,beta+1);
    }
    if(s==0) cout<<-1<<endl;
    else cout<<s<<" "<<alpha<<endl;
    return 0;
}

*/

/*
P1324 矩形分割

题目描述

出于某些方面的需求，我们要把一块N×M的木板切成一个个1×1的小方块。

对于一块木板，我们只能从某条横线或者某条竖线（要在方格线上），而且这木板是不均匀的，从不同的线切割下去要花不同的代价。而且，对于一块木板，切割一次以后就被分割成两块，而且不能把这两块木板拼在一起然后一刀切成四块，只能两块分别再进行一次切割。

现在，给出从不同的线切割所要花的代价，求把整块木板分割成1×1块小方块所需要耗费的最小代价。
输入格式

输入文件第一行包括N和M，表示长N宽M的矩阵。

第二行包括N-1个非负整数，分别表示沿着N-1条横线切割的代价。

第三行包括M-1个非负整数，分别表示沿着M-1条竖线切割的代价。
输出格式

输出一个整数，表示最小代价。
输入输出样例
输入 #1

2 2
3
3

输出 #1

9

说明/提示

数据范围：

对于60%的数据，有1 ≤ N ,M≤ 100；

对于100%的数据，有1 ≤ N,M ≤ 2000。

code:
bool cmp(int aa,int bb){return aa>bb;}
int main(){
	int n,m,s1=1,s2=1;cin>>n>>m;
    int a[n+1]={0},b[m+1]={0};
	for(int i=1;i<n;i++) scanf("%d",&a[i]);
	for(int i=1;i<m;i++) scanf("%d",&b[i]);
	sort(a+1,a+n,cmp);sort(b+1,b+m,cmp);
	long long ans=0;
	for(int i=2;i<n+m;i++)
		if(a[s1]>b[s2]) ans+=s2*a[s1++];
		else ans+=s1*b[s2++];
	cout<<ans;
	return 0;
}

*/

/*
P1327 数列排序

题目描述

给定一个数列 aaa，这个数列满足 ai=?aja_i \not =a_jai?=aj?（i=?ji\not=ji=j），现在要求你把这个数列从小到大排序，每次允许你交换其中任意一对数，请问最少需要几次交换？
输入格式

第一行是一个整数，代表数字个数 nnn。

第二行有 nnn 个整数用空格分隔开，表示数列 aaa。
输出格式

只有一行，包含一个数，表示最少的交换次数。
输入输出样例
输入 #1

8
8 23 4 16 77 -5 53 100

输出 #1

5

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 1≤n≤1051\le n\le10^51≤n≤105，?231<ai<231?1-2^{31}\lt a_i\lt2^{31}-1?231<ai?<231?1。

code:
map<int,int>F;//以图排序
int a[100001],b[100001],n,m,ans;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)scanf("%d",&a[i]),b[i]=a[i],F[a[i]]=i;
    sort(b+1,b+n+1);
    for(int i=1;i<=n;i++)
        if(a[i]!=b[i]){
            ans++;
            int x=F[b[i]];
            F[a[i]]=x;
            a[x]=a[i];
        }
    cout<<ans;
}

*/

/*
P1328 [NOIP2014 提高组] 生活大爆炸版石头剪刀布

题目描述

石头剪刀布是常见的猜拳游戏:石头胜剪刀,剪刀胜布,布胜石头。如果两个人出拳一 样，则不分胜负。在《生活大爆炸》第二季第8集中出现了一种石头剪刀布的升级版游戏。

升级版游戏在传统的石头剪刀布游戏的基础上,增加了两个新手势:

斯波克:《星际迷航》主角之一。

蜥蜴人:《星际迷航》中的反面角色。

这五种手势的胜负关系如表一所示,表中列出的是甲对乙的游戏结果。

现在,小 A 和小 B 尝试玩这种升级版的猜拳游戏。已知他们的出拳都是有周期性规律的，但周期长度不一定相等。例如：如果小A以“石头-布-石头-剪刀-蜥蜴人-斯波克”长度为 666 的周期出拳,那么他的出拳序列就是“石头-布-石头-剪刀-蜥蜴人-斯波克-石头-布-石头-剪刀-蜥蜴人-斯波克-......”,而如果小B以“剪刀-石头-布-斯波克-蜥蜴人”长度为 555 的周期出拳,那么他出拳的序列就是“剪刀-石头-布-斯波克-蜥蜴人-剪刀-石头-布-斯波克-蜥蜴人-......”

已知小 A 和小 B 一共进行 NNN 次猜拳。每一次赢的人得 111 分，输的得 000 分；平局两人都得 000 分。现请你统计 NNN 次猜拳结束之后两人的得分。
输入格式

第一行包含三个整数：N,NA,NBN,N_A,N_BN,NA?,NB?,分别表示共进行 NNN 次猜拳、小 A 出拳的周期长度，小 B 出拳的周期长度。数与数之间以一个空格分隔。

第二行包含 NAN_ANA? 个整数,表示小 A出拳的规律,第三行包含 NBN_BNB? 个整数,表示小 B 出拳的规律。其中，000 表示“剪刀”，111 表示“石头”，222 表示“布”，333 表示“蜥蜴人”，44 4表示“斯波克”。数与数之间以一个空格分隔。
输出格式

输出一行，包含两个整数，以一个空格分隔，分别表示小 A、小 B 的得分。
输入输出样例
输入 #1

10 5 6
0 1 2 3 4
0 3 4 2 1 0

输出 #1

6 2

输入 #2

9 5 5
0 1 2 3 4
1 0 3 2 4

输出 #2

4 4

说明/提示

对于100%100\%100%的数据，0<N≤200,0<NA≤200,0<NB≤2000 < N \leq 200, 0 < N_A \leq 200, 0 < N_B \leq 2000<N≤200,0<NA?≤200,0<NB?≤200 。

code:
int sum1=0,sum2=0;
int vs[5][5] = {{0,0,1,1,0},{1,0,0,1,0},{0,1,0,0,1},{0,0,1,0,1},{1,1,0,0,0}}; //得分表的处理 
int main(){
    int num,n,m;cin>>num>>n>>m;
    int a[n],b[m],c=0,d=0;
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<m;i++)cin>>b[i];
    while(num--){
        if(c>=n)c=0;
        if(d>=m)d=0;
        sum1+=vs[a[c]][b[d]];
        sum2+=vs[b[d]][a[c]];
        c++;
        d++;
    }
    cout<<sum1<<" "<<sum2;
    return 0;
}

*/

/*
P1331 海战

题目描述

在峰会期间，武装部队得处于高度戒备。警察将监视每一条大街，军队将保卫建筑物，领空将布满了F-2003飞机。此外，巡洋船只和舰队将被派去保护海岸线。不幸的是因为种种原因，国防海军部仅有很少的几位军官能指挥大型海战。因此，他们考虑培养一些新的海军指挥官，他们选择了“海战”游戏来帮助学习。

在这个著名的游戏中，在一个方形的盘上放置了固定数量和形状的船只，每只船却不能碰到其它的船。在这个题中，我们仅考虑船是方形的，所有的船只都是由图形组成的方形。编写程序求出该棋盘上放置的船只的总数。
输入格式

输入文件头一行由用空格隔开的两个整数R和C组成，1<=R,C<=1000，这两个数分别表示游戏棋盘的行数和列数。接下来的R行每行包含C个字符，每个字符可以为“#”，也可为“.”，“#”表示船只的一部分，“.”表示水。
输出格式

为每一个段落输出一行解。如果船的位置放得正确（即棋盘上只存在相互之间不能接触的方形，如果两个“#”号上下相邻或左右相邻却分属两艘不同的船只，则称这两艘船相互接触了）。就输出一段话“There are S ships.”,S表示船只的数量。否则输出“Bad placement.”。
输入输出样例
输入 #1

6 8
.....#.#
##.....#
##.....#
.......#
#......#
#..#...#

输出 #1

There are 5 ships.

code:
char map[1010][1010];
int fx[4]={0,-1,1,0},fy[4]={-1,0,0,1},r,c,s;
void dfs(int x,int y){
	map[x][y]='*';
	for(int i=0;i<4;i++)
		if(x+fx[i]>0 && x+fx[i]<=r && y+fy[i]>0 && y+fy[i]<=c && map[x+fx[i]][y+fy[i]]=='#')
            dfs(x+fx[i],y+fy[i]);
}
bool d(int i,int j){
	int c=0;
	if(map[i][j]=='#')c++;if(map[i+1][j]=='#')c++;if(map[i][j+1]=='#')c++;if(map[i+1][j+1]=='#')c++;
	if(c==3)return 0;
	return 1;
}
int main(){
	cin>>r>>c;
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
		    cin>>map[i][j];
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			if(i<r&&j<c&&d(i,j)==0){
				printf("Bad placement.");
				return 0;
			}
	for(int i=1;i<=r;i++)
		for(int j=1;j<=c;j++)
			if(map[i][j]=='#')
			    s++,dfs(i,j);	
	printf("There are %d ships.",s);
	return 0;
}

*/

/*
P1334 瑞瑞的木板

题目背景

瑞瑞想要亲自修复在他的一个小牧场周围的围栏。
题目描述

他测量栅栏并发现他需要 nnn 根木板，每根的长度为整数 lil_ili?。于是，他买了一根足够长的木板，长度为所需的 nnn 根木板的长度的总和，他决定将这根木板切成所需的 nnn 根木板（瑞瑞在切割木板时不会产生木屑，不需考虑切割时损耗的长度)。

瑞瑞切割木板时使用的是一种特殊的方式，这种方式在将一根长度为 xxx 的木板切为两根时，需要消耗 xxx 个单位的能量。瑞瑞拥有无尽的能量，但现在提倡节约能量，所以作为榜样，他决定尽可能节约能量。显然，总共需要切割 (n?1)(n-1)(n?1) 次，问题是，每次应该怎么切呢？请编程计算最少需要消耗的能量总和。
输入格式

输入的第一行是整数，表示所需木板的数量 nnn。

第 222 到第 (n+1)(n + 1)(n+1) 行，每行一个整数，第 (i+1)(i + 1)(i+1) 行的整数 lil_ili? 代表第 iii 根木板的长度 lil_ili?。
输出格式

一个整数，表示最少需要消耗的能量总和。
输入输出样例
输入 #1

3
8
5
8

输出 #1

34

说明/提示
输入输出样例 1 解释

将长度为 212121 的木板，第一次切割为长度为 888 和长度为 131313 的，消耗 212121 个单位的能量，第二次将长度为 131313 的木板切割为长度为 555 和 888 的，消耗 131313 个单位的能量，共消耗 343434 个单位的能量，是消耗能量最小的方案。
数据规模与约定

    对于 100%100\%100% 的数据，保证 1≤n≤2×1041\le n \le 2 \times 10^41≤n≤2×104，1≤li≤5×1041 \leq l_i \leq 5 \times 10^41≤li?≤5×104。

code:
int main(){
    std::ios::sync_with_stdio(false);//用于对cin的加速
    priority_queue<long long,vector<long long>,greater<long long>>q;//优先队列 greater升序 less降序
    long long n,t,ans=0,tmp=0,a=0,b=0;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>t;
        q.push(t);
    }
    while(q.size()>1){////只有一个队列时,,,结束计算
        a=q.top();
        q.pop();
        b=q.top();
        q.pop();
        tmp=a+b;
        ans+=tmp;
        q.push(tmp);//把两对整合进队列
    }
    cout<<ans<<endl;
    return 0;
}

*/

/*
P1348 Couple number

题目描述

对于一个整数 nnn，若存在正整数 a,ba, ba,b，满足 n=a2?b2n = a^2 - b^2n=a2?b2，则称 nnn 是 Couple number。

请求出 [a,b][a, b][a,b] 范围内有多少个 Couple number。
输入格式

输入只有一行两个整数，分别表示 a,ba, ba,b。
输出格式

输出一行一个整数表示答案。
输入输出样例
输入 #1

1 10

输出 #1

7

说明/提示
数据规模与约定

对于全部的测试点，保证 1≤a<b≤263?11 \le a < b \le 2^{63}-11≤a<b≤263?1 ，b?a≤107b - a \le 10^7b?a≤107。

code:
int main(){//注:完全平方函数,4倍或奇数符合条件
    int a,b,ans=0;cin>>a>>b;
    for(int i=a;i<=b;i++)
        if(i%4==0 || i%2!=0)
            ans++;
    cout<<ans;
    return 0;
}

*/

/*
P1358 扑克牌

题目描述

组合数学是数学的重要组成部分，是一门研究离散对象的科学，它主要研究满足一定条件的组态（也称组合模型）的存在、计数以及构造等方面的问题。组合数学的主要内容有组合计数、组合设计、组合矩阵、组合优化等。

随着计算机科学的日益发展，组合数学的重要性也日渐凸显，因为计算机科学的核心内容是使用算法处理离散数据。

今天我们来研究组合数学中的一个有趣的问题，也是一个简单的计数问题：

从一副含有 nnn 张的扑克牌(每张扑克牌都不相同)中，分给 mmm 个人，第 iii 个人得到 aia_iai? 张牌，求一共有几种分法，这个数可能非常大，请输出此数模 100071000710007 后的结果。
输入格式

第一行两个整数为 n,mn,mn,m。

第二行 mmm 个整数 aia_iai?。
输出格式

此数模 100071000710007 后的结果。
输入输出样例
输入 #1

5 2
3 1

输出 #1

20

输入 #2

20 19
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

输出 #2

8707

说明/提示

对于 50%50\%50% 的数据：M=1M=1M=1。

对于 100%100\%100% 的数据：1≤n≤1041 \leq n \leq 10^41≤n≤104，1≤m≤1001 \leq m \leq 1001≤m≤100，0≤ai≤1000 \leq a_i \leq 1000≤ai?≤100。

code:
int n,m,s=1,t,a[10005][105];//这题有点奇怪,数据开a[10001][101]会爆
int main(){
	cin>>n>>m;
	a[0][0]=1;
	for(int i=1;i<=10000;i++)
		for(int j=0;j<=100;j++)
			a[i][j]=(a[i-1][j-1]+a[i-1][j])%10007;//当a[?][0-1]时值为0,野指针
	for(int i=1;i<=m;i++){
		cin>>t;
		s=s*a[n][t]%10007;
		n-=t;
	}
	cout<<s;
	return 0;
}

*/

/*
P1359 租用游艇

题目描述

长江游艇俱乐部在长江上设置了 nnn 个游艇出租站 1,2,??,n1,2,\cdots,n1,2,?,n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站 iii 到游艇出租站 jjj 之间的租金为 r(i,j)r(i,j)r(i,j)（1≤i<j≤n1\le i\lt j\le n1≤i<j≤n）。试设计一个算法，计算出从游艇出租站 111 到游艇出租站 nnn 所需的最少租金。
输入格式

第一行中有一个正整数 nnn，表示有 nnn 个游艇出租站。接下来的 n?1n-1n?1 行是一个半矩阵 r(i,j)r(i,j)r(i,j)（1≤i<j≤n1\le i<j\le n1≤i<j≤n）。
输出格式

输出计算出的从游艇出租站 111 到游艇出租站 nnn 所需的最少租金。
输入输出样例
输入 #1

3
5 15
7

输出 #1

12

说明/提示

n≤200n\le 200n≤200，保证计算过程中任何时刻数值都不超过 10610^6106。

code://dp
int n,r[201][201],f[201];
int main(){
	cin >> n;
    for(int i = 1;i <= n-1;i++)
        for(int j = i+1;j <= n;j++)
            cin >> r[i][j];
    for(int i = 1;i <= n;i++)
        f[i] = r[1][i];
    for(int i = 2;i <= n;i++)
    	for(int j = 2;j <= i;j++)
    	    f[i] = min(f[i],f[j-1]+r[j-1][i]);
	cout << f[n] <<	 endl;
	return 0;
}

*/

/*
P1372 又是毕业季I

题目背景

“叮铃铃铃”，随着高考最后一科结考铃声的敲响，三年青春时光顿时凝固于此刻。毕业的欣喜怎敌那离别的不舍，憧憬着未来仍毋忘逝去的歌。100010001000 多个日夜的欢笑和泪水，全凝聚在毕业晚会上，相信，这一定是一生最难忘的时刻！
题目描述

为了把毕业晚会办得更好，老师想要挑出默契程度最大的 kkk 个人参与毕业晚会彩排。可是如何挑呢？老师列出全班同学的号数 1,2,…,n1,2,\ldots ,n1,2,…,n 并且相信 kkk 个人的默契程度便是他们的最大公约数（这不是迷信哦~）。这可难为了他，请你帮帮忙吧！

PS：一个数的最大公约数即本身。
输入格式

两个空格分开的正整数 nnn 和 kkk。
输出格式

一个整数，为最大的默契值。
输入输出样例
输入 #1

4 2

输出 #1

2

说明/提示

对于 20%20\%20% 的数据，k≤2k \le 2k≤2，n≤103n \le 10^3n≤103。

对于另 30%30\%30% 的数据，k≤10k \le 10k≤10，n≤100n \le 100n≤100。

对于 100%100\%100% 的数据，k≤109k \le 10^9k≤109，n≤109n \le 10^9n≤109，n≥k≥1n \ge k \ge 1n≥k≥1（神难校，人数众多）。

code:
int main(){
    long long n,k;
    cin>>n>>k;
    cout<<n/k;
    return 0;
}

*/

/*
P1376 [USACO05MAR]Yogurt factory 机器工厂

题目描述

小 T 开办了一家机器工厂，在 NNN个星期内，原材料成本和劳动力价格不断起伏，第 iii 周生产一台机器需要花费 CiC_iCi? 元。若没把机器卖出去，每保养一台机器，每周需要花费 SSS 元，这个费用不会发生变化。

机器工厂接到订单，在第 iii 周需要交付 YiY_iYi? 台机器给委托人，第 iii 周刚生产的机器，或者之前的存货，都可以进行交付。

请你计算出这 nnn 周时间内完成订单的最小代价。
输入格式

第一行输入两个整数 NNN 和 SSS，接下来 NNN 行每行两个数 CiC_iCi? 和 YiY_iYi?。
输出格式

输出一个整数，表示最少的代价。
输入输出样例
输入 #1

4 5
88 200
89 400
97 300
91 500

输出 #1

126900

说明/提示

1≤n≤1041\leq n\leq 10^41≤n≤104，1≤Ci≤50001 \le C_i \le 50001≤Ci?≤5000，1≤S≤1001 \le S\le 1001≤S≤100，0≤Yi≤1040\le Y_i\le 10^40≤Yi?≤104。

code:
int main(){
    int n,s;cin>>n>>s;
    int gold[n],data[n];
    long long ans=0;
    for(int i=0;i<n;i++)cin>>gold[i]>>data[i];
    for(int i=0;i<n;i++){
        if(i==0)ans+=gold[i]*data[i];
        else {
        gold[i]=min(gold[i],gold[i-1]+s);
        ans+=gold[i]*data[i];
        }
    }
    cout<<ans;
    return 0;
}

*/

/*
P1403 [AHOI2005]约数研究

题目描述

科学家们在 Samuel 星球上的探险得到了丰富的能源储备，这使得空间站中大型计算机 Samuel II 的长时间运算成为了可能。由于在去年一年的辛苦工作取得了不错的成绩，小联被允许用 Samuel II 进行数学研究。

小联最近在研究和约数有关的问题，他统计每个正数 NNN 的约数的个数，并以 f(N)f(N)f(N) 来表示。例如 121212 的约数有 1,2,3,4,6,121,2,3,4,6,121,2,3,4,6,12，因此 f(12)=6f(12)=6f(12)=6。下表给出了一些 f(N)f(N)f(N) 的取值：
NNN 	111 	222 	333 	444 	555 	666
f(N)f(N)f(N) 	111 	222 	222 	333 	222 	444

现在请你求出：

∑i=1nf(i)\sum_{i=1}^n f(i)
i=1∑n?f(i)
输入格式

输入一个整数 nnn。
输出格式

输出答案。
输入输出样例
输入 #1

3

输出 #1

5

说明/提示

    对于 20%20\%20% 的数据，N≤5000N \leq 5000N≤5000；
    对于 100%100\%100% 的数据，1≤N≤1061 \leq N \leq 10^61≤N≤106。


code:
int main(){//不完全的数理证明
    int n,sum;
	cin>>n;
	for(int k=1;k<=n;k++)
		sum+=n/k;
	cout<<sum<<endl;
	return 0;
}

*/

/*
P1413 坚果保龄球

题目描述

PVZ这款游戏中，有一种坚果保龄球。zombie从地图右侧不断出现，向左走，玩家需要从左侧滚动坚果来碾死他们。

我们可以认为地图是一个行数为6，列数为60的棋盘。zombie出现的那一秒站在这一行的第60列，之后每秒向左移动一步。玩家可以随时在屏幕最某一行第一列摆放坚果，这一行的zombie瞬间全被滚过去的坚果碾死。如果zombie走到第1列没有被消灭，如果再向左走，则你的大脑就会被zombie吃掉。

现在有n只zombie！告诉你每只zombie出现的时间以及在出现的行数（可能会同时出现同一位置的僵尸），请问至少需要多少坚果才能消灭所有的zombie。
输入格式

第一行一个正整数n，表示zombie数量。

之后n行中，每行两个正整数P和t，分别表示zombie所在行和zombie出现的时间。
输出格式

一个正整数，最少需要的坚果数。
输入输出样例
输入 #1

10
1 1
1 61
2 1
2 60
3 1
3 2
3 3
3 4
4 1
4 99999

输出 #1

6

说明/提示

【数据规模】

n<=2000，t<=100000，1<=P<=6

【题目来源】

kkksc03改编

code:
struct zombie{
	int p,t;
}b[2010];
int a[7],ans=0,n;
bool cmp(zombie x,zombie y){
	return x.t<y.t;
}
int main(){
	cin>>n;
	memset(a,-60,sizeof(a));
	for(int i=1;i<=n;i++)
	    cin>>b[i].p>>b[i].t;
	sort(b+1,b+n+1,cmp);
	for(int i=1;i<=n;i++)
        if(a[b[i].p]>=b[i].t || a[b[i].p]+60<b[i].t){
            ans++;
            a[b[i].p]=b[i].t-1;
        }   
	cout<<ans;
}

*/

/*
P1416 攻击火星

题目描述

一群外星人将要攻击火星。

火星的地图是一个n个点的无向图。这伙外星人将按照如下方法入侵，先攻击度为0的点（相当于从图中删除掉它），然后是度为1的点，依此类推直到度为n-1的点。

所有的点度统计是动态统计的。（一个点删掉后，与之相连的点的点度都会-1）。外星人攻击度为某个数的点时是同时攻击的。

你需要设计这个图的边的方案来使得未被攻击的点最多。
输入格式

输入文件包含一行一个整数n。
输出格式

一行一个整数，表示最多的最后未被攻击的点。
输入输出样例
输入 #1

3

输出 #1

1

说明/提示

【样例解释】

①-②-③，这样首先删掉度为1的①和③，此时②度数为0，不会被删去。

【数据范围】

对于20%的数据1<=n<=10

对于100%的数据1<=n<=50000

【题目来源】

tinylic改编

code:
int main(){
    int n;
    cin>>n;
    n>=2?printf("%d",n-2):printf("0");
    return 0;
}

*/

/*
P1449 后缀表达式

题目描述

所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。

如：3*(5C2)+7对应的后缀表达式为：3．5．2．-*7．+@。’@’为表达式的结束符号。‘.’为操作数的结束符号。
输入格式

输入：后缀表达式
输出格式

输出：表达式的值
输入输出样例
输入 #1

3.5.2.-*7.+@

输出 #1

16

说明/提示

字符串长度，1000内。

code:
long long stk[1000];
int main(){
    long long i=0,now=0;
    char op;
    while((op=getchar())!='@'){
        if(op>='0'&&op<='9') now*=10,now+=op-'0';
        else if(op=='.')stk[++i]=now,now=0;
        else if(op=='+')stk[i-1]=stk[i-1]+stk[i],stk[i]=0,i--;
        else if(op=='-')stk[i-1]=stk[i-1]-stk[i],stk[i]=0,i--;
        else if(op=='*')stk[i-1]=stk[i-1]*stk[i],stk[i]=0,i--;
        else if(op=='/')stk[i-1]=stk[i-1]/stk[i],stk[i]=0,i--;
    }
    cout<<stk[1];
    return 0;
}

*/

/*
P1451 求细胞数量

题目描述

一矩形阵列由数字 000 到 999 组成，数字 111 到 999 代表细胞，细胞的定义为沿细胞数字上下左右若还是细胞数字则为同一细胞，求给定矩形阵列的细胞个数。
输入格式

第一行两个整数代表矩阵大小 nnn 和 mmm。

接下来 nnn 行，每行一个长度为 mmm 的只含字符 0 到 9 的字符串，代表这个 n×mn \times mn×m 的矩阵。
输出格式

一行一个整数代表细胞个数。
输入输出样例
输入 #1

4 10
0234500067
1034560500
2045600671
0000000089

输出 #1

4

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 1≤n,m≤1001 \le n,m \le 1001≤n,m≤100。

code:
int n,m,ans;
char a[101][101];
void dfs(int x,int y) {
    if(x<0||y<0||x>n-1||y>m-1)return ;
    a[x][y]='0';
	if(a[x][y+1]!='0')dfs(x,y+1);
	if(a[x][y-1]!='0')dfs(x,y-1);
	if(a[x+1][y]!='0')dfs(x+1,y);
	if(a[x-1][y]!='0')dfs(x-1,y);
}
int main() {
	cin>>n>>m;
	for(int i=0; i<n; i++)
		for(int j=0; j<m; j++)
			cin>>a[i][j];
	for(int i=0; i<n; i++)
		for(int j=0; j<m; j++)
			if(a[i][j]!='0')
				ans++,dfs(i,j);
	cout<<ans;
	return 0;
}

*/

/*
P1454 圣诞夜的极光

题目背景

圣诞夜系列~~
题目描述

圣诞老人回到了北极圣诞区，已经快到12点了。也就是说极光表演要开始了。这里的极光不是极地特有的自然极光景象。而是圣诞老人主持的人造极光。

轰隆隆……烟花响起（来自中国的浏阳花炮之乡）。接下来就是极光表演了。

人造极光其实就是空中的一幅幅n*m的点阵图像。只是因为特别明亮而吸引了很多很多小精灵的目光，也成为了圣诞夜最美丽的一刻。

然而在每幅n*m的点阵图像中，每一个点只有发光和不发光两种状态。对于所有的发光的点，在空中就形成了美丽的图画。而这个图画是以若干个（s个）图案组成的。对于图案，圣诞老人有着严格的定义：对于两个发光的点，如果他们的曼哈顿距离（对于A(x1,y1)和B(x2,y2)，A和B之间的曼哈顿距离为|x1-x2|+|y1-y2|）小于等于2。那么这两个点就属于一个图案…… 小精灵们一边欣赏着极光，一边数着每一幅极光图像中的图案数。伴着歌声和舞蹈，度过了美丽的圣诞之夜。^_^
输入格式

第一行，两个数n和m。

接下来一共n行，每行m个字符。对于第i行第j个字符，如果其为“-”，那么表示该点不发光，如果其为“#”，那么表示该点发光。不可能出现其他的字符。
输出格式

第一行，一个数s。
输入输出样例
输入 #1

19 48
------------------------------------------------
---####-----#-----#----------------------####---
--######----#-----#---------------------######--
-########--#-#---#-#####--#-##-##---#--########-
-###--###--#-#---#-#----#-##-##--#--#--###--###-
-###--###--#--#-#--######-#--#---#-#---###--###-
-########--#--#-#--#------#--#----##---########-
--######---#---#---######-#--#-----#----######--
---####----------------------------#-----####---
----------------------------------#-------------
------------------------------------------------
---###--#--------#------#-----------------------
--#---#-#---------------#-----------------------
-#------#-##--#-##--##-###-#-##-###--###-#--##--
-#------##--#-##-#-#----#--##--#---##---##-#----
-#------#---#-#--#--#---#--#---#---##----#--#---
--#---#-#---#-#--#---#--#--#---#---##---##---#--
---###--#---#-#--#-##---#--#---#---#-###-#-##---
------------------------------------------------

输出 #1

4

说明/提示

1<=n,m<=100

DFS~~

code:
int n,m,ans,nx[13]={0,1,-1,0,0,2,-2,0,0,1,-1,1,-1},ny[13]={0,0,0,1,-1,0,0,2,-2,-1,1,1,-1}; 
char a[1001][1001];
void dfs(int x,int y){
	if(x<0 || x>n-1 || y<0 || y>m-1 || a[x][y]!='#') return;
    a[x][y]='-';
    for(int i=1;i<13;i++) dfs(x+nx[i],y+ny[i]);
}
int main(){//标准DFS
    cin>>n>>m;
    for(int i=0;i<n;i++) 
        for(int j=0;j<m;j++) 
            cin>>a[i][j]; 
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            if (a[i][j]=='#')
                ans++,dfs(i,j);
    cout<<ans;
}

*/

/*
P1458 [USACO2.1]顺序的分数 Ordered Fractions

题目描述

输入一个自然数 nnn，对于一个最简分数 a/ba/ba/b（分子和分母互质的分数），满足 1≤b≤n,0≤a/b≤11 \le b \le n,0 \le a/b \le 11≤b≤n,0≤a/b≤1，请找出所有满足条件的分数。

这有一个例子，当 n=5n=5n=5 时，所有解为：

01,15,14,13,25,12,35,23,34,45,11\frac01,\frac15,\frac14,\frac13,\frac25,\frac12,\frac35,\frac23,\frac34 ,\frac45,\frac11
10?,51?,41?,31?,52?,21?,53?,32?,43?,54?,11?

给定一个自然数 nnn，请编程按分数值递增的顺序输出所有解。

注：
1、000 和任意自然数的最大公约数就是那个自然数。
2、互质指最大公约数等于1的两个自然数。
输入格式

单独的一行一个自然数 nnn
输出格式

每个分数单独占一行，按照大小次序排列
输入输出样例
输入 #1

5

输出 #1

0/1
1/5
1/4
1/3
2/5
1/2
3/5
2/3
3/4
4/5
1/1

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤n≤1601\le n \le 1601≤n≤160。

USACO 2.1

翻译来自NOCOW

code:
int N;//做个笔记
void dfs(const int& l1, const int& l2, const int& r1, const int& r2){
    if(l2>N || r2>N)return ;
    dfs(l1,l2,l1+r1,l2+r2);
    if(l2+r2<=N)printf("%d/%d\n",l1+r1,l2+r2);
    dfs(l1+r1,l2+r2,r1,r2);
}
int main(){//分数树
    cin>>N;
    printf("0/1\n");
    dfs(0,1,1,1);
    printf("1/1\n");
    return 0;
}

*/

/*
P1459 [USACO2.1]三值的排序 Sorting a Three-Valued Sequence

题目描述

排序是一种很频繁的计算任务。现在考虑最多只有三值的排序问题。一个实际的例子是，当我们给某项竞赛的优胜者按金银铜牌排序的时候。在这个任务中可能的值只有三种 1,2,31,2,31,2,3。我们用交换的方法把他排成升序的。

写一个程序计算出，给定的一个 1,2,31,2,31,2,3 组成的数字序列，排成升序所需的最少交换次数
输入格式

第一行一个正整数 nnn，表示奖牌个数。
接下来 nnn 行，每行一个 [1,3][1,3][1,3] 内的整数，表示奖牌。
输出格式

输出一行一个整数，表示排成升序所需的最少交换次数。
输入输出样例
输入 #1

9
2
2
1
3
3
3
2
3
1

输出 #1

4

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤n≤10001\le n \le 10001≤n≤1000。

USACO 2.1

翻译来自NOCOW

code:
int main(){//贪心算法
    int n,ans=0,sum=0,f[3][3]={0};
    cin>>n;
    int a[n],b[n];
    for(int i=0;i<n;i++) 
        scanf("%d",&a[i]),b[i]=a[i];
    sort(b,b+n); 
    for(int i=0;i<n;i++) f[b[i]-1][a[i]-1]++;
    ans=min(f[0][1],f[1][0]);
    f[0][1]-=ans;
    f[1][0]-=ans;
    sum+=ans;
    ans=min(f[0][2],f[2][0]);
    f[0][2]-=ans;
    f[2][0]-=ans;
    sum+=ans;
    ans=min(f[1][2],f[2][1]);
    f[1][2]-=ans;
    f[2][1]-=ans;
    sum+=ans;
    sum+=max(f[0][1],f[1][0])*2;//三处都错则累加二倍
    printf("%d\n",sum);
    return 0;
}

*/

/*
P1460 [USACO2.1]健康的荷斯坦奶牛 Healthy Holsteins 

题目描述

农民 John 以拥有世界上最健康的奶牛为傲。他知道每种饲料中所包含的牛所需的最低的维他命量是多少。请你帮助农夫喂养他的牛，以保持它们的健康，使喂给牛的饲料的种数最少。

给出牛所需的最低的维他命量，输出喂给牛需要哪些种类的饲料，且所需的饲料剂量最少。

维他命量以整数表示，每种饲料最多只能对牛使用一次，数据保证存在解。
输入格式

第一行一个整数 vvv，表示需要的维他命的种类数。
第二行 vvv 个整数，表示牛每天需要的每种维他命的最小量。

第三行一个整数 ggg，表示可用来喂牛的饲料的种数。
下面 ggg 行，第 nnn 行表示编号为 nnn 饲料包含的各种维他命的量的多少。
输出格式

输出文件只有一行，包括牛必需的最小的饲料种数 ppp；后面有 ppp 个数，表示所选择的饲料编号（按从小到大排列）。

如果有多个解，输出饲料序号最小的（即字典序最小）。
输入输出样例
输入 #1

4
100 200 300 400
3
50  50  50  50
200 300 200 300
900 150 389 399

输出 #1

2 1 3

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤v≤251\le v \le 251≤v≤25，1≤g≤151\le g \le 151≤g≤15。
输入的所有整数在 [1,1000][1,1000][1,1000] 范围内。

USACO 2.1

翻译来自NOCOW

code:
int n,m,vc[30],c[20][30],a[30];
bool v[20];
void dfs(int x,int sum,int num){
    if(sum == num){
        for(int i=1; i<=m; ++i) 
            if(a[i] < vc[i]) 
                return;
        cout << num << ' ';
        for(int i=1; i<=n; ++i) 
            if(v[i]) cout << i << ' ';
        exit(0);
    }
    for(int i=x+1; i<=n; ++i){
        v[i] = 1;
        for(int j=1; j<=m; ++j) 
            a[j] += c[i][j];
        dfs(i,sum+1,num);
        for(int j=1; j<=m; ++j) 
            a[j] -= c[i][j];
        v[i] = 0;
    }
}
int main(){
    cin>>m;
    for(int i=1; i<=m; ++i) cin>>vc[i];
    cin>>n;
    for(int i=1; i<=n; ++i)
        for(int j=1; j<=m; ++j) 
            cin>>c[i][j];
    for(int i=1; i<=n; ++i) 
        dfs(0,0,i);
    return 0;
}

*/

/*
P1464 Function

题目描述

对于一个递归函数w(a,b,c)w(a,b,c)w(a,b,c)

    如果a≤0a \le 0a≤0 or b≤0b \le 0b≤0 or c≤0c \le 0c≤0就返回值111.
    如果a>20a>20a>20 or b>20b>20b>20 or c>20c>20c>20就返回w(20,20,20)w(20,20,20)w(20,20,20)
    如果a<ba<ba<b并且b<cb<cb<c 就返回w(a,b,c?1)+w(a,b?1,c?1)?w(a,b?1,c)w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c)w(a,b,c?1)+w(a,b?1,c?1)?w(a,b?1,c)
    其它的情况就返回w(a?1,b,c)+w(a?1,b?1,c)+w(a?1,b,c?1)?w(a?1,b?1,c?1)w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1)w(a?1,b,c)+w(a?1,b?1,c)+w(a?1,b,c?1)?w(a?1,b?1,c?1)

这是个简单的递归函数，但实现起来可能会有些问题。当a,b,ca,b,ca,b,c均为15时，调用的次数将非常的多。你要想个办法才行.

    absi2011 : 比如 w(30,?1,0)w(30,-1,0)w(30,?1,0)既满足条件1又满足条件2
    这种时候我们就按最上面的条件来算
    所以答案为1

输入格式

会有若干行。

并以?1,?1,?1-1,-1,-1?1,?1,?1结束。

保证输入的数在[?9223372036854775808,9223372036854775807][-9223372036854775808,9223372036854775807][?9223372036854775808,9223372036854775807]之间，并且是整数。
输出格式

输出若干行，每一行格式：

w(a, b, c) = ans

注意空格。
输入输出样例
输入 #1

1 1 1
2 2 2
-1 -1 -1

输出 #1

w(1, 1, 1) = 2
w(2, 2, 2) = 4

说明/提示

记忆化搜索

code:
long long rpt[25][25][25];
long long w(long long a,long long b,long long c){
    if(a<=0||b<=0||c<=0) return 1;
    else if(rpt[a][b][c]!=0) return rpt[a][b][c];
    else if(a>20||b>20||c>20) rpt[a][b][c]=w(20,20,20);
    else if(a<b&&b<c) rpt[a][b][c]=w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c);
    else rpt[a][b][c]=w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1);
    return rpt[a][b][c];
}
int main(){
    long long a,b,c;
    while(scanf("%lld%lld%lld",&a,&b,&c)==3){
        memset(rpt,0,sizeof(rpt));
        if(a==-1&&b==-1&&c==-1) break;
        printf("w(%lld, %lld, %lld) = ",a,b,c);
        if(a>20) a=21;
        if(b>20) b=21;
        if(c>20) c=21;
        printf("%lld\n",w(a,b,c));
    }
    return 0;
}

*/

/*
P1467 [USACO2.2]循环数 Runaround Numbers

题目描述

循环数是那些不包括 000 且没有重复数字的整数（比如 813628136281362）并且还应同时具有一个有趣的性质, 就像这个例子:

如果你从最左边的数字开始（在这个例子中 888）向右数最左边这个数（如果数到了最右边就回到最左边），你会停止在另一个新的数字（如果停在一个相同的数字上，这个数就不是循环数）。

就像：8 1 3 6 28\ 1\ 3\ 6\ 28 1 3 6 2 从最左边接下去数 888 个数字: 1 3 6 2 8 1 3 61\ 3\ 6\ 2\ 8\ 1\ 3\ 61 3 6 2 8 1 3 6 所以下一个数字是 666

重复这样做 (这次从 6 开始数 666 个数字) 并且你会停止在一个新的数字上: 2 8 1 3 6 22\ 8\ 1\ 3\ 6\ 22 8 1 3 6 2, 也就是 222

再这样做 (这次数两个): 8 18\ 18 1

再一次 (这次一个): 333

又一次: 6 2 86\ 2\ 86 2 8

这时你回到了起点,在经过每个数字一次后回到起点的就是循环数。如果你经过每一个数字一次以后没有回到起点, 你的数字不是一个循环数。

给你一个数字 mmm ，找出第一个比 mmm 大的循环数, 输出数据保证结果能用一个无符号长整型数 ∈[0,232) \in [0,2^{32})∈[0,232) 装下。 （追加提醒：循环数每个数位都必须要访问到）
输入格式

仅仅一行, 包括 mmm。
输出格式

仅仅一行，输出第一个比 mmm 大的循环数。
输入输出样例
输入 #1

81361

输出 #1

81362

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤m≤1091\le m \le 10^91≤m≤109。

翻译来自NOCOW

USACO 2.2

code:
int k,t,x,l,b[200],v[200],a[200];
bool pd(){
	int t=1; 
	memset(v,0,sizeof(v));
	for(int i=1;i<=l;++i){
		if(v[a[t]]||!a[t])
            return 0;
		v[a[t]]++; 
		t=(t+a[t])%l; 
		if(t==0)t=l;
	}
	if(t!=1)return 0;
    cout<<k;
	return 1;
}
int main(){
	cin>>k;
	while(1){
		k++;
        t=0;
        x=k;
        while(x>0)
            b[++t]=x%10,x/=10;
        for(int i=1;i<=t;++i)
            a[i]=b[t-i+1];
		l=t;
		if(pd())break;
	}
	return 0;
}

*/

/*
P1478 陶陶摘苹果（升级版）

题目描述

又是一年秋季时，陶陶家的苹果树结了 nnn 个果子。陶陶又跑去摘苹果，这次他有一个 aaa 公分的椅子。当他手够不着时，他会站到椅子上再试试。

这次与 NOIp2005 普及组第一题不同的是：陶陶之前搬凳子，力气只剩下 sss 了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在 s<0s<0s<0 之前最多能摘到多少个苹果。

现在已知 nnn 个苹果到达地上的高度 xix_ixi?，椅子的高度 aaa，陶陶手伸直的最大长度 bbb，陶陶所剩的力气 sss，陶陶摘一个苹果需要的力气 yiy_iyi?，求陶陶最多能摘到多少个苹果。
输入格式

第 111 行：两个数 苹果数 nnn，力气 sss。

第 222 行：两个数 椅子的高度 aaa，陶陶手伸直的最大长度 bbb。

第 333 行~第 3+n?13+n-13+n?1 行：每行两个数 苹果高度 xix_ixi?，摘这个苹果需要的力气 yiy_iyi?。
输出格式

只有一个整数，表示陶陶最多能摘到的苹果数。
输入输出样例
输入 #1

8 15
20 130
120 3
150 2
110 7
180 1
50 8
200 0
140 3
120 2

输出 #1

4

说明/提示

对于 100%100\%100% 的数据，n≤5000n\leq 5000n≤5000, a≤50a\leq 50a≤50, b≤200b\leq 200b≤200, s≤1000s\leq 1000s≤1000, xi≤280x_i\leq 280xi?≤280, yi≤100y_i\leq 100yi?≤100。

code:
struct Apple{
    int x,y;
};
bool cmp(Apple a1,Apple a2){
    return a1.y<a2.y;
}
int main(){
    int n,s,a,b,sum=0;
    cin>>n>>s>>a>>b;
    Apple apple[n];
    for(int i=0;i<n;i++)
        cin>>apple[i].x>>apple[i].y;
    sort(apple,apple+n,cmp);
    for(int i=0;i<n;i++)
        if((apple[i].x<=(a+b))&&(apple[i].y<=s))
            s-=apple[i].y,sum++;
    cout<<sum;
    return  0;
}

*/

/*
P1479 宿舍里的故事之五子棋

题目描述

宿舍里好多好多有趣的事！

7890653今天看到不知何时流行的五子棋，在宿舍里拿个本子，画一些格子，一个棋盘就做好了。

当7890653把目光放到棋上，突发奇想……

在一个 5*5 的棋盘内，放上n颗棋子，其中（5<=n<=25)；

这n颗棋子可以不同的放到任何一个地方---在棋盘内。于是呼，便会有五颗棋子排成一行，或一列，或两条对角线，不同的放法，就会出现多少排五子的排列。

本题你要做的是，给你一个n，你找出不同放法出现的排列(设为k)，如：n=11

有(1是棋子，0是空格）

1 1 1 0 0         1 1 1 1 1
1 1 0 0 0         1 1 1 1 0
1 1 0 0 0         1 1 0 0 0
1 1 0 0 0         0 0 0 0 0
1 1 0 0 0   k=2;  0 0 0 0 0   k=1;

只有这两种k值，（注意k不重复），你要输出的便是k值的和。

也就是1+2=3
输入格式

输入一个数n, 占一行！

其中(5<=n<=25);
输出格式

输出一个k值的总和!（想也不用想k的范围是1<=k<=12的）；
输入输出样例
输入 #1

11

输出 #1

3

code:
int main(){//打表,题目似乎有一点问题(?)
    int a[26]= {0,0,0,0,0,1,1,1,1,3,3,3,6,6,10,10,15,21,21,28,28,35,30,30,27,12},n;
    cin>>n;
    cout<<a[n];
	return 0;
}

*/

/*
P1480 A/B Problem

题目描述

输入两个整数 a,ba,ba,b，输出它们的商。
输入格式

两行，第一行是被除数，第二行是除数。
输出格式

一行，商的整数部分。
输入输出样例
输入 #1

10
2

输出 #1

5

说明/提示

0≤a≤1050000\le a\le 10^{5000}0≤a≤105000，1≤b≤1091\le b\le 10^91≤b≤109。

code:
int main(){//模拟竖式除法
    long long a,b,f,n=0,pd=0;
    string p;
	cin>>p>>b;
	for(int x=0;x<p.size();x++){
        a=p[x]-48;;
        n=n*10+a;;
        f=n/b;;
        n%=b;
        if(pd||f){
            pd=1;
            cout<<f;
        }
    }
	return 0;
}

*/

/*
P1488 肥猫的游戏

题目描述

野猫与胖子，合起来简称肥猫，是一个班的同学，他们也都是数学高手，所以经常在一起讨论数学问题也就不足为奇了。

一次，野猫遇到了一道有趣的几何游戏题目，便拿给胖子看。游戏要求在一个有 nnn 个顶点凸多边形上进行，这个凸多边形的 n?3n-3n?3 条对角线将多边形分成 n?2n-2n?2 个三角形，这 n?3n-3n?3 条对角线在多边形的顶点相交。三角形中的一个被染成黑色，其余是白色。

双方轮流进行游戏，当轮到一方时，他必须沿着画好的对角线，从多边形上切下一个三角形。切下黑色三角形的一方获胜。胖子一看觉得确实很有趣，不如就一起玩玩吧。假设游戏由野猫先开始，那么野猫是否有必胜的策略呢？请写一个程序帮助野猫算一算。
输入格式

第一行为一个整数 nnn，表示多边形的顶点数，多边形的顶点由 000 至 n?1n-1n?1 顺时针标号。

接着的 n?2n-2n?2 行描述组成多边形的三角形。第 i+1i+1i+1 行 (1≤i≤n?2)(1 \leq i \leq n-2)(1≤i≤n?2) 有三个空格分隔的非负整数 aaa 、bbb 、ccc ，它们是第 iii 个三角形的顶点编号。第一个给出的三角形是黑色的。
输出格式

只有一行，倘若野猫有必胜策略，输出 JMcat Win；否则，输出 PZ Win（注意大小写和空格）。
输入输出样例
输入 #1

6
0 1 2
2 4 3
4 2 0
0 5 4

输出 #1

JMcat Win

说明/提示

4≤n≤5×1044 \leq n \leq 5 \times 10^44≤n≤5×104。

如果连接一个多边形中任意两点的线段都完全包含于这个多边形，则称这个多边形为凸多边形。

code:
int main(){//弱数据打表法
    int n;
    cin>>n;
    if(n==5)cout<<"JMcat Win";
    else if(n%2==0)
    cout<<"JMcat Win"; 
    else cout<<"PZ Win";
    return 0;
}

*/

/*
P1496 火烧赤壁

题目背景

曹操平定北方以后，公元 208 年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。

孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。

隆冬的十一月，天气突然回暖，刮起了东南风。

没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。

曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！
题目描述

给定每个起火部分的起点和终点，请你求出燃烧位置的长度之和。
输入格式

第一行一个整数，表示起火的信息条数 nnn。
接下来 nnn 行，每行两个整数 a,ba, ba,b，表示一个着火位置的起点和终点。
输出格式

输出一行一个整数表示答案。
输入输出样例
输入 #1

3
-1 1
5 11
2 9

输出 #1

11

说明/提示
数据规模与约定

对于全部的测试点，保证 1≤n≤2×1041 \leq n \leq 2 \times 10^41≤n≤2×104，?231≤a≤b<231-2^{31} \leq a \leq b \lt 2^{31}?231≤a≤b<231，且答案小于 2312^{31}231。

code:
int main(){//离散化模拟
    int n;cin>>n;
    long long a[20001],b[20001],l=0;
    for(int i=0;i<n;i++)
        cin>>a[i]>>b[i];
    sort(a,a+n);
    sort(b,b+n);
    for(int i=0;i<n;i++){
        l+=b[i]-a[i];
        if(i==n-1)break;
        if(b[i]>a[i+1])l-=b[i]-a[i+1];
    }
    cout<<l;
    return 0;
}

*/

/*
P1497 木牛流马

题目描述

孔明造出了木牛流马

木牛者，方腹曲头，一脚四足，头入领中，舌著于腹。载多而行少，宜可大用，不可小使；特行者数十里，群行者二十里也。曲者为牛头，双者为牛脚，横者为牛领，转者为牛足，覆者为牛背，方者为牛腹，垂者为牛舌，曲者为牛肋，刻者为牛齿，立者为牛角，细者为牛鞅，摄者为牛秋轴。牛仰双辕，人行六尺，牛行四步。载一岁粮，日行二十里，而人不大劳。流马尺寸之数，肋长三尺五寸，广三寸，厚二寸二分，左右同。前轴孔分墨去头四寸，径中二寸。前脚孔分墨二寸，去前轴孔四寸五分，广一寸。前杠孔去前脚孔分墨二寸七分，孔长二寸，广一寸。后轴孔去前杠分墨一尺五分，大小与前同。后脚孔分墨去后轴孔三寸五分，大小与前同。后杠孔去后脚孔分墨二寸七分，后载克去后杠孔分墨四寸五分。前杠长一尺八寸，广二寸，厚一寸五分。后杠与等版方囊二枚，厚八分，长二尺七寸，高一尺六寸五分，广一尺六寸，每枚受米二斛三斗。从上杠孔去肋下七寸，前后同。上杠孔去下杠孔分墨一尺三寸，孔长一寸五分，广七分，八孔同。前后四脚，广二寸，厚一寸五分。形制如象，y长四寸，径面四寸三分。孔径中三脚杠，长二尺一寸，广一寸五分，厚一寸四分，同杠耳。（《三国志・亮集载作木牛流马法》）

可是在现实中它有个缺陷，就是两个不能在同一行或同一列！

孔明兴高采烈的叫庞统来参观，孔明存心想难一难庞统，他把k个木牛流马放在一个大的n*n的格子地板上，并且给他们都染上色，想让庞统帮着算算有多少种不同的合理布局情况？
输入格式

第一行:n,k,h(h为有多少种颜色) n<=20

接下来h行为每种颜色多少个
输出格式

合理布局情况总数
输入输出样例
输入 #1

4 4 1

4

输出 #1

24

说明/提示

不需要高精度,并且孔明规定在格子地板上不能翻转，也就是说如果两种布局在翻转后是一样的仍算两种。

code:
int main(){
    int n,k,h,x;
    cin>>n>>k>>h;
    long long ans1=1,ans2=1,k1=k;
    if(k>n)cout<<0;
    else {
        for(int i=0;i<h;i++){
            cin>>x;
            for(int j=1;j<=x;j++)
                ans1*=j;
        }
        for(int i=n;i>=n-k+1;i--)
            ans2*=i*i;
        cout<<ans2/ans1<<endl;
    }
    return 0;
} 

*/

/*
P1498 南蛮图腾

题目描述

自从到了南蛮之地，孔明不仅把孟获收拾的服服帖帖，而且还发现了不少少数民族的智慧，他发现少数民族的图腾往往有着一种分形的效果，在得到了酋长的传授后，孔明掌握了不少绘图技术，但唯独不会画他们的图腾，于是他找上了你的爷爷的爷爷的爷爷的爷爷……帮忙，作为一个好孙子的孙子的孙子的孙子……你能做到吗？
输入格式

每个数据一个数字，表示图腾的大小（此大小非彼大小） n<=10
输出格式

这个大小的图腾
输入输出样例
输入 #1

2

输出 #1

   /\
  /__\
 /\  /\
/__\/__\

输入 #2

3

输出 #2

       /\
      /__\
     /\  /\
    /__\/__\
   /\      /\
  /__\    /__\
 /\  /\  /\  /\
/__\/__\/__\/__\

code:
int n,a[1024]={1};
int main(){
    cin>>n;
    for(int i=0;i<1<<n;++i){
        for(int j=1;j<(1<<n)-i;++j)
            cout<<" ";
		for(int j=i;j>=0;--j)
            a[j]^=a[j-1];
		if(!(i%2))
            for(int j=0;j<=i;++j)
                cout<<(a[j]?"/\\":"  ");
		else 
            for(int j=0;j<=i;j+=2)
                cout<<(a[j]?"/__\\":"    ");
		cout<<endl;
    }
    return 0;
} 

*/

/*
P1506 拯救oibh总部

题目背景

oibh总部突然被水淹没了！现在需要你的救援……
题目描述

oibh被突来的洪水淹没了>.<还好oibh总部有在某些重要的地方起一些围墙，用*号表示，而一个封闭的*号区域洪水是进不去的……现在给出oibh的围墙建设图，问oibh总部没被淹到的重要区域（由"0"表示）有多少。
输入格式

第一行是两个数，x和y（x,y<=500）

第二行及以下是一个由*和0组成的x*y的图。
输出格式

输出没被水淹没的oibh总部的“0”的数量。
输入输出样例
输入 #1

样例输入1
4 5
00000
00*00
0*0*0
00*00

样例输入2
5 5
*****
*0*0*
**0**
*0*0*
*****

输出 #1

样例输出1
1

样例输出2
5

code:
int n,m,s=0,kx[5]={0,1,-1,0,0},ky[5]={0,0,0,1,-1},a[501][501];
void search(int x,int y){
    a[x][y]=1;
    for(int i=1;i<=4;i++){
        int x0=x+kx[i],y0=y+ky[i];
        if(x0>0&&x0<=n&&y0>0&&y0<=m&&a[x0][y0]==0)search(x0,y0);
    }
}
int main(){
    cin>>n>>m;
    char e;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            cin>>e;
            if(e=='*')a[i][j]=1;
            else a[i][j]=0;
        }
    for(int i=1;i<=n;i++){
        if(a[i][1]==0)search(i,1);
        if(a[i][m]==0)search(i,m);
    }
    for(int i=1;i<=m;i++){
        if(a[1][i]==0)search(1,i);
        if(a[n][i]==0)search(n,i);
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            if(a[i][j]==0)s++;
    cout<<s;
    return 0;
}

*/

/*
P1507 NASA的食物计划

题目背景

NASA(美国航空航天局)因为航天飞机的隔热瓦等其他安全技术问题一直大伤脑筋,因此在各方压力下终止了航天飞机的历史,但是此类事情会不会在以后发生，谁也无法保证,在遇到这类航天问题时,解决方法也许只能让航天员出仓维修,但是多次的维修会消耗航天员大量的能量,因此NASA便想设计一种食品方案,让体积和承重有限的条件下多装载一些高卡路里的食物.
题目描述

航天飞机的体积有限,当然如果载过重的物品,燃料会浪费很多钱,每件食品都有各自的体积、质量以及所含卡路里,在告诉你体积和质量的最大值的情况下,请输出能达到的食品方案所含卡路里的最大值,当然每个食品只能使用一次.
输入格式

第一行 两个数 体积最大值(<400)和质量最大值(<400)

第二行 一个数 食品总数N(<50).

第三行－第3+N行

每行三个数 体积(<400) 质量(<400) 所含卡路里(<500)
输出格式

一个数 所能达到的最大卡路里(int范围内)
输入输出样例
输入 #1

320 350
4
160 40 120
80 110 240
220 70 310
40 400 220

输出 #1

550

说明/提示

很简单的背包...

code:
int a[51],b[51],c[51],f[501][501];
int main(){
    int i,j,l,m,n,k;
    cin>>m>>n>>k;
    for(i=1;i<=k;i++)
        cin>>a[i]>>b[i]>>c[i];
    for(i=1;i<=n;i++)
        for(j=m;j>=a[i];j--)
            for(l=n;l>=b[i];l--)
                f[j][l]=max(f[j][l],f[j-a[i]][l-b[i]]+c[i]);
    cout<<f[m][n];
    return 0;
}

*/

/*
P1510 精卫填海

题目描述

【版权说明】

本题为改编题。

【问题描述】

发鸠之山，其上多柘木。有鸟焉，其状如乌，文首，白喙，赤足，名曰精卫，其名自。是炎帝之少女，名曰女娃。女娃游于东海，溺而不返，故为精卫。常衔西山之木石，以堙于东海。――《山海经》

精卫终于快把东海填平了！只剩下了最后的一小片区域了。同时，西山上的木石也已经不多了。精卫能把东海填平吗？

事实上，东海未填平的区域还需要至少体积为v的木石才可以填平，而西山上的木石还剩下n块，每块的体积和把它衔到东海需要的体力分别为k和m。精卫已经填海填了这么长时间了，她也很累了，她还剩下的体力为c。
输入格式

输入文件的第一行是三个整数：v、n、c。

从第二行到第n+1行分别为每块木石的体积和把它衔到东海需要的体力。
输出格式

输出文件只有一行，如果精卫能把东海填平，则输出她把东海填平后剩下的最大的体力，否则输出’Impossible’（不带引号）。
输入输出样例
输入 #1

100 2 10
50 5
50 5

输出 #1

0

输入 #2

10 2 1
50 5
10 2

输出 #2

Impossible

说明/提示

【数据范围】

对于20%的数据，0<n<=50。

对于50%的数据，0<n<=1000。

对于100%的数据，0<n<=10000，所有读入的数均属于[0,10000]，最后结果<=c。

code:
int v,n,c,tj[10002],tl[10002],f[10002];
int main(){
	cin>>v>>n>>c;
	for(int i=1;i<=n;i++)
        cin>>tj[i]>>tl[i];
	for(int i=1;i<=n;i++)
		for(int j=c;j>=tl[i];j--)
			f[j]=max(f[j],f[j-tl[i]]+tj[i]);
	if(f[c]<v) cout<<"Impossible";
	else{ 
		int i=c;
		while(f[i]>=v) 
            i--; 
		cout<<c-(i+1);
	}
	return 0;
}

*/

/*
P1513 绕钉子的长绳子

题目背景

平面上有N个圆柱形的大钉子，半径都为R,所有钉子组成一个凸多边形。

现在你要用一条绳子把这些钉子围起来，绳子直径忽略不计。
题目描述

求出绳子的长度
输入格式

第1行两个数：整数N(1<=N<=100)和实数R。

接下来N行按逆时针顺序给出N个钉子中心的坐标

坐标的绝对值不超过100。
输出格式

一个数，绳子的长度，精确到小数点后2位。
输入输出样例
输入 #1

4 1

0.0 0.0

2.0 0.0

2.0 2.0

0.0 2.0

输出 #1

14.28

说明/提示

如果你用比较复杂的方法AC了，请想一想有没有更加简便的方法。

本题来自URAL1020，翻译来自NOCOW。

code:
double a[103],r,s=0,b[103];
int n;
int main(){
    cin>>n>>r;
    for(int i=1;i<=n;i++)
        cin>>a[i]>>b[i];
    a[n+1]=a[1];
    b[n+1]=b[1];
    for(int i=1;i<=n;i++)
        s+=sqrt((a[i]-a[i+1])*(a[i]-a[i+1])+(b[i]-b[i+1])*(b[i]-b[i+1]));
    printf("%.2lf",s+6.28318*r);
    return 0;
}

*/

/*
P1515 旅行

题目描述

你要进行一个行程为7000KM的旅行，现在沿途有些汽车旅馆，为了安全起见，每天晚上都不开车，住在汽车旅馆，你手里现在已经有一个旅馆列表，用离起点的距离来标识，如下：

0， 990， 1010， 1970， 2030， 2940， 3060

3930， 4060， 4970， 5030， 5990， 6010， 7000

但在出发之前可能还要增加一些旅馆。

现在旅行社为了节约成本，要求每天至少行驶A公里，国家旅行社为了安全起见，要求每天最多只能行驶B公里。

你想知道一共有多少种旅行方案。
输入格式

第一行输入A，第二行输入B，第三行输入N（0≤N≤20），表示在出发之前又新增N个汽车旅馆；接下来N行，每行一个整数m，表示旅馆离起点的距离（0<m<7000）。注意：没有任意两个旅馆在同一位置。
输出格式

输出一共有多少种旅行方案。
输入输出样例
输入 #1

500
1500
0

输出 #1

64

code:
int main(){//类斐波那契数列
    int a,b,n,ans[40]={0},r[40]={0,990,1010,1970,2030,2940,3060,3930,4060,4970,5030,5990,6010,7000};
	scanf("%d %d %d",&a,&b,&n);
	for (int i=14;i<14+n;i++) cin>>r[i];
	sort(r,r+14+n); 
	ans[0]=1;
	for (int i=1;i<14+n;i++)
		for (int j=0;j<i;j++)
			if (r[i]-r[j]>=a&&r[i]-r[j]<=b)
				ans[i]+=ans[j];
	cout<<ans[13+n]<<endl;
	return 0;
}

*/

/*
P1540 [NOIP2010 提高组] 机器翻译

题目背景

小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。
题目描述

这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。

假设内存中有 MMM 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M?1M-1M?1，软件会将新单词存入一个未使用的内存单元；若内存中已存入 MMM 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。

假设一篇英语文章的长度为 NNN 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。
输入格式

共 222 行。每行中两个数之间用一个空格隔开。

第一行为两个正整数 M,NM,NM,N，代表内存容量和文章的长度。

第二行为 NNN 个非负整数，按照文章的顺序，每个数（大小不超过 100010001000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。
输出格式

一个整数，为软件需要查词典的次数。
输入输出样例
输入 #1

3 7
1 2 1 5 4 4 1

输出 #1

5

说明/提示
样例解释

整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：

    1：查找单词 1 并调入内存。
    1 2：查找单词 2 并调入内存。
    1 2：在内存中找到单词 1。
    1 2 5：查找单词 5 并调入内存。
    2 5 4：查找单词 4 并调入内存替代单词 1。
    2 5 4：在内存中找到单词 4。
    5 4 1：查找单词 1 并调入内存替代单词 2。

共计查了 555 次词典。
数据范围

    对于 10%10\%10% 的数据有 M=1M=1M=1，N≤5N \leq 5N≤5；
    对于 100%100\%100% 的数据有 1≤M≤1001 \leq M \leq 1001≤M≤100，1≤N≤10001 \leq N \leq 10001≤N≤1000。

code:
int n,m,x,ans,l,r,a[1005],b[1005];
int main(){
    cin>>m>>n;
    l=0;r=0;
    for (int i=1;i<=n;i++){
        scanf("%d",&x);
        if (a[x]==0){
            ans++;
            r++;
            b[r]=x;
            a[x]=1;
            if (r>m)l++,a[b[l]]=0;
        }
    }
    cout<<ans;
    return 0;
}

*/

/*
P1551 亲戚

题目背景

若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。
题目描述

规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。
输入格式

第一行：三个整数n,m,p，（n<=5000,m<=5000,p<=5000），分别表示有n个人，m个亲戚关系，询问p对亲戚关系。

以下m行：每行两个数Mi，Mj，1<=Mi，Mj<=N，表示Mi和Mj具有亲戚关系。

接下来p行：每行两个数Pi，Pj，询问Pi和Pj是否具有亲戚关系。
输出格式

P行，每行一个’Yes’或’No’。表示第i个询问的答案为“具有”或“不具有”亲戚关系。
输入输出样例
输入 #1

6 5 3
1 2
1 5
3 4
5 2
1 3
1 4
2 3
5 6

输出 #1

Yes
Yes
No

说明/提示

非常简单的并查集入门题哦！！！

code:
int n,m,p,x,y,fa[10009];
int find(int x){
	if(fa[x]==x)return x;
	return fa[x]=find(fa[x]);
}
int main(){//并查集
	cin>>n>>m>>p;
	for(int i=1;i<=n;i++)
        fa[i]=i;
	for(int i=1;i<=m;i++){
		cin>>x>>y;
	    fa[find(x)]=find(y);//注意:不是fa[x]
	}
	for(int i=1;i<=p;i++){
		cin>>x>>y;
		if(find(x)==find(y)) cout<<"Yes"<<endl;
		else cout<<"No"<<endl;
	}
	return 0;
}

*/

/*
P1553 数字反转（升级版）

题目背景
以下为原题面，仅供参考

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与NOIp2011普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为0（除非小数部分除了0没有别的数，那么只保留1个0）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为0），本次没有负数。
题目描述

给定一个数，请将该数各个位上数字反转得到一个新数。

这次与NOIp2011普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。

    整数反转是将所有数位对调。

    小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。

    分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。

    百分数的分子一定是整数，百分数只改变数字部分。

输入格式

一个数 sss
输出格式

一个数，即 sss 的反转数
输入输出样例
输入 #1

5087462

输出 #1

2647805

输入 #2

600.084

输出 #2

6.48

输入 #3

700/27

输出 #3

7/72

输入 #4

8670%

输出 #4

768%

说明/提示

所有数据：25%s是整数，不大于20位

25%s是小数，整数部分和小数部分均不大于10位

25%s是分数，分子和分母均不大于10位

25%s是百分数，分子不大于19位

（20个数据）

数据保证：

    对于整数翻转而言，整数原数和整数新数满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数和原来的数字的最高位数字不应为零。

    对于小数翻转而言，其小数点前面部分同上，小数点后面部分的形式，保证满足小数的常见形式，也就是末尾没有多余的 000（小数部分除了 000 没有别的数，那么只保留 111 个 000。若反转之后末尾数字出现 000，请省略多余的 000）

    对于分数翻转而言，分数不约分，分子和分母都不是小数。输入的分母不为0。与整数翻转相关规定见上。

    对于百分数翻转而言，见与整数翻转相关内容。

数据不存在负数。

code:
int main(){
    string s;cin>>s;
    char p=0;
    int cnt=0; 
    for(int i=0;i<s.size();i++)
        if(s[i]>='0'&&s[i]<='9') cnt++;//第一个数长度
        else{//跳出符号
        p=s[i];
        break;
        }
    int x=cnt;////符号位置
    cnt--;
    while(s[cnt]=='0'&&cnt>0)cnt--;//去多余前0
    for(int i=cnt;i>=0;i--)cout<<s[i];//输出第一个数
    if(p==0) return 0;//没有符号->结束
    else
        if(p=='%') {cout<<p;return 0;} //百分号->结束
        else cout<<p; 
    int m=s.size()-1;
    while(s[x+1]=='0'&&x<m-1) x++;//去末尾0
    while(s[m]=='0'&&m>x+1) m--;//去多余前0
    for(int i=m;i>x;i--)cout<<s[i];//输出第二个数
    return 0; 
}

*/

/*
P1563 [NOIP2016 提高组] 玩具谜题

题目描述

小南有一套可爱的玩具小人, 它们各有不同的职业。

有一天, 这些玩具小人把小南的眼镜藏了起来。 小南发现玩具小人们围成了一个圈,它们有的面朝圈内,有的面朝圈外。如下图:

这时singersingersinger告诉小南一个谜}: “眼镜藏在我左数第3个玩具小人的右数第111个玩具小人的左数第222个玩具小人那里。 ”

小南发现, 这个谜题中玩具小人的朝向非常关键, 因为朝内和朝外的玩具小人的左右方向是相反的: 面朝圈内的玩具小人, 它的左边是顺时针方向, 右边是逆时针方向; 而面向圈外的玩具小人, 它的左边是逆时针方向, 右边是顺时针方向。

小南一边艰难地辨认着玩具小人, 一边数着:

singersingersinger朝内, 左数第333个是archerarcherarcher。

archerarcherarcher朝外,右数第111个是thinkerthinkerthinker。

thinkerthinkerthinker朝外, 左数第222个是writewritewriter。

所以眼镜藏在writerwriterwriter这里!

虽然成功找回了眼镜, 但小南并没有放心。 如果下次有更多的玩具小人藏他的眼镜, 或是谜}的长度更长, 他可能就无法找到眼镜了 。 所以小南希望你写程序帮他解决类似的谜}。 这样的谜}具体可以描述为:

有 nnn个玩具小人围成一圈, 已知它们的职业和朝向。现在第111个玩具小人告诉小南一个包含mmm条指令的谜}, 其中第 zzz条指令形如“左数/右数第s ss,个玩具小人”。 你需要输出依次数完这些指令后,到达的玩具小人的职业。
输入格式

输入的第一行包含两个正整数 n,mn,mn,m，表示玩具小人的个数和指令的条数。

接下来 nnn 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 000 表示朝向圈内，111 表示朝向圈外。 保证不会出现其他的数。字符串长度不超过 101010 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。

接下来 mmm 行，其中第 iii 行包含两个整数 ai,sia_i,s_iai?,si?，表示第 iii 条指令。若 ai=0a_i=0ai?=0，表示向左数 sis_isi? 个人；若 ai=1a_i=1ai?=1，表示向右数 sis_isi? 个人。 保证 aia_iai? 不会出现其他的数，1≤si<n1 \le s_i < n1≤si?<n。
输出格式

输出一个字符串，表示从第一个读入的小人开始，依次数完 mmm 条指令后到达的小人的职业。
输入输出样例
输入 #1

7 3
0 singer
0 reader
0 mengbier 
1 thinker
1 archer
0 writer
1 mogician 
0 3
1 1
0 2

输出 #1

writer

输入 #2

10 10
1 C
0 r
0 P
1 d
1 e
1 m
1 t
1 y
1 u
0 V
1 7
1 1
1 4
0 5
0 3
0 1
1 6
1 2
0 8
0 4

输出 #2

y

说明/提示

【样例1说明】

这组数据就是【题目描述】 中提到的例子。

【子任务】

子任务会给出部分测试数据的特点。 如果你在解决题目中遇到了困难, 可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表:

其中一些简写的列意义如下:

? 全朝内: 若为“√”, 表示该测试点保证所有的玩具小人都朝向圈内;

全左数:若为“√”,表示该测试点保证所有的指令都向左数,即对任意的

1≤z≤m,ai=01≤z≤m, a_i=01≤z≤m,ai?=0;

s=1s= 1s=1:若为“√”,表示该测试点保证所有的指令都只数1个,即对任意的

1≤z≤m,si=11≤z≤m,s_i=11≤z≤m,si?=1;

职业长度为111 :若为“√”,表示该测试点保证所有玩具小人的职业一定是一个

长度为111的字符串。

code:
int main(){
    int n,m,a[100001],k=1,i,j,x,y; 
    char c[100001][11]; 
    cin>>n>>m;
    for(i=1;i<=n;i++)
        cin>>a[i]>>c[i]; 
    for(j=1;j<=m;j++){
        cin>>x>>y;
        if(a[k]==0){
            if(x==0)k=k-y;
            else k=k+y;
        }
        else
            if(x==0)k=k+y;
            else k=k-y;
        if(k>n)k-=n; 
        if(k<=0)k+=n;
    }
    printf("%s",c[k]); 
}

*/

/*
P1569 Generic Cow Protests

题目描述

约翰家的 nnn 头奶牛聚集在一起，排成一列，正在进行一项抗议活动。第 iii 头奶牛的理智度为 aia_iai?。
约翰希望奶牛在抗议时保持理性，为此，他打算将所有的奶牛隔离成若干个小组，每个小组内的奶牛的理智度总和都要不小于零。
由于奶牛是按直线排列的，所以一个小组内的奶牛位置必须是连续的。请帮助约翰计算一下，最多分成几组。
输入格式

第一行一个正整数 nnn，表示牛的数目。
接下来 nnn 行，每行一个整数，表示每个牛的理智度。
输出格式

若存在合法分组方案，输出一行一个整数表示答案；否则输出 Impossible。
输入输出样例
输入 #1

4
2
3
-3
1

输出 #1

3

说明/提示

【数据规模和约定】
对于 30%30\%30% 的数据，1≤n≤201\le n \le 201≤n≤20；
对于 100%100\%100% 的数据，1≤n≤10001\le n \le 10001≤n≤1000，OaiO≤105|a_i| \le 10^5Oai?O≤105。

code:
int a[100001],dp[100001];
int main(){
	int n,i,j,sumn=0;
	cin>>n;
	for(i=1;i<=n;i++){	
        cin>>a[i];
		a[i]+=a[i-1];
		if(a[i]>=0) 
            dp[i]=1;
    }
	for(i=1;i<=n;i++)
		for(j=1;j<i;j++)
			if(dp[j]>0&&a[i]-a[j]>=0) 
                dp[i]=max(dp[i],dp[j]+1);
	if(dp[n]==0) cout<<"Impossible";
	else cout<<dp[n];cout<<endl;
	return 0;
}

*/

/*
P1571 眼红的Medusa

题目描述

虽然 Miss Medusa 到了北京，领了科技创新奖，但是她还是觉得不满意。原因是：他发现很多人都和她一样获了科技创新奖，特别是其中的某些人，还获得了另一个奖项――特殊贡献奖。而越多的人获得了两个奖项，Miss Medusa就会越眼红。于是她决定统计有哪些人获得了两个奖项，来知道自己有多眼红。
输入格式

第一行两个整数 n,mn, mn,m，表示有 nnn 个人获得科技创新奖，mmm 个人获得特殊贡献奖。

第二行 nnn 个正整数，表示获得科技创新奖的人的编号。

第三行 mmm 个正整数，表示获得特殊贡献奖的人的编号。
输出格式

输出一行，为获得两个奖项的人的编号，按在科技创新奖获奖名单中的先后次序输出。
输入输出样例
输入 #1

4 3
2 15 6 8
8 9 2

输出 #1

2 8

说明/提示

对于 60%60\%60% 的数据，1≤n,m≤10001 \leq n, m \leq 10001≤n,m≤1000，获得奖项的人的编号 <2×109\lt 2 \times 10^9<2×109；

对于 100%100\%100% 的数据，1≤n,m≤1051 \leq n, m \leq 10^51≤n,m≤105，获得奖项的人的编号 <2×109\lt 2 \times 10^9<2×109。

输入数据保证第二行任意两个数不同，第三行任意两个数不同。

code:
int n,m;
map<int,bool> v;
int a[101000],b[101000];
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;i++) {scanf("%d",&a[i]);}
	for(int i=1;i<=m;i++) {scanf("%d",&b[i]);v[b[i]]=true;}
	for(int i=1;i<=n;i++) if(v[a[i]]) cout<<a[i]<<" ";
    return 0;
}

*/

/*
P1579 哥德巴赫猜想（升级版）

题目背景

1742年6月7日哥德巴赫写信给当时的大数学家欧拉，正式提出了以下的猜想：任何一个大于9的奇数都可以表示成3个质数之和。质数是指除了1和本身之外没有其他约数的数，如2和11都是质数，而6不是质数，因为6除了约数1和6之外还有约数2和3。需要特别说明的是1不是质数。

这就是哥德巴赫猜想。欧拉在回信中说，他相信这个猜想是正确的，但他不能证明。

从此，这道数学难题引起了几乎所有数学家的注意。哥德巴赫猜想由此成为数学皇冠上一颗可望不可及的“明珠”。
题目描述

现在请你编一个程序验证哥德巴赫猜想。

先给出一个奇数n，要求输出3个质数，这3个质数之和等于输入的奇数。
输入格式

仅有一行，包含一个正奇数n，其中9<n<20000
输出格式

仅有一行，输出3个质数，这3个质数之和等于输入的奇数。相邻两个质数之间用一个空格隔开，最后一个质数后面没有空格。如果表示方法不唯一，请输出第一个质数最小的方案，如果第一个质数最小的方案不唯一，请输出第一个质数最小的同时，第二个质数最小的方案。
输入输出样例
输入 #1

2009

输出 #1

3 3 2003

code:
int check(int x){
	for (int i=2;i*i<=x;i++)
	    if(x%i==0) 
            return 0;
	return 1;
}
int main(){
	int n;
	cin>>n;
	if(check(n-4)) {
        cout<<"2 2 "<<n-4;
        return 0;
    }
	for (int i=3;i<n;i++)
        if((i%2)!=0&&check(i))
            for (int j=i;j<n;j++)
                if((j%2)!=0&&check(j))
                    if(check(n-i-j)) {
                        cout<<i<<" "<<j<<" "<<n-i-j;
                        return 0;
                    }
}

*/

/*
P1581 A+B Problem（升级版）

题目背景

小明这在写作业，其中有一道A+B Problem ，他想啊想啊想，就是想不出来，于是就找到了会编程的你......
题目描述

这里的A＋B是很奇特的。它是按质数的顺序来进位的。例如：1,0+2,1＝1,0,1（用，来分隔每一位）。个位是2进制，十位是3进制，百位是5进制，千位是7进制，万位是11进制……两个加数的最高位是万位（万位可能有两位）。
输入格式

输入一个形如1,0+2,1字符串s。
输出格式

输出相加后的结果。
输入输出样例
输入 #1

1,0+2,1

输出 #1

1,0,1

code:#include<bits/stdc++.h>
using namespace std;
int c[7]={0,2,3,5,7,11,13},a[7];
int main(){
    string s;cin>>s;
	int n=s.size(),u=1,t=0;
	for(int i=n-1;i>=0;i--){ 
		if(s[i]>='0'&&s[i]<='9'){
			if(s[i-1]>='0'&&s[i-1]<='9'){
				a[u]=a[u]+(s[i-1]-48)*10+(s[i]-48);
                i--;
            }
			else a[u]=a[u]+s[i]-48;
			u++;
		}
		if(s[i]=='+')u=1;
	}
	for(int i=1;i<=5;i++){
        a[i+1]=a[i+1]+(a[i]/c[i]);
        a[i]=a[i]%c[i];
    }
	for(int i=6;i>=1;i--)
        if(a[i]!=0){
            t=i;
            break;
        }
	for(int i=t;i>=2;i--)
        cout<<a[i]<<",";
	cout<<a[1];
	return 0;
}

*/

/*
P1583 魔法照片

题目描述

一共有n（n≤20000）个人（以1--n编号）向佳佳要照片，而佳佳只能把照片给其中的k个人。佳佳按照与他们的关系好坏的程度给每个人赋予了一个初始权值W[i]。然后将初始权值从大到小进行排序，每人就有了一个序号D[i]（取值同样是1--n）。按照这个序号对10取模的值将这些人分为10类。也就是说定义每个人的类别序号C[i]的值为(D[i]-1) mod 10 +1，显然类别序号的取值为1--10。第i类的人将会额外得到E[i]的权值。你需要做的就是求出加上额外权值以后，最终的权值最大的k个人，并输出他们的编号。在排序中，如果两人的W[i]相同，编号小的优先。
输入格式

第一行输入用空格隔开的两个整数，分别是n和k。

第二行给出了10个正整数，分别是E[1]到E[10]。

第三行给出了n个正整数，第i个数表示编号为i的人的权值W[i]。
输出格式

只需输出一行用空格隔开的k个整数，分别表示最终的W[i]从高到低的人的编号。
输入输出样例
输入 #1

10 10
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20

输出 #1

10 9 8 7 6 5 4 3 2 1

code:
struct person{
    int w,num,d;
}p[20001];
bool cmp(const person &a,const person &b){
    if(a.w!=b.w)return a.w>b.w;
    return a.num<b.num;
}
int main(){//快排 计算 快排
    int e[10],n,k;
    cin>>n>>k;
    for(int i=0;i<10;i++)
        cin>>e[i];
    for(int i=0;i<n;i++){
        cin>>p[i].w;
        p[i].num=i+1;
    }
    sort(p,p+n,cmp);
    for(int i=0;i<n;i++){
        p[i].d=i%10;
        p[i].w+=e[p[i].d];
    }
    sort(p,p+n,cmp);
    for(int i=0;i<k;i++)
        cout<<p[i].num<<" ";
}

*/

/*
P1589 泥泞路

题目描述

暴雨过后，FJ的农场到镇上的公路上有一些泥泞路，他有若干块长度为L的木板可以铺在这些泥泞路上，问他至少需要多少块木板，才能把所有的泥泞路覆盖住。
输入格式

第一行为正整数n(≤10000)和L(≤10000)，分别表示有多少段泥泞路和木板的长度；接下来n行，每一行两个整数s和e(s≤e≤10^9)，表示每一段泥泞路的起点和终点。
输出格式

仅一个正整数，表示木板数。
输入输出样例
输入 #1

3 3
1 6
13 17
8 12

输出 #1

5

code:
int main(){//贪心
    int n,l,d,h=0;
    cin>>n>>l;
    int s[n],e[n];
    for(int i=0;i<n;i++)
        cin>>s[i]>>e[i];
    sort(s,s+n);sort(e,e+n);//数论思维
    d=s[0];
    for(int i=0;i<n;i++){
        while(d<e[i]){
            d+=l;
            h++;
        }
        d=max(d,s[i+1]);
    }
    cout<<h;
    return 0;
}

*/

/*
P1591 阶乘数码

题目描述

求 n!n!n! 中某个数码出现的次数。
输入格式

第一行为 t(t≤10)t(t \leq 10)t(t≤10)，表示数据组数。接下来 ttt 行，每行一个正整数 n(n≤1000)n(n \leq 1000)n(n≤1000) 和数码 aaa。
输出格式

对于每组数据，输出一个整数，表示 n!n!n! 中 aaa 出现的次数。
输入输出样例
输入 #1

2
5 2
7 0

输出 #1

1
2

code:
int a[3000];
int main(){//高精
    int t,n,m;cin>>t;
    while(t--){
        cin>>n>>m;
        for(int i=0;i<1000;i++)
            a[i]=0;
        a[1]=1;//注意初始化为1
        int p=1,jw=0,j;
        for(int i=2;i<=n;i++){
            jw=0;//进位初始化
            for(j=1;j<=p;j++){
                a[j]=a[j]*i+jw;
                jw=a[j]/10;
                a[j]=a[j]%10;
            }
            while(jw){//清除进位
                a[j]=jw%10;
                jw=jw/10;
                j++;
            }
            p=j-1;//跟进长度
        }
        long long sum=0;
        for(int i=p;i>=1;i--)
            if(a[i]==m)
                sum++;
        cout<<sum<<endl;
    }
    return 0;
}

*/

/*
P1595 信封问题

题目描述

某人写了n封信和n个信封，如果所有的信都装错了信封。求所有信都装错信封共有多少种不同情况。
输入格式

一个信封数n（n<=20）
输出格式

一个整数，代表有多少种情况。
输入输出样例
输入 #1

2

输出 #1

1

输入 #2

3

输出 #2

2

code:
int main(){//差排递推公式
    int n;cin>>n;
    long long f[n+1];
    f[0]=1;
    f[1]=0;
    for(int i=2;i<=n;i++)
        f[i]=(i-1)*(f[i-1]+f[i-2]);
    cout<<f[n];
    return 0;
}

*/

/*
P1596 [USACO10OCT]Lake Counting S

题目描述

Due to recent rains, water has pooled in various places in Farmer John's field, which is represented by a rectangle of N x M (1 <= N <= 100; 1 <= M <= 100) squares. Each square contains either water ('W') or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John's field, determine how many ponds he has.

由于近期的降雨，雨水汇集在农民约翰的田地不同的地方。我们用一个NxM(1<=N<=100;1<=M<=100)网格图表示。每个网格中有水('W') 或是旱地('.')。一个网格与其周围的八个网格相连，而一组相连的网格视为一个水坑。约翰想弄清楚他的田地已经形成了多少水坑。给出约翰田地的示意图，确定当中有多少水坑。
输入格式

Line 1: Two space-separated integers: N and M * Lines 2..N+1: M characters per line representing one row of Farmer John's field. Each character is either 'W' or '.'. The characters do not have spaces between them.

第1行：两个空格隔开的整数：N 和 M 第2行到第N+1行：每行M个字符，每个字符是'W'或'.'，它们表示网格图中的一排。字符之间没有空格。
输出格式

Line 1: The number of ponds in Farmer John's field.

一行：水坑的数量
输入输出样例
输入 #1

10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.

输出 #1

3

说明/提示

OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left, and one along the right side.

code:
char a[101][101];
int ans,n,m;
void dfs(int x,int y){
    a[x][y]='.';
    for(int i=-1;i<=1;i++)
        for(int j=-1;j<=1;j++)
            if(a[x+i][y+j]=='W')//其实需要注意越界问题 x+i>=0&&x+i<=n&&y+j>=0&&y+j<m&&
                dfs(x+i,y+j);
    return;
} 
int main(){//深度搜索
    scanf("%d%d",&n,&m);
    for(int i=0;i<=n;i++)
    	scanf("%s",a[i]);
    for(int i=0;i<=n;i++)
        for(int j=0;j<m;j++)
            if(a[i][j]=='W')
                dfs(i,j),ans++;
    cout<<ans;
    return 0;
}

*/

/*
P1598 垂直柱状图

题目描述

写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过100个字符），然后用柱状图输出每个字符在输入文件中出现的次数。严格地按照输出样例来安排你的输出格式。
输入格式

四行字符，由大写字母组成，每行不超过100个字符
输出格式

由若干行组成，前几行由空格和星号组成，最后一行则是由空格和字母组成的。在任何一行末尾不要打印不需要的多余空格。不要打印任何空行。
输入输出样例
输入 #1

THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG.
THIS IS AN EXAMPLE TO TEST FOR YOUR
HISTOGRAM PROGRAM.
HELLO!

输出 #1

                            *
                            *
        *                   *
        *                   *     *   *
        *                   *     *   *
*       *     *             *     *   *
*       *     * *     * *   *     * * *
*       *   * * *     * *   * *   * * * *
*     * * * * * *     * * * * *   * * * *     * *
* * * * * * * * * * * * * * * * * * * * * * * * * *
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

说明/提示

每行输出后面不允许出现多余的空格。

code:
int main(){
    int sum[26]={0},maxsum=0;
    string c;
    while(cin>>c){
        for(int i=0;i<c.length();i++)
            sum[c[i]-'A']++;
    }
    for(int i=0;i<26;i++)
        maxsum=max(maxsum,sum[i]);
    for(int i=maxsum;i>0;i--){
        for(int j=0;j<26;j++){
            if(sum[j]>=i)cout<<"* ";
            else cout<<"  ";
        }
        cout<<endl;
    }
    for(int j=0;j<26;j++){
        cout<<char('A'+j)<<" ";
    }
}

*/

/*
P1599 结算日

题目背景

借债还债
题目描述

“不放债不借债”，贝西多么希望自己可以遵循这个忠告。她已经和她的 N(1≤N≤100,000)N(1 \leq N \leq 100,000)N(1≤N≤100,000) 个朋友有了债务关系，或者借债了，或者放债了。她的 NNN 个朋友依次标号为 1…N1\dots N1…N。 结算日终于来临了。她知道，朋友欠她的钱比她欠朋友的钱多。她的朋友们分布在一条直线上，第 iii 头奶牛站的位置距离谷仓 iii 米。贝西打算沿着这条直线行走，从欠她钱的奶牛手里收钱回来，并且还钱给她欠钱的奶牛。 当她沿直线移动的时候，她可以要求任何欠她钱的奶牛还全部的钱。当她有足够的钱可以还清她的某个债，就可以把钱给对应的奶牛还清她的债。奶牛 iii 欠贝西 DiD_iDi? 元 (?1,000≤Di≤1,000,Di≠0)(-1,000 \leq D_i \leq 1,000,D_i \neq 0)(?1,000≤Di?≤1,000,Di?=0)，负数表示贝西欠奶牛 iii 钱。 贝西从谷仓出发，位置为 000，初始贝西没有钱。贝西收回她的所有借债，并且还清她的欠债所需行走的最短距离是多少？注意：她必须在最后一头奶牛所在的位置，完成她的行走。
输入格式

第一行，一个整数 NNN

接下来第 2…N+12 \dots N+12…N+1 行，第 i+1i+1i+1 行包含一个整数 DiD_iDi?
输出格式

一个整数，贝西收回借债并且还清欠债，所需要行走的最短距离（单位为米）
输入输出样例
输入 #1

5
100
-200
250
-200
200

输出 #1

9

说明/提示

输入解释：

333 头奶牛欠贝西钱；她欠 222 头奶牛钱。当她完成结算，她将有 150150150 元。

输出解释：

谷仓  100  -200  250 -200  200
 |     |     |    |    |    |
 ***>**+**>*****>**+
                   *            < 贝西有 350元
             -**<***
             *                  < 贝西有 150元
             ***>****>****>**+
                             *  < 贝西有 350
                       -**<***
                       *     
                       ***>***  < 贝西结束她的行走，有 150元

code:
int main(){
    int n,m,l,sum=0,step=0;cin>>n;
    bool flag=false;
    for(int i=0;i<n;i++){
        cin>>m;
        sum+=m;
        step++;
        if((sum>=0)&&flag)flag=false,step+=(i-l)*2;
        if((sum<0)&&!flag)flag=true,l=i;
    }
    cout<<step;
}

*/

/*
P1601 A+B Problem（高精）

题目描述

高精度加法，相当于a+b problem，不用考虑负数.
输入格式

分两行输入。a,b≤10500a,b \leq 10^{500}a,b≤10500
输出格式

输出只有一行，代表a+ba+ba+b的值
输入输出样例
输入 #1

1
1

输出 #1

2

输入 #2

1001
9099

输出 #2

10100

code:
int num[501],jw,rh;
int main(){//高精
    string a,b;
    cin>>a>>b;
    for(int i=a.length()-1;i>=0;i--)
        num[i]+=(a[a.length()-i-1]-'0');
    for(int i=b.length()-1;i>=0;i--)
        num[i]+=(b[b.length()-i-1]-'0');
    for(int i=0;i<max(a.length(),b.length());i++){
        rh=num[i]+jw;
        num[i]=(num[i]+jw)%10;
        jw=rh/10;
    }
    if(jw)cout<<jw;
    for(int i=max(a.length(),b.length())-1;i>=0;i--)
        cout<<num[i];
}

*/

/*
P1603 斯诺登的密码

题目背景

根据斯诺登事件出的一道水题
题目描述

2013 年 X 月 X 日，俄罗斯办理了斯诺登的护照，于是他混迹于一架开往委内瑞拉的飞机。但是，这件事情太不周密了，因为FBI的间谍早已获悉他的具体位置――但这不是最重要的――最重要的是如果要去委内瑞拉，那么就要经过古巴，而经过古巴的路在美国的掌控之中。

丧心病狂的奥巴马迫降斯诺登的飞机，搜查时却发现，斯诺登杳无踪迹。但是，在据说是斯诺登的座位上，发现了一张纸条。纸条由纯英文构成：Obama is a two five zero.（以 . 结束输出，只有 6 个单词+一个句号，句子开头如没有大写亦为合法）这句话虽然有点无厘头，但是警官陈B骛发现这是一条极其重要的线索。他在斯诺登截获的一台笔记本中找到了一个 C++ 程序，输入这条句子后立马给出了相对应的密码。陈B鹜高兴得晕了过去，身为警官的你把字条和程序带上了飞机，准备飞往曼哈顿国际机场，但是在飞机上检查的时候发现――程序被粉碎了！飞机抵达华盛顿只剩5分钟，你必须在这 5 分钟内编写（杜撰）一个程序，免受上司的 10000000000%10 大板。破译密码的步骤如下：

（1）找出句子中所有用英文表示的数字(≤20)(\leq 20) (≤20)，列举在下：

正规：one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty

非正规：a both another first second third。为避免造成歧义，another 算作 111 处理。

（2）将这些数字平方后对 100100100 取模，如 00,05,11,19,86,9900,05,11,19,86,9900,05,11,19,86,99。

（3）把这些两位数按数位排成一行，组成一个新数，如果开头为 000，就去 000。

（4）找出所有排列方法中最小的一个数，即为密码。

// 数据已经修正 By absi2011 如果还有问题请联系我
输入格式

一个含有 6 个单词的句子。
输出格式

一个整型变量（密码）。如果没有符合要求的数字出现，则输出 0。
输入输出样例
输入 #1

Black Obama is two five zero .

输出 #1

425

code:
char dic[30][20]={  "zero","one","two","three","four",
                    "five","six","seven","eight","nine",
                    "ten","eleven","twelve", "thirteen", "fourteen", 
                    "fifteen", "sixteen", "seventeen", "eighteen", "nineteen", 
                    "twenty","a","both","another","first",
                    "second","third"};
int di[]={          0,1,4,9,16,
                    25,36,49,64,81,
                    00,21,44,69,96,
                    25,56,89,24,61,
                    0,1,4,1,1,
                    4,9};
long long a[10],top,flag;
char s[100];
int main(){
    for(int i=1;i<=6;i++){
        cin>>s;
        for(int j=1;j<=26;j++)
            if(!strcmp(s,dic[j])){
                a[++top]=di[j];
                break;
            }
    }
    sort(a+1,a+top+1);
    for(int i=1;i<=top;i++)
        if(flag)printf("%.2d",a[i]);
        else if(a[i]) printf("%d",a[i]),flag=1;
    if(!flag)printf("0");
    return 0;
}

*/

/*
P1604 B进制星球

题目背景

进制题目，而且还是个计算器~~
题目描述

话说有一天，小Z乘坐宇宙飞船，飞到一个美丽的星球。因为历史的原因，科技在这个美丽的星球上并不很发达，星球上人们普遍采用B（2<=B<=36）进制计数。星球上的人们用美味的食物招待了小Z，作为回报，小Z希望送一个能够完成B进制加法的计算器给他们。 现在小Z希望你可以帮助他，编写实现B进制加法的程序。
输入格式

共3行第1行：一个十进制的整数,表示进制B。第2-3行：每行一个B进制数正整数。数字的每一位属于{0，1，2，3，4，5，6，7，8，9，A，B……}，每个数字长度<=2000位。
输出格式

一个B进制数，表示输入的两个数的和。
输入输出样例
输入 #1

4
123
321

输出 #1

1110

说明/提示

进制计算器

code:
int main(){//注意输入的进制是int型
    int numeration,jw=0,rh;cin>>numeration;
    string a,b;
    cin>>a>>b;
    int num[max(a.length(),b.length())+1];
    for(int i=0;i<max(a.length(),b.length())+1;i++)
        num[i]=0;
    for(int i=0;i<a.length();i++)
        if(a[a.length()-1-i]>='0' && a[a.length()-1-i]<='9')num[i]=num[i]+a[a.length()-1-i]-'0';
        else num[i]=num[i]+int(a[a.length()-1-i]-'A'+10);
    for(int i=0;i<b.length();i++)
        if(b[b.length()-1-i]>='0' && b[b.length()-1-i]<='9')num[i]=num[i]+b[b.length()-1-i]-'0';
        else num[i]=num[i]+int(b[b.length()-1-i]-'A'+10);
    for(int i=0;i<max(a.length(),b.length())+1;i++){
        rh=num[i]+jw;
        num[i]=(num[i]+jw)%numeration;
        jw=rh/numeration;
    }
    if(num[max(a.length(),b.length())])cout<<num[max(a.length(),b.length())];
    for(int i=max(a.length(),b.length())-1;i>=0;i--)
        if(num[i]<=9)cout<<num[i];
        else cout<<char('A'+(num[i]-10));
}

*/

/*
P1605 迷宫

题目背景

给定一个N*M方格的迷宫，迷宫里有T处障碍，障碍处不可通过。给定起点坐标和终点坐标，问: 每个方格最多经过1次，有多少种从起点坐标到终点坐标的方案。在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。
题目描述

无
输入格式

第一行N、M和T，N为行，M为列，T为障碍总数。第二行起点坐标SX,SY，终点坐标FX,FY。接下来T行，每行为障碍点的坐标。
输出格式

给定起点坐标和终点坐标，问每个方格最多经过1次，从起点坐标到终点坐标的方案总数。
输入输出样例
输入 #1

2 2 1
1 1 2 2
1 2

输出 #1

1

说明/提示

【数据规模】

1≤N,M≤5

code:
int q[101][101],sum,i,j,n,m,t,sx,sy,x,y,ex,ey,up[]={-1,0,0,1},down[]={0,-1,1,0};
void dfs(int a,int b){//广义广搜
    if (a==ex&&b==ey)sum++;
    else
        for(int i=0;i<4;i++)
            if(q[a+up[i]][b+down[i]]!=0) 
                q[a][b]=0,dfs(a+up[i],b+down[i]),q[a+up[i]][b+down[i]]=1;
}
int main(){
    cin>>n>>m>>t>>sx>>sy>>ex>>ey;
    for(i=1;i<=n;i++)
        for(j=1;j<=m;j++)
            q[i][j]=1;
    for(i=0;i<t;i++)
        scanf("%d%d",&x,&y),q[x][y]=0;
    dfs(sx,sy);
    cout<<sum;
    return 0;
}

*/

/*
P1610 鸿山洞的灯

题目描述

已知n盏灯以及每盏灯的位置p[i]，p[i]均不相等，两盏相邻的灯当小于dist时，若这个安全距离里面还有灯是亮着时，就可以关掉该盏灯，(即若第i-1盏与第i+1盏的距离<=dist，则可以关掉第i盏)求在保证洞里的光线是充足的情况下，一段区域里能删除的灯的最大值。

距离洞口最近和最远的两盏灯必须是亮着
输入格式

第一行两个数，n和dist

第二行n个数，即每盏灯的位置
输出格式

一个数，即一段区域里能删除的灯的最大值。
输入输出样例
输入 #1

3 3

1 2 3

输出 #1

1

说明/提示

n<=100000

code:
int main(){//贪心
    int n,dist,sum=0;
	cin>>n>>dist;
    int a[n];
	for(int i=1; i<=n; i++)
		cin>>a[i];
	sort(a+1,a+1+n);
	for(int i=2; i<=n-1; i++)
		if(a[i+1]-a[i-1]<=dist)
			a[i]=a[i-1],sum++;
	cout<<sum<<endl;
	return 0;
}

*/

/*
P1611 循环的数字

题目描述

你曾经因为看见一样的东西一遍又一遍地重复、循环而对电视节目感到厌烦么？好吧，虽然我并不关心电视节目的好坏，不过有时却也很像那样不断循环的数字。

让我们假定两个不同的正整数 (n,m)(n, m)(n,m) 是循环的，当且仅当你能通过将 nnn 末端的几个数字移到它的首端而不改变移动的数字的顺序并使整个数字变成 mmm 。举个例子，(12345,34512)(12345, 34512)(12345,34512) 就是一对循环的数字，因为你能把 123451234512345 中末尾的 345345345 移到 121212 前面，从而得到 345123451234512。注意，为了成为一对循环的数字，nnn 和 mmm 位数必须相同。无论 nnn 或 mmm 都没有前置的 000。

现在给定正整数 AAA 和 BBB，并保证 AAA 和 BBB 位数相同且均没有前置 000，求存在多少循环的正整数对 (n,m)(n, m)(n,m)，使得 A≤n≤m≤BA \leq n \le m \leq BA≤n≤m≤B ？
输入格式

本题有共有 101010 个测试点。 每个输入文件包含 111 行。 第 111 行有两个用空格隔开的正整数 AAA 和 BBB。
输出格式

每个输出文件应包含一个正整数 xxx，表示共有 xxx 组循环的正整数对 (n,m)(n,m)(n,m) 使得 A≤n≤m≤BA \leq n \le m \leq BA≤n≤m≤B。
输入输出样例
输入 #1

1111 2222

输出 #1

287

说明/提示

1≤A,B≤2×1061\le A,B \leq 2\times 10^61≤A,B≤2×106。

code:
int main(){
	int a,b,n,m,ans=0;
    cin>>a>>b;
	for(int i=a;i<b;++i){
		int wei=0;
		n=i;
		while(n){
			++wei;
            n/=10;
        }
		n=i;
		m=(n%10)*pow(10,wei-1)+n/10;
        while(m!=n){
			if(m>n&&m<=b) 
				++ans;
			m=(m%10)*pow(10,wei-1)+m/10;
		}
	}
    cout<<ans;
	return 0;
}

*/

/*
P1616 疯狂的采药

题目背景

此题为纪念 LiYuxiang 而生。
题目描述

LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是 LiYuxiang，你能完成这个任务吗？

此题和原题的不同点：

111. 每种草药可以无限制地疯狂采摘。

222. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！
输入格式

输入第一行有两个整数，分别代表总共能够用来采药的时间 ttt 和代表山洞里的草药的数目 mmm。

第 222 到第 (m+1)(m + 1)(m+1) 行，每行两个整数，第 (i+1)(i + 1)(i+1) 行的整数 ai,bia_i, b_iai?,bi? 分别表示采摘第 iii 种草药的时间和该草药的价值。
输出格式

输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。
输入输出样例
输入 #1

70 3
71 100
69 1
1 2

输出 #1

140

说明/提示
数据规模与约定

    对于 30%30\%30% 的数据，保证 m≤103m \le 10^3m≤103 。
    对于 100%100\%100% 的数据，保证 1≤m≤1041 \leq m \le 10^41≤m≤104，1≤t≤1071 \leq t \leq 10^71≤t≤107，且 1≤m×t≤1071 \leq m \times t \leq 10^71≤m×t≤107，1≤ai,bi≤1041 \leq a_i, b_i \leq 10^41≤ai?,bi?≤104。

code:
int main(){
    long long time,m;
    cin>>time>>m;
    long long weight[m]={0},val[m]={0},f[time+1]={0};
    for(int i=1;i<=m;i++)
        cin>>weight[i]>>val[i];
    for(int i=1;i<=m;i++)
        for(int j=weight[i];j<=time;j++)
            f[j]=max(f[j],f[j-weight[i]]+val[i]);
    cout<<f[time];
	return 0;
}

*/

/*
P1618 三连击（升级版）

题目描述

将 1,2,…,91, 2,\ldots, 91,2,…,9 共 999 个数分成三组，分别组成三个三位数，且使这三个三位数的比例是 A:B:CA:B:CA:B:C，试求出所有满足条件的三个三位数，若无解，输出 No!!!。

//感谢黄小U饮品完善题意
输入格式

三个数，A,B,CA,B,CA,B,C。
输出格式

若干行，每行 333 个数字。按照每行第一个数字升序排列。
输入输出样例
输入 #1

1 2 3

输出 #1

192 384 576
219 438 657
273 546 819
327 654 981

说明/提示

保证 A<B<CA<B<CA<B<C。

code:
int sums(int a,int b,int c,int d=1){
    return (100*a+10*b+c)*d;
}
int main(){//stl用法
    int A,B,C,a[]={1,2,3,4,5,6,7,8,9};
    bool h=false;
    cin>>A>>B>>C;
    do{
        if(sums(a[0],a[1],a[2],B*C)==sums(a[3],a[4],a[5],A*C) && sums(a[0],a[1],a[2],B*C)==sums(a[6],a[7],a[8],A*B)){
            cout<<sums(a[0],a[1],a[2])<<" "<<sums(a[3],a[4],a[5])<<" "<<sums(a[6],a[7],a[8])<<endl;
            h=true;
        }
    }while(next_permutation(a,a+9));//stl中,函数next_permutation提供下一个排列功能
    if(h==false) cout<<"No!!!";
    return 0;
}

*/

/*
P1626 象棋比赛

题目描述

有N个人要参加国际象棋比赛，该比赛要进行K场对弈。每个人最多参加两场对弈，最少参加零场对弈。每个人都有一个与其他人不相同的等级（用一个正整数来表示）。

在对弈中，等级高的人必须用黑色的棋子，等级低的人必须用白色的棋子。每个人最多只能用一次黑色的棋子和一次白色的棋子。为增加比赛的可观度，观众希望K场对弈中双方的等级差的总和最小。

比如有7个选手，他们的等级分别是30，17，26，41，19，38，18，要进行3场比赛。最好的安排是选手2对选手7，选手7对选手5，选手6对选手4。此时等级差的总和等于（18-17）+（19-18）+（41-38）=5达到最小。
输入格式

第一行两个正整数N，K

接下来有N行，第i行表示第i-1个人等级。

[数据规模]

在90%的数据中，1≤N≤3000；

在100%的数据中，1≤N≤100000；

保证所有输入数据中等级的值小于100000000，1≤K≤N-1。
输出格式

在第一行输出最小的等级差的总和。
输入输出样例
输入 #1

7 3
30
17
26
41
19
38
18

输出 #1

5

code:
int main(){
    int n,m,sum=0;cin>>n>>m;
    int num[n];
    for(int i=0;i<n;i++)
        cin>>num[i];
    sort(num,num+n);
    for(int i=0;i<n-1;i++)
        num[i]=num[i+1]-num[i];
    sort(num,num+n);
    for(int i=0;i<m;i++)
        sum+=num[i];
    cout<<sum;
    return 0;
}

*/

/*
P1628 合并序列

题目描述

有 NNN 个单词和字符串 TTT，按字典序输出以字符串 TTT 为前缀的所有单词。
输入格式

输入文件第一行包含一个正整数 NNN；

接下来 NNN 行，每行一个单词，长度不超过 100100100；

最后一行包含字符串 TTT。
输出格式

按字典序升序输出答案。
输入输出样例
输入 #1

6
na
no
ki
ki
ka
ku
k

输出 #1

ka
ki
ki
ku

说明/提示

【数据规模】

对于 60%60\%60% 的数据，满足 1≤N≤10001 \le N \le 10001≤N≤1000；

对于 100%100\%100% 的数据，满足 1≤N≤1000001 \le N \le 1000001≤N≤100000 且所有字符均为小写字母。

code:
int main(){//sort 字符串字典排序用法
    int n;
    cin>>n;
    string a[n],k;
    for(int i=0;i<n;i++)
        cin>>a[i];
    cin>>k;
    sort(a,a+n);
    for(int i=0;i<n;i++) 
        if(a[i].find(k)==0)
            cout<<a[i]<<endl;
    return 0;
}


*/

/*
P1636 Einstein学画画

题目描述

Einstein 学起了画画。

此人比较懒~~，他希望用最少的笔画画出一张画……

给定一个无向图，包含 nnn 个顶点（编号 1?n1 \sim n1?n），mmm 条边，求最少用多少笔可以画出图中所有的边。
输入格式

第一行两个整数 n,mn, mn,m。

接下来 mmm 行，每行两个数 a,ba, ba,b（a≠ba \ne ba=b），表示 a,ba, ba,b 两点之间有一条边相连。

一条边不会被描述多次。
输出格式

一个数，即问题的答案。
输入输出样例
输入 #1

5 5

2 3

2 4

2 5

3 4

4 5

输出 #1

1

说明/提示

对于 50%50 \%50% 的数据，n≤50n \le 50n≤50，m≤100m \le 100m≤100。

对于 100%100\%100% 的数据，1≤n≤10001 \le n \le 10001≤n≤1000，1≤m≤1051 \le m \le {10}^51≤m≤105。

code:
int main(){//欧拉无向图
    int n,m;cin>>n>>m;
    int num[n]={0},a,b,sum=0;
    for(int i=0;i<m;i++){
        cin>>a>>b;
        num[a-1]++;
        num[b-1]++;
    }
    for(int i=0;i<n;i++)
        if(num[i]%2)
            sum++;
    if(sum==0)cout<<1;
    else cout<<sum/2;
    return 0;
}

*/

/*
P1644 跳马问题

题目背景

在爱与愁的故事第一弹第三章出来前先练练四道基本的回溯/搜索题吧……
题目描述

中国象棋半张棋盘如图 111 所示。马自左下角 (0,0)(0,0)(0,0) 向右上角 (m,n)(m,n)(m,n) 跳。规定只能往右跳，不准往左跳。比如图 111 中所示为一种跳行路线，并将路径总数打印出来。

输入格式

只有一行：两个数 nnn，mmm。
输出格式

只有一个数：总方案数 totaltotaltotal。
输入输出样例
输入 #1

4 8

输出 #1

37

说明/提示

对于 100%100\%100% 的数据：n,m≤18n, m\leq 18n,m≤18

code:
int m,n,t;
void dfs(int a,int b){
    if (a<0 || a>n || b>m) return;
    else if (a==n && b==m) t++;
    else dfs(a+1,b+2),dfs(a+2,b+1),dfs(a-2,b+1),dfs(a-1,b+2);
}
int main(){//深搜
    cin>>n>>m;
    dfs(0,0);
    cout<<t;
    return 0;
}

*/

/*
P1657 选书

题目描述

学校放寒假时，信息学奥赛辅导老师有1,2,3……x本书，要分给参加培训的x个人，每人只能选一本书，但是每人有两本喜欢的书。老师事先让每个人将自己喜欢的书填写在一张表上。然后根据他们填写的表来分配书本，希望设计一个程序帮助老师求出所有可能的分配方案，使每个学生都满意。
输入格式

第1行：一个数x

第2行~第1+x行：每行两个数，表示ai喜欢的书的序号
输出格式

只有一个数：总方案数total。
输入输出样例
输入 #1

5
1 3
4 5
2 5
1 4
3 5

输出 #1

2

说明/提示

所有数据：x<=20

（世界上最难出数据的题目，没有之一……）

code:
int x,a1[21],a2[21],flag=0;
bool ans[21]={false};
void dfs(int m){
	if(m>x)flag++;
    else
        for(int i=1;i<=x;i++)
            if(ans[i]==false && (a1[m]==i || a2[m]==i))
                ans[i]=true,dfs(m+1),ans[i]=false;
}
int main(){//深搜
	cin>>x;
	if(x==0)cout<<0;
    else {
        for(int i=1;i<=x;i++)
            cin>>a1[i]>>a2[i];
        dfs(1);
        cout<<flag;
    }
	return 0;
}

*/

/*
P1678 烦恼的高考志愿

题目背景

计算机竞赛小组的神牛V神终于结束了高考，然而作为班长的他还不能闲下来，班主任老t给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是v神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。
题目描述

现有 m(m≤100000)m(m\le100000)m(m≤100000) 所学校，每所学校预计分数线是 ai(ai≤106)a_i(a_i\le10^6)ai?(ai?≤106)。有 n(n≤100000)n(n\le100000)n(n≤100000) 位学生，估分分别为 bi(bi≤106)b_i(b_i\le10^6)bi?(bi?≤106)。

根据n位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。
输入格式

第一行读入两个整数m,n。m表示学校数，n表示学生数。第二行共有m个数，表示m个学校的预计录取分数。第三行有n个数，表示n个学生的估分成绩。
输出格式

一行，为最小的不满度之和。
输入输出样例
输入 #1

4 3
513 598 567 689
500 600 550

输出 #1

32

说明/提示

数据范围：

对于30%的数据，m，n<=1000,估分和录取线<=10000;

对于100%的数据，n,m<=100,000,录取线<=1000000。

code:#include<bits/stdc++.h>
using namespace std;
int main(){//二分
	int n,m,ans=0;
    cin>>n>>m;
    int a[n+1],b[m+1];
	for(int i=0; i<n; i++)
		cin>>a[i];
	for(int i=0; i<m; i++)
		cin>>b[i];
	sort(a,a+n);
	for(int i=0; i<m; i++){
		int l=0,r=n;
		while(l<r)
			if(a[(l+r)/2]<=b[i])l=(l+r)/2+1;
			else r=(l+r)/2;
		if(b[i]<=a[0])ans+=a[0]-b[i];
		else ans+=min(abs(a[l-1]-b[i]),abs(a[l]-b[i]));
	}
	cout<<ans;
    return 0;
}

*/

/*
P1679 神奇的四次方数

题目描述

在你的帮助下，v神终于帮同学找到了最合适的大学，接下来就要通知同学了。在班级里负责联络网的是dm同学，于是v神便找到了dm同学，可dm同学正在忙于研究一道有趣的数学题，为了请dm出山，v神只好请你帮忙解决这道题了。

题目描述：将一个整数m分解为n个四次方数的和的形式，要求n最小。例如，m=706,706=5^4+3^4,则n=2。
输入格式

一行，一个整数m。
输出格式

一行，一个整数n。
输入输出样例
输入 #1

706

输出 #1

2

说明/提示

数据范围：对于30%的数据，m<=5000;对于100%的数据，m<=100,000

code:
int n,ans=100000;
void dfs(int tot,int k,int last){
	if(k>ans||tot>n) return;
	if(tot==n){
		ans=min(ans,k);
		return;
	}
	int i;
	for(i=last;i*i*i*i<=n-tot;i++);
	for(;i>=last;i--)
		dfs(tot+i*i*i*i,k+1,i);
}
int main(){//深搜爆搜
	cin>>n;
	dfs(0,0,1);
    cout<<ans;
}

*/

/*
P1683 入门

题目描述

不是任何人都可以进入桃花岛的，黄药师最讨厌象郭靖一样呆头呆脑的人。所以，他在桃花岛的唯一入口处修了一条小路，这条小路全部用正方形瓷砖铺设而成。有的瓷砖可以踩，我们认为是安全的，而有的瓷砖一踩上去就会有喷出要命的毒气，那你就死翘翘了，我们认为是不安全的。你只能从一块安全的瓷砖上走到与他相邻的四块瓷砖中的任何一个上，但它也必须是安全的才行。

由于你是黄蓉的朋友，她事先告诉你哪些砖是安全的、哪些砖是不安全的，并且她会指引你飞到第一块砖上（第一块砖可能在任意安全位置），现在她告诉你进入桃花岛的秘密就是：如果你能走过最多的瓷砖并且没有死，那么桃花岛的大门就会自动打开了，你就可以从当前位置直接飞进大门了。

注意：瓷砖可以重复走过，但不能重复计数。
输入格式

第一行两个正整数 WWW 和 HHH，分别表示小路的宽度和长度。

以下 HHH 行为一个 H×WH\times WH×W 的字符矩阵。每一个字符代表一块瓷砖。其中，. 代表安全的砖，# 代表不安全的砖，@ 代表第一块砖。
输出格式

输出一行，只包括一个数，即你从第一块砖开始所能安全走过的最多的砖块个数（包括第一块砖）。
输入输出样例
输入 #1

11 9
.#.........
.#.#######.
.#.#.....#.
.#.#.###.#.
.#.#..@#.#.
.#.#####.#.
.#.......#.
.#########.
...........

输出 #1

59

说明/提示
数据规模与约定

对于全部的测试点，保证 1≤W,H≤201 \leq W,H\le 201≤W,H≤20。

code:
int x[10000001],y[100000001],ans,sum,w,h,qx,qy,py[]={0,-1,0,1,0},px[]={0,0,1,0,-1};
char c[1001][1001];
bool flag[1001][1001];
int se(int sy,int sx){
	for(int i=1;i<=4;i++){
		int dy=py[i]+sy,dx=px[i]+sx;
		if(flag[dy][dx]==0&&c[dy][dx]=='.'&&dy<=h&&dy>0&&dx<=w&&dx>0){
			flag[dy][dx]=1;
			sum++;
			se(dy,dx);
		}
	}
}
int main(){
	cin>>w>>h;
	for(int i=1;i<=h;i++)
		for(int j=1;j<=w;j++){
			cin>>c[i][j];
			if(c[i][j]=='@')qx=j,qy=i;
		}
	sum++;
	flag[qy][qx]=1;
	se(qy,qx);
	cout<<sum<<endl;
	return 0;
}

*/

/*
P1689 方程求解

题目描述

给一个方程，形如 X+Y=ZX+Y=ZX+Y=Z 或 X?Y=ZX-Y=ZX?Y=Z。给出了其中两个未知数，请求出第三个数。未知数用 ? 表示，等式中也许会出现一些多余的空格。
输入格式

输入一行一个字符出代表方程。
输出格式

一行一个整数表示?代表的值。
输入输出样例
输入 #1

1+2=?

输出 #1

3

输入 #2

3 +? =  2

输出 #2

-1

输入 #3

3-?=2

输出 #3

1

说明/提示
数据规模与约定

对于 100%100\%100% 的数，保证 0≤X,Y,Z<1090\le X,Y,Z\lt10^90≤X,Y,Z<109，输入的字符串一定为题目给定的形式且长度不超过 10610^6106。

code:
int i,x,a[10],b[10];
string t,s;
int main(){
    while(cin>>t)
        s+=t;
    for(i=0;i<s.size();i++){
        if(s[i]=='?')
            b[++x]=1;
        if(s[i]<'0'||s[i]>'9')
            continue;
        for(x++;s[i]>='0'&&s[i]<='9';i++)
            a[x]=a[x]*10+s[i]-48;
    }
    if(s.find('+')<s.size())x=1;
    else x=0;
    if(x&&b[1])printf("%d\n",a[3]-a[2]);
    else if(x&&b[2])printf("%d\n",a[3]-a[1]);
    else if(x&&b[3])printf("%d\n",a[1]+a[2]);
    else if(!x&&b[1])printf("%d\n",a[2]+a[3]);
    else if(!x&&b[2])printf("%d\n",a[1]-a[3]);
    else printf("%d\n",a[1]-a[2]);
    return 0;
}

*/

/*
P1703 那个什么密码2

题目背景

原题为 https://www.luogu.com.cn/problem/P1079。
题目描述

与原题一模一样、具体不同请见输入格式
输入格式

第一行输入密钥

第二行输入明文

第三行输入一个正整数 MMM, 代表操作个数.

每个操作将 [a,b][a,b][a,b] 的字符全部倒转，比如 abc 倒转为 cba.

接下来 MMM 行，每行输入两个正整数 aaa, bbb。
输出格式

输出一行,输出密文。
输入输出样例
输入 #1

CompleteVictory
Wherethereisawillthereisaway
0

输出 #1

Yvqgpxaimmklongnzfwpvxmniytm

说明/提示

由 zxy 大神原创、本人在洛谷上传。

code:
int main(){
    int m=0,a=0,b=0;
    string key,ans;
    cin>>key>>ans;
    for(int i=0;key[i];i++)
        key[i]=tolower(key[i]);
    for(int i=0,j=0,x;ans[i];i++,j=(j+1)%key.size()){
        x=ans[i]+key[j]-'a';
        if((islower(ans[i])&&x>'z')||(isupper(ans[i])&&x>'Z'))
            x-=26;
        ans[i]=x;
    }
    scanf("%d",&m);
    for(int i=0;i<m;i++){
        cin>>a>>b;
        a--;
        b--;
        string s=ans.substr(a,b-a+1);
        reverse(s.begin(),s.end());
        ans.replace(a,b-a+1,s);
    }
    cout<<ans;
}

*/

/*
P1705 爱与愁过火

题目背景

（本道题目隐藏了两首歌名，找找看哪~~~）

《爱与愁的故事第一弹・heartache》第三章。

爱与愁大神说这是ta的伤心指数，只不过现在好很多了，翻译只是看你无聊让你动动脑筋罢了（shit~~~）。虽然月落乌啼嘴上骂着：“我去年买了个表……纽曼表……”，但是结果还是请爱与愁大神去Pizza Hut吃了一顿。
题目描述

到了Pizza Hut，爱与愁大神由于不爽，所以存心想坑月落乌啼的钱，ta点了m样菜，每样菜ai元。月落乌啼预计只用n元，于是他让爱与愁大神重新从这m样菜中选r样。爱与愁大神还是想坑钱，于是ta打电话给你，让你编一个程序告诉ta有几种方案可以从m样菜中点取r样菜但是还能超过月落乌啼的预计n元。
输入格式

第1行：三个数 m，r，n。

第2行：m个数，每道菜需要的钱ai，两个数之间有空格。
输出格式

只有一个整数，表示方案总数。
输入输出样例
输入 #1

5 2 8

1 7 2 5 4

输出 #1

4

说明/提示

100%数据：m<=30，r<=m，m<=ai<=90 n<=2700

时限：前两个点1秒，中间两个点3秒，最后一个点6秒。

code:
int main(){//01背包 dp算法 
    int m,r,n,t=0,ans=0;
    cin>>m>>r>>n;
    int a[m+1];
    for (int i=1;i<=m;i++){
        cin>>a[i];
        t+=a[i];
    }
    int f[m+1][t+1];
    memset(f,0,sizeof(f));
    f[0][0]=1;
    for (int i=1;i<=m;i++)
        for (int j=r;j>=1;j--)
            for (int k=a[i];k<=t;k++)
                f[j][k]+=f[j-1][k-a[i]];
    for (int i=n+1;i<=t;i++)
        ans+=f[r][i];
    cout<<ans;
    return 0;
}

*/

/*
P1706 全排列问题

题目描述

按照字典序输出自然数 111 到 nnn 所有不重复的排列，即 nnn 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。
输入格式

一个整数 nnn。
输出格式

由 1?n1 \sim n1?n 组成的所有不重复的数字序列，每行一个序列。

每个数字保留 555 个场宽。
输入输出样例
输入 #1

3

输出 #1

    1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1

说明/提示

1≤n≤91 \leq n \leq 91≤n≤9。

code:
int main(){//stl 全排列next_permutation
    int n,i,j=1,k,a[10];
    cin>>n;
    for(i=1;i<=n;i++){
        a[i]=n-i+1;
        j*=i;
    }
    for(i=1;i<=j;i++){
        next_permutation(a+1,a+n+1);
        for(k=1;k<=n;k++)
            cout<<"    "<<a[k];
        cout<<endl;
    }
    return 0;
}

*/

/*
P1708 天然气井

题目描述

Mary试图控制成都的天然气市场。专家已经标示出了最好的天然气井和中转站在成都的地图。现在需要将中转站和天然气井连接起来。每个中转站必须被连接到正好一个钻油井，反之亦然。

Mary特别指名，建设的天然气管道必须从某个天然气井开始，向南或者向东建设。Mary想知道怎么连接每个天然气井和中转站，使得需要的天然气管道的总长度最小。
输入格式

输入文件的第一行为一个正整数n(2<=n<=50000)，表示天然气井的数量（中转站的数量与之相等）。

接下来n行，每行两个整数xi和yi（0<=xi,yi<=100000），表示天然气井的坐标。向东走则x坐标增加，向北走则y坐标增加。

接下来n行，每行两个数xj'和yj'（0<=xj',yj'<=100000），表示中转站的坐标。
输出格式

输入文件第一行包含一个数，表示最短的连接管道长度。
输入输出样例
输入 #1

3

3 5

1 2

4 3

6 3

5 2

2 1

输出 #1

9

说明/提示

本题题源 POI-XIV-GAZ,请采用尽可能优的算法满足时限

code:
long long n,x,y,ansx,ansy;
int main(){//贪心数论
	scanf("%d",&n);//注:main内定义longlong将会无法正常输入
	for(int i=0;i<n;i++)
        scanf("%lld%lld",&x,&y),ansx+=x,ansy+=y;
	for(int i=0;i<n;i++)
        scanf("%lld%lld",&x,&y),ansx-=x,ansy-=y;
	printf("%lld",abs(ansx)+abs(ansy));
	return 0;
} 

*/

/*
P1716 双调序列

题目描述

电脑组的童鞋们经常玩一些智力PK小游戏，某月某日，发源于小朋友又发明了一种新的序列：双调序列，所谓的双调呢主要是满足如下条件描述：

假定有n(n<=1000)个整数（都在longint范围内，即-2147483648~2147483647），双调序列的第一个数是n个整数中的最大数，第二个数是n个整数中的最小数，第三个数是n个数中的第二大数，第四个数是n个数中的第二小数……取过的数不能再取，依次类推，直到结束。

聪明的你听完描述就抿嘴笑了吧？那就请你用程序正确的帮他找出这n个数的双调序列。
输入格式

第1行为一个整数n。

接下来n行给出了题目中所述的n个整数，每行包含一个整数。
输出格式

有n行，每行为一个整数，是满足条件的双调序列
输入输出样例
输入 #1

5
10
-1
3
3
-9

输出 #1

10
-9
3
-1
3

说明/提示

对于100%的数据，n<=1000。

code:
int main(){
    int n;cin>>n;
    int num[n];
    for(int i=0;i<n;i++)cin>>num[i];
    sort(num,num+n);
    for(int i=0;i<n/2;i++)cout<<num[n-i-1]<<endl<<num[i]<<endl;
    if(n%2==1)cout<<num[n/2];
    return 0;
}

*/

/*
P1718 图形复原

题目描述

HWX小朋友对几何的热爱在电脑组是出了名的，号称“每题必解”，这天，LXC在玩logo的时候突然想到了一个题目，刚好可以去测试一下他封号的虚实，于是，他logo编程画了一个n边形，并且将n个顶点用1，2，3，…,n这n个连续自然数随手编了个号，为了增加难度，他又画了一些不相交的对角线。如下图：

他把所有的边和对角线都写在一张纸上，对于上图，他写了：（1，3），（3，2），（2，4），（4，5），（5，1），（1，4），（3，4）。正得意的时候，电脑突然自动重启了，郁闷的是，他忘记保存刚才的logo程序了，此刻的他很想利用纸上记录的信息将这个n边形的编号复原，电脑组的你能帮助他吗？
输入格式

第一行n（n<=50）

下面若干行，每行两个数a，b，表示纸上记录的信息。
输出格式

仅一行，按字典序较小的顺序依次输出顶点的编号。对于上面的例子，你的输出应该是1 3 2 4 5。
输入输出样例
输入 #1

5

1 3

3 2

2 4

4 5

5 1

1 4

3 4

输出 #1

1 3 2 4 5

code:#include<bits/stdc++.h>
using namespace std;
int n,m,x,y,sum,s,ans[60];
bool all,flag,a[60][60],vis[60];
void dfs(int k,int cnt){
    if(flag==true) 
        return;
	ans[cnt]=k;
	if(cnt==n&&a[k][s]==1){
        for(int i=1;i<=n;i++) 
            cout<<ans[i]<<' ';
        flag=true;
        return;
    }
    for(int i=1;i<=n;i++)
        if(a[k][i]&&k!=i&&!vis[i])
            vis[i]=1,dfs(i,cnt+1),vis[i]=0;
}
int main(){//图论搜索
	scanf("%d",&n);
	for(int i=1;i<=2*n-3;i++){
	    scanf("%d%d",&x,&y);
	    a[x][y]=1;
	    a[y][x]=1;
	}
	for(int i=1;i<=n;i++)
	    s=i,vis[i]=1,dfs(i,1);
}

*/

/*
P1719 最大加权矩形

题目描述

为了更好的备战 NOIP2013 ，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。

校长先给他们一个 N×NN\times NN×N 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 [?127,127][-127,127][?127,127] ,例如

 0 C2 C7  0 
 9  2 C6  2
-4  1 C4  1 
-1  8  0 C2

在左下角：

9  2
-4  1
-1  8

和为15。

几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？
输入格式

第一行：nnn ，接下来是 nnn 行 nnn 列的矩阵。
输出格式

最大矩形（子矩阵）的和。
输入输出样例
输入 #1

4
0 -2 -7 0
 9 2 -6 2
-4 1 -4  1 
-1 8  0 -2

输出 #1

15

说明/提示

n≤120n\le 120n≤120

code:
int b[125][125];
int main() {
	int n,ans=-1828805;//最小不会小过这个值 
	scanf("%d",&n);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=n;++j) {
			int a;
			scanf("%d",&a);
			b[i][j]=b[i-1][j]+a;
		}
	for(int i=1;i<=n;++i) 
		for(int j=0;j<i;++j) {
			int sum=0;
			for(int k=1;k<=n;++k) {
				int tmp=b[i][k]-b[j][k];
				if(sum<0)sum=0;
                sum+=tmp;
				if(sum>ans)	ans=sum;
			}
		}
	printf("%d",ans);
	return 0;
}

*/

/*
P1722 矩阵 II

题目背景

usqwedf 改编系列题。
题目描述

如果你在百忙之中抽空看题，请自动跳到第六行。

众所周知，在中国古代算筹中，红为正，黑为负……

给定一个1*(2n)的矩阵（usqwedf：这不是一个2n的队列么），现让你自由地放入红色算筹和黑色算筹，使矩阵平衡[即对于所有的i(1<=i<=2n)，使第1~i格中红色算筹个数大于等于黑色算筹]

问有多少种方案满足矩阵平衡。

见样例解释。
输入格式

正整数 n
输出格式

方案数t对100取模
输入输出样例
输入 #1

2

输出 #1

2

说明/提示

样例解释： 红 黑 红 黑

红 红 黑 黑

1<=n<=100

code:
int main(){//经典卡特兰数论dp递推
    int n;
    cin>>n;
    int f[n*2+1][n*2+1];
    memset(f,0,sizeof(f));
	f[1][1]=1;
	for (int i=2;i<=n+n;i++)
		for (int j=(i+1)/2;j<=i;j++)
			f[i][j]=(f[i-1][j]+f[i-1][j-1])%100;
	printf("%d",f[n+n][n]);
	return 0;
}

*/

/*
P1724 东风谷早苗

题目描述

在幻想乡，东风谷早苗是以高达控闻名的高中生宅巫女。某一天，早苗终于入手了最新款的钢达姆模型。作为最新的钢达姆，当然有了与以往不同的功能了，那就是它能够自动行走，厉害吧（好吧，我自重）。早苗的新模型可以按照输入的命令进行移动，命令包含’E’、’S’、’W’、’N’四种，分别对应四个不同的方向，依次为东、南、西、北。执行某个命令时，它会向着对应方向移动一个单位。作为新型机器人，自然不会只单单执行一个命令，它可以执行命令串。对于输入的命令串，每一秒它会按照命令行动一次。而执行完命令串最后一个命令后，会自动从头开始循环。在0时刻时早苗将钢达姆放置在了(0,0)的位置，并且输入了命令串。她想要知道T秒后钢达姆所在的位置坐标。

向东移动，坐标改变改变为(X+1,Y);

向南移动，坐标改变改变为(X,Y-1);

向西移动，坐标改变改变为(X-1,Y);

向北移动，坐标改变改变为(X,Y+1);
输入格式

第1行：一个字符串，表示早苗输入的命令串，保证至少有1个命令

第2行：一个正整数T
输出格式

第1行：两个整数，表示T秒时，钢达姆的坐标
输入输出样例
输入 #1

NSWWNSNEEWN
12

输出 #1

-1 3

说明/提示

对于60%的数据：T <= 500,000且命令串长度 <= 5,000

对于100%的数据：T <= 2,000,000,000且命令串长度<= 5,000

code:
string s;
long long t,x,y;
int main(){
    cin>>s>>t;
    for(int i=0;i<=min((long long)s.size()-1,t);i++)
    	if(s[i]=='N')x++;
    	else if(s[i]=='E')y++;
    	else if(s[i]=='S')x--;
    	else if(s[i]=='W')y--;
	x*=t/s.size(),y*=t/s.size();
	for(int i=0;i<t%s.size();i++)
    	if(s[i]=='N')x++;
    	else if(s[i]=='E')y++;
    	else if(s[i]=='S')x--;
    	else if(s[i]=='W')y--;
	cout<<y<<" "<<x;
    return 0;
}

*/

/*
P1727 计算π

题目背景

《爱与愁的故事第二弹・compute》第一章。
题目描述

中秋至，博饼声铿锵不断。爱与愁大神兴致勃勃地到学校博饼，结果抱回家的只有一秀二举。爱与愁大神十分生气，打电话给月落乌啼：“喂，帮我算出圆周率小数点后n（n<=10000）位，速度……”然后就挂了电话，也不知道月落乌啼正准备去上课。月落乌啼只好请到了你，让你编一个程序求出圆周率小数点后n位。
输入格式

只有一行：n
输出格式

若干行。

第一行：3.

第二行开始：圆周率的小数部分。10个数一个空格，50个数一次回车。
输入输出样例
输入 #1

100

输出 #1

3.
1415926535 8979323846 2643383279 5028841971 6939937510
5820974944 5923078164 0628620899 8628034825 3421170679

说明/提示

对于 30%30\%30% 的数据，n≤103n\leq 10^3n≤103。

对于 100%100\%100% 的数据，n≤104n\leq 10^4n≤104。

时限：1?61\sim 61?6 点 111 秒，777 点 333 秒，888 点 888 秒，9?109\sim 109?10 点 121212 秒。

code:
int a=10000,b,c=70000,d,e,f[70001],g,n=-1,len;
char str[100005]="141";
int main() {
	scanf("%d",&len);
    for(;b-c;) 
        f[b++]=a/5;
    for(;d=0,(g=c*2)
        &&n<=len;
        c-=14,~n&&sprintf(str+n, "%.4d",e+d/a),n+=4,e=d%a)
    for(b=c;d+=f[b]*a,f[b]=d%--g,d/=g--,--b;d*=b);
	printf("3.");
	for(register int i=0;i<len;i++) {
		if (!(i%10)) printf(" ");
		if (!(i%50)) printf("\n");
		printf("%c", str[i]);
	}
    return 0;
}

*/

/*
P1732 [TJOI2011]序列

题目描述

一数列 A={a1,a2,…,an}A=\{a_1,a_2,\ldots,a_n\}A={a1?,a2?,…,an?}，根据数列 AAA 计算数列 B={b1,b2,…,bn}B=\{b_1,b_2,\ldots,b_n\}B={b1?,b2?,…,bn?}，其中：

bi={a1,i=1min?1≤j<iOai?ajO,i>1b_i= \begin{cases} a_1 &, i=1 \\ \min_{1 \leq j < i}\left|a_i-a_j\right| &, i\gt 1 \end{cases}
bi?={a1?min1≤j<i?Oai??aj?O?,i=1,i>1?

求 ∑i=1nbi\sum\limits^n_{i=1}b_ii=1∑n?bi?。
输入格式

第一行是一个正整数 TTT，表示测试数据的组数。接下来有 TTT 行，每行表示一组测试数据。每行以一个正整数 nnn 开始，表示数列 AAA 中元素的个数；然后是 nnn 个非负整数，依次表示 a1,a2,…,ana_1,a_2,\ldots,a_na1?,a2?,…,an? 的值。
输出格式

对于每组测试数据，输出数列 BBB 的所有的元素之和。
输入输出样例
输入 #1

2
5 1 2 3 4 5
7 2 9 7 4 6 2 6

输出 #1

5
14

说明/提示

1≤t≤101\le t\le 101≤t≤10，1≤n≤1051\le n\le10^51≤n≤105，0≤ai≤655360\le a_i\le655360≤ai?≤65536。

code:
bool hav[65537];
int main(){
    int n,t,i,ans,tmp;
    scanf("%d",&t);
    while(t--){
        memset(hav,false,sizeof(hav));
        scanf("%d%d",&n,&tmp);
        hav[tmp]=true;
        ans=tmp;
        while(--n){
            scanf("%d",&tmp);
            for(i=0;;i++){
                if(tmp-i>=0)
                    if(hav[tmp-i]){
                        ans+=i;
                        break;
                    }
                if(tmp+i<=65536)
                    if(hav[tmp+i]){
                        ans+=i;
                        break;
                    }
            }
            hav[tmp]=true;
        }
        printf("%d\n",ans);
    }
    return 0;
}

*/

/*
P1733 猜数（IO交互版）

题目描述

评测机会在区间 [1,109][1,10^9][1,109] 中选择一个整数，你应该写一个代码来猜测它。你最多可以问评测机 505050 个问题。

对于每一次询问，你可以向评测机询问区间 [1,109][1,10^9][1,109] 中的一个整数，评测机会返回:

    0，如果它为答案（即评测机所选的数字），且程序应该在此之后停止询问。
    -1，如果它小于答案。
    1，如果它大于答案。

每次询问，你需要向标准输出输出一个 [1,109][1,10^9][1,109] 中的整数，然后清空缓冲区。

你可以使用如下语句来清空缓冲区：

    对于 C/C++：fflush(stdout)；
    对于 C++：std::cout << std::flush；
    对于 Java：System.out.flush()；
    对于 Python：stdout.flush()；
    对于 Pascal：flush(output)；
    对于其他语言，请自行查阅对应语言的帮助文档。

特别的，对于 C++ 语言，在输出换行时如果你使用 std::endl 而不是 '\n'，也可以自动刷新缓冲区。

然后你需要从标准输入中输入一个整数，代表评测机返回的结果。
输入格式

无
输出格式

无
输入输出样例

无
说明/提示
数据规模与约定

设 nnn 为答案。

    对于 50%50\%50% 的数据，保证 n≤51n \leq 51n≤51。
    对于 100%100\%100% 的数据，保证 1≤n≤1091 \leq n \leq 10^91≤n≤109。

code:
int main(){
	int l=1,r=pow(10,9),mid,res;
	while(l<=r){
		mid=(l+r)/2;
		cout<<mid<<endl;
		cin>>res;
		if(res==-1)l=mid+1;
		else if(res==0)break;
		else r=mid-1;
	}
    return 0;
}

*/

/*
P1734 最大约数和

题目描述

选取和不超过S的若干个不同的正整数，使得所有数的约数（不含它本身）之和最大。
输入格式

输入一个正整数S。
输出格式

输出最大的约数之和。
输入输出样例
输入 #1

11

输出 #1

9

说明/提示

样例说明

取数字4和6，可以得到最大值(1+2)+(1+2+3)=9。

数据规模

S<=1000

code:
int s,a[1005],u[1005];
int find(int x){
    int ans=0;
    for(int i=1;i<x;i++)
        if(x%i==0)
        ans+=i;
    return ans;
}
int main(){
    cin>>s;
    for(int i=1;i<=s;i++)
    a[i]=find(i);
    for(int i=1;i<=s;i++)
        for(int j=s;j>=i;j--)
            u[j]=max(u[j],u[j-i]+a[i]);
    cout<<u[s];
    return 0;
}

*/

/*
P1740 Diamond A&B(1)

题目背景

由于本题较难，将本题拆做两题，分别为 diamondA 以及 diamond B

原题仅供参考，请认真阅读 diamondA以及 diamondB的 input&output format

本题为：DiamondA
题目描述

原题 Description

教主上电视了！这个消息绝对是一个爆炸性的新闻。一经传开，大街上瞬间就没人了（都回家看电视去了），商店打烊，工厂停业。大家都把电视机的音量开到最大，教主的声音回响在大街小巷。

小L给小X慌乱地打开自己家的电视机，发现所有频道都播放的是教主的采访节目（-_-bbb）。只见电视屏幕上的教主笑意吟吟，给大家出了一道难题：

一个边长为n的大菱形被均匀地划分成了n*n个边长为1的小菱形组成的网格，但是网格中部分边被抹去了，小L想知道，大菱形内有多少个平行四边形，这些平行四边形内不存在边（平行四边形内是空的）。

教主说，如果谁写出了程序，移动用户请将程序发送到xxxx，联通用户请将程序发送到xxxx……如果答对这个题，将有机会参加抽奖，大奖将是教主签名的Orz教主T-Shirt一件！这个奖品太具有诱惑力了。于是你需要编一个程序完成这么一道题。

Input (input.in)

输入的第1行为一个正整数n，为大菱形的边长。

以下2n行，每行2n个字符，字符为空格，“/”，“\”中的一个。

前n行，第i行中居中有2i个字符，这2i个字符中位置为奇数的字符只可能为“/”或者空格，位置为偶数的字符只可能为“\”或空格，若为空格表示这样一条边不存在，其余字符均为空格，描述了大菱形的上半部分。

后n行，第i行居中有有2(n-i+1)个字符，与上半部分类似地描述了菱形的下半部分

输入文件保证大菱形的轮廓上没有边被抹去。

Output(output.out)

输出仅包括一个整数，为满足要求的平行四边形个数。

Sample Input

4 /
//
/\ /
/ / \

// / /

/\ / \ / /

Sample Output

3

DiamondA

将原题中的输入菱形 改为 矩形 输出。

用1表示有边，0表示无边。
输入格式

同原题
输出格式

第一行：n

以下2*n+1行,改为矩形后各边的输出，1表示有边，0表示无边。
输入输出样例
输入 #1

4

   /\   

  /\/\  

 /\  /\ 

/  \/  \

\/\/ / /

 \/\  / 

  \ \/  

   \/   

输出 #1

4

1111

11101

1000

10111

1100

10101

0111

11101

1111

说明/提示

数据范围：

对于20%的数据，n≤10；

对于40%的数据，n≤60；

对于60%的数据，n≤200；

对于100%的数据，n≤888。

时限1s

code:
int n,ps,o,p;
string a[1777],s;
int main(){//模拟
    cin>>n;
    cout<<n<<endl;
    for (int i=0;i<=n*2;i++){
    	getline(cin,s);//读取一行
        a[i]=" "+s;
    }
    for (int i=1;i<=2*n+1;i++,puts("")){
        ps=n+!(i&1);//i&1 -> i奇偶性
        o=(i+1)/2;
        p=n+1-i/2;
        for (int j=1;j<=ps;j++)
            if(a[o++][p++]==' ')putchar('0');
            else putchar('1');
    }
}

*/

/*
P1755 斐波那契的拆分

题目背景

无
题目描述

已知任意一个正整数都可以拆分为若干个斐波纳契数，现在，让你求出n的拆分方法
输入格式

一个数t，表示有t组数据

接下来t行，每行一个数n（如题）
输出格式

t行，每行一个字符串，表示拆分方法（格式:n=a1+a2+a3+..+an），要求从小到大输出
输入输出样例
输入 #1

1
1

输出 #1

1=1

输入 #2

1
10

输出 #2

10=2+8

说明/提示

若有多组数据，以个数最小的为准，若仍有多组，输出右边尽量大的一组

对于100%的数据 t<=1000 1<=n<=10^9

code:
long long f[100]={1,1};
stack <int> s;
int main() {//stl stack用法
	for(int i=1; i<=45;i++)
		f[i]=f[i-1]+f[i-2];
	int T,n;
    cin>>T;
    for(;T;T--){
		cin>>n; 
        cout<<n<<'=';
		for(int i=45;i>=1;i--){
			while(n>=f[i])
                s.push(f[i]),n-=f[i];
			if(n==0)
                break;
		}
		while(s.size()){
			if(s.size()==1){
				printf("%d\n",s.top());
				s.pop();
				break;
			}
			printf("%d+",s.top());
			s.pop();
		}
	}
	return 0;
}

*/

/*
P1757 通天之分组背包

题目背景

直达通天路・小 A 历险记第二篇
题目描述

自 010101 背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于 010101 背包，他的物品大致可分为 kkk 组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。
输入格式

两个数 m,nm,nm,n，表示一共有 nnn 件物品，总重量为 mmm。

接下来 nnn 行，每行 333 个数 ai,bi,cia_i,b_i,c_iai?,bi?,ci?，表示物品的重量，利用价值，所属组数。
输出格式

一个数，最大的利用价值。
输入输出样例
输入 #1

45 3
10 10 1
10 5 1
50 400 2

输出 #1

10

说明/提示

1≤m,n≤10001 \leq m, n \leq 10001≤m,n≤1000。

code:
int n,m,f[1010],a[1010],b[1010],c[101][20],cc[101],cn;
int main(){//dp
    scanf("%d%d",&m,&n);
    for(int i=1;i<=n;i++){
    	int C;
    	scanf("%d%d%d",&a[i],&b[i],&C);
    	cn=max(cn,C);
    	cc[C]++;
    	c[C][cc[C]]=i;
	}
    for(int i=1;i<=cn;i++)
    	for(int j=m;j>=0;j--)
    		for(int k=1;k<=cc[i];k++)
                if(j>=a[c[i][k]])
                    f[j]=max(f[j],f[j-a[c[i][k]]]+b[c[i][k]]);
    printf("%d\n",f[m]);
}

*/

/*
P1760 通天之汉诺塔

题目背景

直达通天路・小A历险记第四篇
题目描述

在你的帮助下，小A成功收集到了宝贵的数据，他终于来到了传说中连接通天路的通天山。但是这距离通天路仍然有一段距离，但是小A突然发现他没有地图！！！但是幸运的是，他在山脚下发现了一个宝箱。根据经验判断（小A有经验吗？），地图应该就在其中！在宝箱上，有三根柱子以及在一根柱子上的n个圆盘。小A在经过很长时间判断后，觉得这就是hanoi塔！（这都要琢磨）。但是移动是需要时间的，所以小A必须要通过制造延寿药水来完成这项任务。现在，他请你告诉他需要多少步完成，以便他造足够的延寿药水.。时限1s。
输入格式

一个数n，表示有n个圆盘
输出格式

一个数s，表示需要s步。
输入输出样例
输入 #1

31

输出 #1

2147483647

输入 #2

15

输出 #2

32767

说明/提示

对于所有数据n<=15000

很容易的练手题哦！

code:
int main(){//递推
    int n,l=1;
	cin>>n;
    int a[n+1]={0};
	a[1]=1;
	for(int i=0;i<n;i++){
        for(int i=1;i<=l;i++)a[i]*=2;
        for(int i=1;i<=l;i++)
            if(a[i]>9)
                a[i+1]++,a[i]-=10; 
        if(a[l+1]>0)l++;
    }
	for(int i=l;i>1;i--)cout<<a[i];
	cout<<a[1]-1;
	return 0;
} 

*/

/*
P1781 宇宙总统

题目描述

地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 nnn 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。
输入格式

第一行为一个整数 nnn，代表竞选总统的人数。

接下来有 nnn 行，分别为第一个候选人到第 nnn 个候选人的票数。
输出格式

共两行，第一行是一个整数 mmm，为当上总统的人的号数。

第二行是当上总统的人的选票。
输入输出样例
输入 #1

5
98765
12365
87954
1022356
985678

输出 #1

4
1022356

说明/提示

票数可能会很大，可能会到 100100100 位数字。

1≤n≤201 \leq n \leq 201≤n≤20

code:
int main(){//字符串排序
    int n,id;cin>>n;
    string a="",b;
    for(int i=0;i<n;i++){
        cin>>b;
        int asize=a.size(),bsize=b.size();
        if(asize<bsize || (asize==bsize && a<b)){//字符串逻辑比对与长度弱相关
            a=b;
            id=i+1;
        }
    }
    cout<<id<<endl<<a<<endl;
	return 0;
}

*/

/*
P1795 无穷的序列

题目描述

有一个无穷序列如下：

110100100010000100000…

请你找出这个无穷序列中指定位置上的数字
输入格式

第一行一个正整数N，表示询问次数；

接下来的N行每行一个正整数Ai，Ai表示在序列中的位置。
输出格式

N行，每行为0或l，表示序列第Ai位上的数字。
输入输出样例
输入 #1

4
3
14
7
6 

输出 #1

0
0
1
0

说明/提示

对于100%的数据有N≤1500000，Ai≤10^9

code:
long long cinin(){//读入优化
    int s=0,w=1;
    char ch=getchar();
    while('0'>ch || ch>'9'){
        if(ch=='-')w=-1;
        ch=getchar();
    }
    while('0'<=ch && ch<='9')
        s=10*s+ch-'0',ch=getchar();
    return 2*(s*w-1);
}
int main(){//数论求根公式
    int n;cin>>n;
    long long k;
    double p;
    for(int i=0;i<n;i++){
        k=cinin();
        p=(long long)(sqrt(4*k+1));
        if(p==(sqrt(4*k+1)))cout<<1<<endl;
        else cout<<0<<endl;
    }
	return 0;
}

*/

/*
P1796 汤姆斯的天堂梦

题目描述

汤姆斯生活在一个等级为 000 的星球上。那里的环境极其恶劣，每天 121212 小时的工作和成堆的垃圾让人忍无可忍。他向往着等级为 NNN 的星球上天堂般的生活。

有一些航班将人从低等级的星球送上高一级的星球，有时需要向驾驶员支付一定金额的费用，有时却又可以得到一定的金钱。

汤姆斯预先知道了从 000 等级星球去 NNN 等级星球所有的航线和需要支付（或者可以得到）的金钱，他想寻找一条价格最低（甚至获得金钱最多）的航线。
输入格式

第一行一个正整数 NNN（N≤100N \le 100N≤100），接下来的数据可分为 NNN 个段落，每段的第一行一个整数 KiK_iKi?（Ki≤100K_i \le 100Ki?≤100），表示等级为 iii 的星球有 KiK_iKi? 个。

接下来的 KiK_iKi? 行中第 jjj 行依次表示与等级为 iii，编号为 jjj 的星球相连的等级为 i?1i - 1i?1 的星球的编号和此航线需要的费用（正数表示支出，负数表示收益，费用的绝对值不超过 100010001000）。

每行以 000 结束，每行的航线数 ≤100\le 100≤100。
输出格式

输出所需（或所得）费用。正数表示支出，负数表示收益。
输入输出样例
输入 #1

3
2
1 15 0
1 5 0
3
1 -5 2 10 0
1 3 0
2 40 0
2
1 1 2 5 3 -5 0
2 -19 3 -20 0

输出 #1

-1

说明/提示

对于 100%100 \%100% 的数据，1≤N≤1001 \le N \le 1001≤N≤100，1≤Ki≤1001 \le K_i \le 1001≤Ki?≤100。

code:
int f[200][200]={0},n,a,b,c;
int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;++i){
        scanf("%d",&a);
        for(int j=1;j<=a;++j){
            f[i][j]=INT_MAX-1000;//初始化，防止溢出
            scanf("%d",&b);
            while(b!=0){
                scanf("%d",&c);
                f[i][j]=f[i-1][b]+c<f[i][j]?f[i-1][b]+c:f[i][j];//DP
                scanf("%d",&b);
            }
        }
    }
    int min=INT_MAX;
    for(int i=1;i<=a;++i)
        min=f[n][i]<min?f[n][i]:min;
    printf("%d",min);
   return 0;
}

*/


/*
P1799 数列

题目描述

虽然 msh 长大了，但她还是很喜欢找点游戏自娱自乐。有一天，她在纸上写了一串数字：1,1,2,5,41, 1, 2, 5, 41,1,2,5,4。接着她擦掉了一个 111，结果发现剩下 1,2,41, 2, 41,2,4 都在自己所在的位置上，即 111 在第 111 位，222 在第 222 位，444 在第 444 位。她希望擦掉某些数后，剩下的数列中在自己位置上的数尽量多。她发现这个游戏很好玩，于是开始乐此不疲地玩起来……不过她不能确定最多能有多少个数在自己的位置上，所以找到你，请你帮忙计算一下！
输入格式

第一行为一个数 nnn，表示数列的长度。

接下来一行为 nnn个用空格隔开的正整数，第 iii 行表示数 AiA_iAi?。
输出格式

一行一个整数，表示擦掉某些数后，最后剩下的数列中最多能有多少个数在自己的位置上，即 Ai=iA_i=iAi?=i 最多能有多少。
输入输出样例
输入 #1

5

1 1 2 5 4

输出 #1

3

说明/提示

对于 20%20\%20% 的数据，n≤20n\leq 20n≤20;

对于 60%60\%60% 的数据，n≤100n\leq 100n≤100;

对于 100%100\%100% 的数据，n≤103n\leq 10^3n≤103。

code:
int main(){//一维bp
    int n,a,ans=0;
    cin>>n;
    int f[n+2]={0};
	for(int i=1;i<=n;i++){
        cin>>a;
		for(int j=i;j>=1;j--)
			f[j]=max(f[j],f[j-1]+(a==j?1:0));
	}
	for(int i=0;i<=n;i++)  
        ans=max(ans,f[i]);
    cout<<ans;
	return 0;
}

*/

/*
P1802 5倍经验日

题目背景

现在乐斗有活动了！每打一个人可以获得5倍经验！absi2011却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。
题目描述

现在absi2011拿出了x个迷你装药物(嗑药打人可耻….)，准备开始与那些人打了

由于迷你装一个只能管一次，所以absi2011要谨慎的使用这些药，悲剧的是，没到达最少打败该人所用的属性药了他打人必输>.<所以他用2个药去打别人，别人却表明3个药才能打过，那么相当于你输了并且这两个属性药浪费了。

现在有n个好友，有输掉拿的经验、赢了拿的经验、要嗑几个药才能打过。求出最大经验（注意，最后要乘以5）
输入格式

第一行两个数，n和x

后面n行每行三个数，分别表示输了拿到的经验(lose[i])、赢了拿到的经验(win[i])、打过要至少使用的药数量(use[i])。
输出格式

一个整数，最多获得的经验
输入输出样例
输入 #1

6 8
21 52 1
21 70 5
21 48 2
14 38 3
14 36 1
14 36 2

输出 #1

1060

说明/提示

【Hint】

五倍经验活动的时候，absi2011总是吃体力药水而不是这种属性药>.<

【数据范围】

对于10%的数据，保证x=0

对于30%的数据，保证n<=10,x<=20

对于60%的数据，保证n<=100,x<=100, 10<=lose[i], win[i]<=100,use[i]<=5

对于100%的数据，保证n<=1000,x<=1000,0<lose[i]<=win[i]<=1000000,0<=use[i]<=1000

【题目来源】

fight.pet.qq.com

absi2011授权题目

code:
int dp[1001];
int main(){//dp变式
    int n,m;
    cin>>n>>m;
    int win[n+1],lose[n+1],use[n+1];
    for(int i=1;i<=n;i++)
        cin>>lose[i]>>win[i]>>use[i];
    for(int i=1;i<=n;i++){
        for(int j=m;j>=use[i];j--)
            dp[j]=max(dp[j]+lose[i],dp[j-use[i]]+win[i]);
        for(int j=use[i]-1;j>=0;j--)
            dp[j]+=lose[i];
    }
    printf("%lld",5ll*dp[m]);//注意输出的long long否则产生截断出错
}

*/

/*
P1803 凌乱的yyy / 线段覆盖

题目背景

快 noip 了，yyy 很紧张！
题目描述

现在各大 oj 上有 nnn 个比赛，每个比赛的开始、结束的时间点是知道的。

yyy 认为，参加越多的比赛，noip 就能考的越好（假的）。

所以，他想知道他最多能参加几个比赛。

由于 yyy 是Xm，如果要参加一个比赛必须善始善终，而且不能同时参加 222 个及以上的比赛。
输入格式

第一行是一个整数 nnn ，接下来 nnn 行每行是 222 个整数 ai,bia_{i},b_{i}ai?,bi? ( ai<bia_{i}<b_{i}ai?<bi? )，表示比赛开始、结束的时间。
输出格式

一个整数最多参加的比赛数目。
输入输出样例
输入 #1

3
0 2
2 4
1 3

输出 #1

2

说明/提示

对于 20%20\%20% 的数据， n≤10n \le 10n≤10。

对于 50%50\%50% 的数据， n≤103n \le 10^3n≤103。

对于 70%70\%70% 的数据， n≤105n \le 10^{5}n≤105。

对于 100%100\%100% 的数据， 1≤n≤1061\le n \le 10^{6}1≤n≤106 ， 0≤ai<bi≤1060 \le a_{i} < b_{i} \le 10^60≤ai?<bi?≤106。

code:
struct Node{
    int a,b;
};
bool cmp(Node x,Node y){
    return x.b<y.b;
}
int main(){
    int n,sum=1;
    cin>>n;
    Node node[n]={0};
    for(int i=0;i<n;i++)
        cin>>node[i].a>>node[i].b;
    sort(node,node+n,cmp);
    int m=node[0].b;
    for(int i=0;i<n;i++){
        if(node[i].a>=m){
            m=node[i].b;
            sum++;
        }
    }
    cout<<sum;
    return 0;
}

*/

/*
P1808 单词分类

题目描述

Oliver为了学好英语决定苦背单词，但很快他发现要直接记住杂乱无章的单词非常困难，他决定对单词进行分类。

两个单词可以分为一类当且仅当组成这两个单词的各个字母的数量均相等。

例如“AABAC”，它和“CBAAA”就可以归为一类，而和“AAABB”就不是一类。

现在Oliver有N个单词，所有单词均由大写字母组成，每个单词的长度不超过100。你要告诉Oliver这些单词会被分成几类。
输入格式

输入文件的第一行为单词个数N，以下N行每行为一个单词。
输出格式

输出文件仅包含一个数，表示这N个单词分成的类数
输入输出样例
输入 #1

3 
AABAC 
CBAAA 
AAABB

输出 #1

2

说明/提示

对于70%的数据满足N≤100。 对于100%的数据满足N≤10000。

code:
int main(){//stl string用法 begin end unique
    int n,i;
    cin>>n;
    string in[n];
    for(i=0;i<n;i++){
        cin>>in[i];
        sort(in[i].begin(),in[i].end());//字符串首地址 字符串尾地址 排序
    }
    sort(in,in+n);
    n=unique(in,in+n)-in;//去重的尾地址 - 首地址变长度
    cout<<n<<endl;
    return 0;
}

*/

/*
P1824 进击的奶牛

题目描述

Farmer John建造了一个有N(2<=N<=100,000)个隔间的牛棚，这些隔间分布在一条直线上，坐标是x1,...,xN (0<=xi<=1,000,000,000)。

他的C(2<=C<=N)头牛不满于隔间的位置分布，它们为牛棚里其他的牛的存在而愤怒。为了防止牛之间的互相打斗，Farmer John想把这些牛安置在指定的隔间，所有牛中相邻两头的最近距离越大越好。那么，这个最大的最近距离是多少呢？
输入格式

第1行：两个用空格隔开的数字N和C。

第2~N+1行：每行一个整数，表示每个隔间的坐标。
输出格式

输出只有一行，即相邻两头牛最大的最近距离。
输入输出样例
输入 #1

5 3
1 
2 
8 
4 
9 
 
输出 #1

3

code:
int a[1000000],n,m,l=0,r=1e9;
bool check(int mid){
    int cnt=0,last=-(1<<30);
    for(int i=0;i<n;i++)
        if(a[i]-last>=mid)
            cnt++,last=a[i];
    return cnt>=m;
}
int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++)
        cin>>a[i];
    sort(a,a+n);
    while(l<r){
        int mid=(l+r+1)>>1;
        if(check(mid))l=mid;
        else r=mid-1;
    }
    cout<<l;
    return 0;
}

*/

/*
P1827 [USACO3.4]美国血统 American Heritage

题目描述

农夫约翰非常认真地对待他的奶牛们的血统。然而他不是一个真正优秀的记帐员。他把他的奶牛 们的家谱作成二叉树，并且把二叉树以更线性的“树的中序遍历”和“树的前序遍历”的符号加以记录而 不是用图形的方法。

你的任务是在被给予奶牛家谱的“树中序遍历”和“树前序遍历”的符号后，创建奶牛家谱的“树的 后序遍历”的符号。每一头奶牛的姓名被译为一个唯一的字母。（你可能已经知道你可以在知道树的两 种遍历以后可以经常地重建这棵树。）显然，这里的树不会有多于 26 个的顶点。 这是在样例输入和 样例输出中的树的图形表达方式：

　　　　　　　　 C
　　　　　　   /  \
　　　　　　  /　　\
　　　　　　 B　　  G
　　　　　　/ \　　/
　　　　   A   D  H
　　　　　　  / \
　　　　　　 E   F

树的中序遍历是按照左子树，根，右子树的顺序访问节点。

树的前序遍历是按照根，左子树，右子树的顺序访问节点。

树的后序遍历是按照左子树，右子树，根的顺序访问节点。
输入格式

第一行： 树的中序遍历

第二行： 同样的树的前序遍历
输出格式

单独的一行表示该树的后序遍历。
输入输出样例
输入 #1

ABEDFCHG
CBADEFGH 

输出 #1

AEFDBHGC

说明/提示

题目翻译来自NOCOW。

USACO Training Section 3.4

code:
string a,b;
void dfs(int l1,int l2,int l3,int l4){
    if(l1>l2||l3>l4)return;
    for(int i=l1;i<=l2;i++)
        if(a[i]==b[l3]){
            dfs(l1,i-1,l3+1,l3+i-l1);
            dfs(i+1,l2,l3+i-l1+1,l4);
            cout<<a[i];
        }
}
int main(){//二叉树的拆分
    cin>>a>>b;
    dfs(0,a.size()-1,0,a.size()-1);
    return 0;
}

*/

/*
P1832 A+B Problem（再升级）

题目背景

・题目名称是吸引你点进来的

・实际上该题还是很水的
题目描述

・1+1=? 显然是2

・a+b=? 1001回看不谢

・哥德巴赫猜想 似乎已呈泛滥趋势

・以上纯属个人吐槽

・给定一个正整数n，求将其分解成若干个素数之和的方案总数。
输入格式

一行：一个正整数n
输出格式

一行：一个整数表示方案总数
输入输出样例
输入 #1

7

输出 #1

3

说明/提示

【样例解释】

7=7 7=2+5

7=2+2+3

【福利数据】

【输入】 20

【输出】 26

【数据范围及约定】

对于30%的数据 1<=n<=10

对于100%的数据，1<=n<=10^3

code:
int sushu(int x,int* a){
    bool flag[x+1]={0};
    for(int i=2;i<=x;i++)
        if (!flag[i])
            for(int j=i*2;j<=x;j+=i)
                flag[j]=1;
    int k=0;
    for(int i=2;i<=x;i++)    
        if (!flag[i]) 
            a[++k]=i;
    return k;
}
int main(){
    int n;
    cin>>n;
    int a[n+1]={0};
    long long dp[n+1]={0};
    dp[0]=1;
    for(int i=1;i<=sushu(n,a);i++)
        for(int j=a[i];j<=n;j++) 
            dp[j]+=dp[j-a[i]];
    cout<<dp[n];
}

*/

/*
P1847 轰炸II

题目描述

一个城市遭到了 MMM 次轰炸，每次都炸了一个每条边都与边界平行的矩形。

在轰炸后，有 NNN 个关键点，指挥官想知道，它们有没有受到过轰炸，如果有，被炸了几次，最后一次是第几轮。
输入格式

第一行，两个整数：M,NM,NM,N。

以下 MMM 行，每行四个整数：x1x_1x1?、y1y_1y1?、x2x_2x2?、y2y_2y2?，表示被轰炸的矩形的左上角坐标和右下角坐标（比如1 3 7 10就表示被轰炸的地方是从(1,3)(1,3)(1,3)到(7,10)(7,10)(7,10) 的矩形）。

再以下 NNN 行，每行两个整数，表示这个关键点的坐标。
输出格式

共 NNN 行，

每行第一个字符为 YES 或 NO，表示是否被轰炸，若为 YES，在一个空格后为两个整数，表示被炸了几次和最后一次是第几轮。
输入输出样例
输入 #1

1 1 
1 1 10 10
11 11

输出 #1

NO

说明/提示

1≤N,M≤20001 \le N,M\le 20001≤N,M≤2000

1<=x1,y1,x2,y2<=232?11<=x_1,y_1,x_2,y_2<=2^{32}-11<=x1?,y1?,x2?,y2?<=232?1

code:
int main(){//模拟
    int m,n,xi,yi,sum=0,num=0;cin>>m>>n;
    long long x1[m],y1[m],x2[m],y2[m];
    for(int i=0;i<m;i++)
        cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];
    //思考:事先排序后再模拟是否会增加效率？
    for(int i=0;i<n;i++){
        cin>>xi>>yi;
        sum=0;
        for(int j=0;j<m;j++){
            if(xi>=x1[j] && xi<=x2[j] && yi>=y1[j] && yi<=y2[j]){
                sum++;
                num=j+1;
            }
        }
        if(sum)cout<<"YES "<<sum<<" "<<num<<endl;
        else cout<<"NO"<<endl;
    }
}

*/

/*
P1855 榨取kkksc03

题目描述

洛谷 2 的团队功能是其他任何 OJ 和工具难以达到的。借助洛谷强大的服务器资源，任何学校都可以在洛谷上零成本的搭建 OJ 并高效率的完成训练计划。

为什么说是搭建 OJ 呢？为什么高效呢？

因为，你可以上传私有题目，团队外别人是无法看到的。我们还能帮你们评测！

你可以创建作业，给组员布置任务，查看组员的完成情况，还可以点评任意一份代码！

你可以创建比赛！既可以是 OI 赛制还可以是 ICPC 赛制！既可以是团队内部的私有比赛，也可以公开赛，甚至可以指定谁可以参加比赛。这样，搞“x 校联赛”最合适不过了。洛谷凭借这个功能，希望能够提供公开及私有比赛的另外一个平台。

值得说明的是，本次比赛就是采用团队私有题目+邀请比赛的机制。

洛谷的运营组决定，如果一名 OIer 向他的教练推荐洛谷，并能够成功的使用（成功使用的定义是：该团队有 202020 个或以上的成员，上传 101010 道以上的私有题目，布置过一次作业并成功举办过一次公开比赛），那么他可以浪费掉 kkksc03 的一些时间的同时消耗掉 kkksc03 的一些金钱以满足自己的一个愿望。

kkksc03 的时间和金钱是有限的，所以他很难满足所有同学的愿望。所以他想知道在自己的能力范围内，最多可以完成多少同学的愿望？
输入格式

第一行三个整数 n,M,Tn,M,Tn,M,T，表示一共有 nnn（1≤n≤1001 \le n \le 1001≤n≤100）个愿望， kkksc03 的手上还剩 MMM（0≤M≤2000 \le M \le 2000≤M≤200）元，他的暑假有 TTT（0≤T≤2000 \le T \le 2000≤T≤200）分钟时间。

第 222~n+1n+1n+1 行 mim_{i}mi? , tit_{i}ti? 表示第 iii 个愿望所需要的金钱和时间。
输出格式

一行，一个数，表示 kkksc03 最多可以实现愿望的个数。
输入输出样例
输入 #1

6 10 10
1 1
2 3 
3 2
2 5
5 2
4 3

输出 #1

4

code:
int main(){//二维dp
    int n,M,T;
    scanf("%d%d%d",&n,&M,&T);
    int m[n+1],t[n+1],dp[M+1][1000]={0};
    for(int i=1;i<=n;i++){
        scanf("%d%d",&m[i],&t[i]);
        for(int j=M;j>=m[i];j--)
            for(int k=T;k>=t[i];k--)
                dp[j][k]=max(dp[j][k],dp[j-m[i]][k-t[i]]+1);
    }
    printf("%d\n",dp[M][T]);
}

*/

/*
P1862 输油管道问题

题目背景

听说最近石油危机

所以想到了这题
题目描述

某石油公司计划建造一条由东向西的主要输油管道。该管道要穿过一个有n口油井的油田。从每口油井都要有一条输油管道沿最短路径（或南或北）与主管道相连。如果给定n口油井的位置，及它们的x坐标（东西向）和y坐标（南北向），应如何确定主管道的最优位置，即使各油井到主管道之间的输油管道长度总和最小的位置？证明可规定时间内确定主管道的最优位置。
输入格式

第一行是油井数n（1<=n<=10000）

接下来n行是油井的位置,每行2个整数x和y(-10000<=x,y<=10000)
输出格式

只有一行

是油井到主管道之间的输油管道最小长度总和
输入输出样例
输入 #1

5
1 2
2 2
1 3
3 -2
3 3

输出 #1

6

code:
int main(){
	int n,tmp,mid,sum=0;
	cin>>n;
    int y[n];
	for(int i=0;i<n;i++)
		cin>>tmp>>y[i];
	sort(y,y+n);
	if(n%2==1)mid=y[(n)/2];
	else mid=(y[n/2]+y[n/2-1])/2;
	for(int i=0;i<n;i++)
		sum+=abs(y[i]-mid);
	cout<<sum<<endl;
	return 0;
}

*/

/*
P1866 编号

题目描述

太郎有N只兔子，现在为了方便识别它们，太郎要给他们编号。兔子们向太郎表达了它们对号码的喜好，每个兔子i想要一个整数，介于1和Maxnumber[i]之间（包括1和Maxnumber[i]）。当然，每个兔子的编号是不同的。现在太郎想知道一共有多少种编号的方法。

你只用输出答案mod 1000000007即可。如果这是不可能的，就输出0.
输入格式

第一行是一个整数N。（1≤N≤50）

第二行N个整数Maxnumber[i]。（1≤Maxnumber[i]≤1000）
输出格式

一个整数
输入输出样例
输入 #1

2
5 8

输出 #1

35

code:
int main(){
    int n,i;
    long long ans=1; 
    cin>>n;
    int maxnumber[n+1]={0};
    for(i=0;i<n;i++)cin>>maxnumber[i];
    sort(maxnumber,maxnumber+n);
    for(i=0;i<n;i++){
        ans*=(maxnumber[i]-i); 
        ans%=1000000007;
    }
    cout<<ans<<endl; return 0;
}

*/

/*
P1870 公交车

题目描述

某城市有个能容纳n辆公交车的停车场。每一天，这些公交车都要一辆一辆依次有序离开停车库去另一个终点站。这终点站距离停车场有d米的路程。当然第i辆公交车离开停车场的时间是ti秒，并以最大速度不超过vi米/秒行驶，加速度最大值为a。一辆公交车能瞬间减速，也能瞬间改变它的加速度。当然每辆车的最大加速度都一样为a。

不管有多大的马力，一辆公交车都不能超过其他另外的公交车，如果一辆公交车追上另一辆公交车，那么后面追上的车跟前面被追的车一起并排行驶同时到达终点站。当然司机都是尽可能快的驾车到达终点站的。

座位公交公司老板的你，希望每辆公交车都尽可能快的到达终点站。当然，公交车到达终点站时，速度可以没必要达到0。当一辆公交车离开停车场时，它的起始速度等于零。通过物理的观点解释的话，公交车可以看成是抽象的一个物体而已，除了能加速和减速，其他对速度的影响都可以忽略掉。
输入格式

第一行三个空格隔开的整数n,a,d(1<=n<=10^5,1<=a,d<=10^6)，分别表示公交车的数量，最大加速度。离终点站的距离。

接下来n行，每行有一对整数ti,vi(0<=t1<t2…<tn-1<tn<=10^6,1<=vi<=10^6)，分别表示每辆车离开停车场的时刻和能够行驶的最大速度。
输出格式

输出每辆公交车到达终点站的时刻。一行表示一辆公交车的到达时刻，输出时刻的公交车顺序按照输入的公交车顺序。输出答案的相对或绝对误差不能超过10^(-4)（即截尾保留4位小数）。
输入输出样例
输入 #1

3 10 10000

0 10

5 11

1000 1

输出 #1

1000.5000

1000.5000

11000.0500

说明/提示

【样例解释】

第2辆公交车能追上第一辆公交车，在行驶到距离终点510.5公里处。然后还剩9489.5公里的路程，两辆车都以10公里/小时的速度，一起到达终点的，它们到达终点的时刻是1000.5秒，第三辆公交车不能赶上其他的公交车，他到达终点的时刻是11000.05秒。

code:
int main(){
	double n,a,x,y,v,t,maxn=0.0000;
	scanf("%lf %lf %lf",&n,&a,&x);
    for(int i=0;i<n;i++){
		scanf("%lf %lf",&t,&v);
		double ans = t;
		if(x <= v*v/(2*a))ans += sqrt(2*x / a);
		else ans += x/v+v/(2*a);
        maxn=ans=max(maxn,ans);
		ans=floor(ans*10000)/10000;
		printf("%0.4lf\n",ans); 
	}
}

*/

/*
P1877 [HAOI2012]音量调节

题目描述

一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都需要改变一次音量。在演出开始之前，他已经做好一个列表，里面写着每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。

音量用一个整数描述。输入文件中整数 beginLevelbeginLevelbeginLevel，代表吉他刚开始的音量，整数 maxLevelmaxLevelmaxLevel，代表吉他的最大音量。音量不能小于 000 也不能大于 maxLevelmaxLevelmaxLevel。输入中还给定了 nnn 个整数 c1,c2,c3,??,cnc_1,c_2,c_3,\cdots,c_nc1?,c2?,c3?,?,cn?，表示在第 iii 首歌开始之前吉他手想要改变的音量是多少。

吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。
输入格式

第一行依次为三个整数 nnn，beginLevelbeginLevelbeginLevel 和 maxLevelmaxLevelmaxLevel。

第二行依次为 nnn 个整数 c1,c2,c3,??,cnc_1,c_2,c_3,\cdots,c_nc1?,c2?,c3?,?,cn?。
输出格式

输出演奏最后一首歌的最大音量。如果吉他手无法避免音量低于 000 或者高于 maxLevelmaxLevelmaxLevel，输出 -1。
输入输出样例
输入 #1

3 5 10
5 3 7

输出 #1

10

说明/提示

1≤n≤501\le n\le 501≤n≤50，1≤ci≤maxLevel1\le c_i\le maxLevel1≤ci?≤maxLevel，1≤maxLevel≤10001\le maxLevel\le 10001≤maxLevel≤1000，0≤beginLevel≤maxLevel0\le beginLevel\le maxLevel0≤beginLevel≤maxLevel。

code:
int main(){
    int n,b,m;
	cin>>n>>b>>m;
    int f[n+1][1001]={0},c[n+1]={0};
	for(int i=1; i<=n; i++)cin>>c[i];
	f[0][b]=1;
	for(int i=1; i<=n; i++)
		for(int j=0; j<=m; j++){
			if(f[i-1][j]&&j+c[i]<=m)
				f[i][j+c[i]]=1;
			if(f[i-1][j]&&j-c[i]>=0)
				f[i][j-c[i]]=1;
		}
	for(int i=m; i>=0; i--)
		if(f[n][i]){
			cout<<i<<endl;
			return 0;
		}
	cout<<-1<<endl;;
	return 0;
}

*/

/*
P1881 绳子对折

题目描述

FJ 有一个长度为L（1<= L <= 10,000）的绳子。 这个绳子上有N（1 <= N <= 100）个结，包括两个端点。 FJ想将绳子对折，并使较短一边的绳子上的结与较长一边绳子上的结完全重合，如图所示：

找出FJ有多少种可行的折叠方案。
输入格式

第一行： 两个整数， N和L

第2至N+1行： 每一行包含一个整数表示一个结所在的位置，总有两个数为0和L
输出格式

第一行： 一个整数表示FJ可折叠的方案数。
输入输出样例
输入 #1

5 10

0 

10 

6 

2 

4

输出 #1

4

说明/提示

(可在1,2,3,8点处折叠)

code:
int n,l,p,r[20001],ans;
int main(){
	cin>>n>>l;
	for(int i=1;i<=n;i++)cin>>p,r[p*2]=1;
	for(int i=1;i<2*l;i++){
		int pd=1,s=0;
		while(i>=s&&i+s<=2*l){
			if(r[i-s]!=r[i+s])pd=0;
			s++;
		}
		ans+=pd;
	}
	cout<<ans;
	return 0;
}

*/

/*
P1885 Moo

题目描述

奶牛 Bessie 最近在学习字符串操作，它用如下的规则逐一的构造出新的字符串：

S(0)=S(0) =S(0)= moo

S(1)=S(0)+S(1) = S(0) +S(1)=S(0)+ m +++ ooo +S(0)=+ S(0) =+S(0)= moo +++ m +++ ooo +++ moo === moomooomoo

S(2)=S(1)+S(2) = S(1) +S(2)=S(1)+ m +++ oooo +S(1)=+ S(1) =+S(1)= moomooomoo +++ m +++ oooo +++ moomooomoo === moomooomoomoooomoomooomoo

…\dots…

Bessie 就这样产生字符串，直到最后产生的那个字符串长度不小于读入的整数 NNN 才停止。

通过上面观察，可以发现第 kkk 个字符串是由：第 k?1k-1k?1 个字符串 +++ m +++ (k+2(k+2(k+2 个 o)+o) +o)+ 第 k?1k-1k?1 个字符串连接起来的。

现在的问题是：给出一个整数 N(1≤N≤109)N (1 \leq N \leq 10^9)N(1≤N≤109)，问第 NNN 个字符是字母 m 还是 o？
输入格式

一个正整数 NNN。
输出格式

一个字符，m 或者 o。
输入输出样例
输入 #1

11

输出 #1

m

说明/提示

样例解释：

由题目所知：字符串 S(0)S(0)S(0) 是 moo, 现在要求第 111111 个字符，显然字符串 S(0)S(0)S(0) 不够长；

同样 S(1)S(1)S(1) 的长度是 101010，也不够长；S(2)S(2)S(2) 的长度是 252525，够长了，S(2)S(2)S(2) 的第 111111 个字符是 m，所以答案就输出 m。

code:
int main(){
    int n,t=0,k=2;cin>>n;
    int m=n;
	while(t<=n) 
        t=t*2+(++k);
	while(t>0){
		t=(t-k)/2;
		if(m>t)
			if(m<=t+k)
				if(m==t+1) return printf("m"),0;
				else printf("o"),0;
			else m=m-(t+k);
		k--;
	}
	return 0;
}

*/

/*
P1889 士兵站队

题目描述

在一个划分成网格的操场上， nnn 个士兵散乱地站在网格点上，由整数坐标 (x,y)(x,y)(x,y) 表示。

士兵们可以沿网格边上、下左右移动一步，但在同时刻任一网格点上只能有名士兵。

按照军官的命令，们要整齐地列成个水平队列，即排成 队列，即排成 (x,y),(x+1,y),…,(x+n?1,y)(x,y),(x+1,y), …,(x+n-1,y)(x,y),(x+1,y),…,(x+n?1,y)。请求出如何选择 xxx 和 yyy 的值才能使士兵们以最少的总移动步数排成一列。
输入格式

输入的第一行是一个整数，代表士兵数 nnn。

第 222 到 (n+1)(n + 1)(n+1) 行，每行 222 个整数，第 (i+1)(i + 1)(i+1) 行的整数 xi,yix_i, y_ixi?,yi? 代表第 iii 个士兵的坐标。
输出格式

输出一行一个整数，代表答案。
输入输出样例
输入 #1

5
1 2
2 2
1 3
3 -2
3 3

输出 #1

8

说明/提示

对于 100%100\%100% 的数据，保证 1≤n≤100001 \leq n \leq 100001≤n≤10000，?10000≤x,y≤10000-10000 \leq x,y \leq 10000?10000≤x,y≤10000。

code:
int main(){
    int n,ans=0,rx,ry;
    cin>>n;
    int x[n],y[n];
	for(int i=0;i<n;i++) 
        cin>>x[i]>>y[i];
	sort(x,x+n); 
    sort(y,y+n);
	for(int i=0;i<n;i++) 
        x[i]=x[i]-i-1;
	sort(x,x+n);
	if(n%2)rx=x[n/2],ry=y[n/2];
	else rx=(x[n/2-1]+x[n/2])/2,ry=(y[n/2-1]+y[n/2])/2;
	for(int i=0;i<n;i++) 
        ans+=abs(x[i]-rx)+abs(y[i]-ry);
    cout<<ans;
	return 0;
}

*/

/*
P1893 山峰磐

题目描述

一天，Bessie在眺望美丽的威斯康星的群山的时候，她突然产生了疑问：那座山是最宽的？

她决定在地平线上，利用她的新式大量程山峰高度测量仪依次做N (1 <= N <= 10,000)次高度测量，每次的高度值为H_i (1 <= H_i <= 1,000,000,000)。

一座山定义为一段连续的高度序列，序列中的高度一开始单调上升（或者不变），然后单调下降（或者不变）。举例来说，2, 3, 3, 5, 4, 4, 1这一段高度序列就是一座山。如果在她的视线范围内有一段单调上升或者单调下降的序列，也算是一座山。注意，两座山之间可能会有部分重叠。

山的宽度定义为在这个山上进行的测量的次数（也就是序列的长度）。例如序列2, 3, 3, 5, 4, 4, 1的宽度为7。

请帮Bessie找到最宽的山。

下图是一个比较典型的的例子：

******* *

*********** ********* *

* ***************** *********** *** *

** ******************* ************* * * ******* * 山的形状

3211112333677777776543332111112344456765432111212111112343232111111211 高度值

aaaaa cccccccccccccccccccc eeeeeee ggggggggg

bbbbbbbbbbbbbbbbbbbbbbbbbbbb ddddd ffffffffff hhhhhhhhh 山的编号

山标记为'a', 'b'等等。显然，山b有着最大的宽度，宽度为28。
输入格式

第1行: 一个单独的整数: N

第2到第N+1行: 第i+1行包含一个单独的整数: H_i
输出格式

第1行: 一个单独的整数，表示最宽的山的宽度。
输入输出样例
输入 #1

7

3

2

3

5

4

1

6

输出 #1

5

说明/提示

[样例说明]

在最宽的山处测量到的高度为2, 3, 5, 4, 1. 其他的山包括3, 2和1, 6。

提示：

如果你知道一座山的最高的部分（也就是山峰），你会发现，找到这座山的宽度是很容易的哦。

code:
int main(){
    int n,ans,left,right;
    cin>>n;
    long long a[n+1];
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=1;i<=n;i++){
        left=i;
        right=i;
        while(a[left-1]<=a[left] && 1<left)
            left--;
        while(a[right+1]<=a[right] && right<n)
            right++;
        ans=max(ans,right-left+1);
    }
    cout<<ans;
}

*/

/*
P1898 缘分计算

题目描述

缘分是一个外国人难以理解的中文名词。大致说来，缘分是一种冥冥中将两人（通常是情人）结合的力量。仅管这是种迷信，很多人――特别是女生――喜欢去计算它。

不幸的是，644 也是这样。有天，她问 DL：“甜心，可以算一下我们的缘分吗？”唉， DL 真的很讨厌这问题，但他无法拒绝。还好， DL 是个程序设计师，所以他只要找到一个看来不错的算法并写成一个缘分计算器就可以了。在网络上搜寻了几个小时后，他决定采用以下的缘分算法：

第一步： 取出姓名的缩写（abbreviation）并接在一起。例如，如果这对恋人叫 Jiang Yun Fan 和 Tang Yu Rou，他们的缩写就是 JYFTYR。第二步： 将每个字母用数字字符串取代。用 ST 来取代 A， ST+1 来取代 B， ST+2 来取代 C，……， ST+25 来取代 Z，其中 ST 为一个已知的正整数。例如，如果ST=81，A 就被 81 取代，B 就被 82 取代，……，Z 则被 106 取代。上面的例子JYFTYR 则被 901058610010598 取代。

第三步：重复以下操作：将相邻的两位数相加，并写下和的个位数。不难发现这个操作每进行一次，这个数字字符串就会少一位数。当这个数字变成 100 或不超过两位数（第一位是 0 也算两位数）时，这个程序便停止。所得的数字就是两人的缘分。用上面的例子来说，处理的过程如下：

901058610010598

91153471011547

0268718112691

…… 374 01

所以如果 ST=81，Jiang Yun Fan 和 Tang Yu Rou 的缘分便只有 1。

惨了！ DL 很了解 644。他知道即使这个程序计算出的缘分高达 99 她仍然会不高兴。更何况 644 还对其余很多对恋人间的缘分感兴趣，要是他一个个计算会太繁琐。如果告诉你一对恋人的姓名和一个 ST 值，你能编一个程序算出他们的缘分吗？
输入格式

输入文件名为 calcYF.in。

第一行包含一个仅含大写字母且长度为 L 的字符串。

第二行包含一个正整数 ST，含义如题目所述。
输出格式

输出文件名为 calcYF.out。

仅一行，包含一个整数，表示两人的缘分。
输入输出样例
输入 #1

DLLSS
478

输出 #1

100

说明/提示

【数据范围】

对于 100%的数据，4 ≤ L ≤ 10，1 ≤ ST ≤ 10000。

【NOTICE】

Don't be sad if the result of you and your sweetie is not 100. That's no big deal.

code:
int main(){
    string s;cin>>s;
    int st,len=s.size(),a[len+1],k[100001],p=0;
    cin>>st;
    for(int i=0;i<len;i++)
        a[i+1]=s[i]-65+st;
    for(int i=len;i>=1;i--)
        while(a[i])
            p++,k[p]=a[i]%10,a[i]=a[i]/10;
    for(int i=p-1;i>=3;i--)
        for(int j=1;j<=i;j++)
            k[j]=(k[j]+k[j+1])%10;
    if(k[1]==0 && k[2]==0 && k[3]==1)cout<<100;
    else if((k[2]+k[3])%10!=0)cout<<(k[2]+k[3])%10<<(k[1]+k[2])%10;
    else cout<<(k[1]+k[2])%10;
}

*/

/*
P1904 天际线

题目描述

Latium 省的 Genoa 是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官 Caesar 的委任，前往 Genoa 建立新的城市。Caesar 对这次任务的要求是在 Genoa 这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。

正在你大刀阔斧地进行城市建设的时候，Caesar 突然写信给你，说他要检查 Genoa 的建设情况。Caesar 希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。

怎样描述一个城市的轮廓呢？我们知道 Genoa 所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组 (Li,Hi,Ri)(L_i,H_i,R_i)(Li?,Hi?,Ri?)，其中 LiL_iLi? 和 RiR_iRi? 分别是建筑的左坐标和右坐标，HiH_iHi? 就是建筑的高度。在下方所示的图表中左边建筑物描述如下 (1,11,5)(1,11,5)(1,11,5)，(2,6,7)(2,6,7)(2,6,7)，(3,13,9)(3,13,9)(3,13,9)，(12,7,16)(12,7,16)(12,7,16)，(14,3,25)(14,3,25)(14,3,25)，(19,18,22)(19,18,22)(19,18,22)，(23,13,29)(23,13,29)(23,13,29)，(24,4,28)(24,4,28)(24,4,28)，右边用轮廓线的顺序(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0) 表示：

输入格式

在输入数据中，你将得到一系列表示建筑的三元组。在输入数据中所有建筑的坐标中的数值都是小于 100001000010000 的正整数，且至少有 111 幢建筑，最多有 500050005000 幢建筑。在输入输入中每幢建筑的三元组各占一行。三元组中的所有整数应由一个或多个空格分开。
输出格式

在输出数据中，你被要求给出城市的轮廓线。你可以这样来描述：对于所有轮廓线上的折点，按顺序排好，第奇数个点输出 xxx 坐标，第偶数个点输出 yyy 坐标，两个数之间用空格分开。
输入输出样例
输入 #1

1 11 5
2 6 7
3 13 9
12 7 16
14 3 25
19 18 22
23 13 29
24 4 28

输出 #1

1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0

code:
int maxh[20003];
int main() {
	int l,h,r,L=10001,R=0;
	while(scanf("%d%d%d",&l,&h,&r)!=EOF) {
		L=min(L,l);
		R=max(R,r);
		for(int i=l;i<=r;i++) {
			maxh[i*2]=max(maxh[i*2],h);
			if(i<r)maxh[i*2|1]=max(maxh[i*2|1],h);
		} 
	}
	for(int i=L;i<=R;i++) {
		if(maxh[i*2]!=maxh[(i*2)-1]) 
            cout<<i<<" "<<maxh[i*2]<<" ";
		if(maxh[i*2]!=maxh[i*2|1]) 
            cout<<i<<" "<<maxh[i*2|1]<<" ";	
    }
}

*/

/*
P1910 L国的战斗之间谍

题目背景

L国即将与I国发动战争！！
题目描述

俗话说的好：“知己知彼，百战不殆”。L国的指挥官想派出间谍前往I国，于是，选人工作就落到了你身上。

你现在有N个人选，每个人都有这样一些数据：A（能得到多少资料）、B（伪装能力有多差）、C（要多少工资）。已知敌人的探查间谍能力为M（即去的所有人B的和要小于等于M）和手头有X元钱，请问能拿到多少资料？
输入格式

N M X

A1 B1 C1

A2 B2 C2

………………

AN BN CN
输出格式

能得到的资料总数
输入输出样例
输入 #1

3 10 12
10 1 11
1 9 1
7 10 12

输出 #1

11

说明/提示

数据范围：

1≤n≤100,1≤m≤1000, 1≤x≤1000

code:
int f[1010][1010];
int main(){//dp
    int n,m,x,a,b,c,j;
    cin>>n>>m>>x;
    for(int i=1;i<=n;i++)
        for(j=m,cin>>a>>b>>c;j>=b;j--)
            for(int k=x;k>=c;k--)
                f[j][k]=max(f[j][k],f[j-b][k-c]+a);
    cout<<f[m][x];
    return 0;
}

*/

/*
P1913 L国的战斗之伞兵

题目背景

L国即将与I国发动战争！！
题目描述

为了在敌国渗透作战，指挥官决定：派出伞兵前往敌国！然而敌国的风十分强烈，能让伞兵在同一高度不停转悠，直到被刮到一个无风区……（可怜的小兵）
输入格式

第一行：n、m两个正整数，表示敌国的大小。

以下n行，每行m个字符，“u”表示风向北吹；“d”表示风向南吹；“l”表示风向西吹；“r”表示风向东吹；“o”表示无风。（上北下南，左西右东)
输出格式

一个数：表示有几个点可以放下伞兵。
输入输出样例
输入 #1

5 5
rrrrr
rdddr
rroll
uuuuu
uuuuu

输出 #1

19

说明/提示

数据范围：

1≤n≤1000,1≤m≤1000.

code:
int n,m,num;
char a[1001][1001];
bool b[1001][1001];
void dt(int i,int j){
    b[i][j]=true;
    if(a[i+1][j]=='u') dt(i+1,j);
    if(a[i-1][j]=='d') dt(i-1,j);
    if(a[i][j+1]=='l') dt(i,j+1);
    if(a[i][j-1]=='r') dt(i,j-1);
}
int main(){
    cin>>n>>m;
    for(int i=0;i<n;i++) 
        for(int j=0;j<m;j++) 
            cin>>a[i][j];
    for(int i=0;i<n;i++) 
        for(int j=0;j<m;j++)
            if(a[i][j]=='o') 
                dt(i,j);
    for(int i=0;i<n;i++) 
        for(int j=0;j<m;j++) 
            if(b[i][j]) 
                num++;
    cout<<num;
    return 0;   
}

*/

/*
P1918 保龄球

题目描述

DL 算缘分算得很烦闷，所以常常到体育馆去打保龄球解闷。因为他保龄球已经打了几十年了，所以技术上不成问题，于是他就想玩点新花招。

DL 的视力真的很不错，竟然能够数清楚在他前方十米左右每个位置的瓶子的数量。他突然发现这是一个炫耀自己好视力的借口――他看清远方瓶子的个数后从某个位置发球，这样就能打倒一定数量的瓶子。

1 OOO

2 OOOO

3 O

4 OO

如上图，每个“O”代表一个瓶子。如果 DL 想要打倒 3 个瓶子就在 1 位置发球，想要打倒 4 个瓶子就在 2 位置发球。

现在他想要打倒 m 个瓶子。他告诉你每个位置的瓶子数，请你给他一个发球位置。
输入格式

输入文件名为 bowling.in。

第一行包含一个正整数 n，表示位置数。

第二行包含 n 个正整数，第 i 个数。表示第 i 个位置的瓶子数，保证各个位置的瓶子数不同。

第三行包含一个正整数 Q，表示 DL 发球的次数。

第四行至文件末尾，每行包含一个正整数 m，表示 DL 需要打倒 m 个瓶子。
输出格式

输出文件名为 bowling.out。

共 Q 行。每行包含一个整数，第 i 行的整数表示 DL 第 i 次的发球位置。若无解，则输出 0。
输入输出样例
输入 #1

5
1 2 4 3 5
2
4
7

输出 #1

3
0

说明/提示

【数据范围】

对于 50%的数据，1 ≤ n,Q ≤ 1000，1 ≤ai,M ≤ 10^5

对于 100%的数据，1 ≤ n,Q ≤ 100000，1 ≤ai,M ≤ 10^9

code:
int main(){//stl中map的映射用法
    map <int,int> ma;
    int n,m;
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>m,ma[m]=i+1;
    cin>>n;
    for(int i=0;i<n;i++)
        cin>>m,cout<<ma[m]<<endl;
}

*/

/*
P1926 小书童――刷题大军

题目背景

数学是火，点亮物理的灯；物理是灯，照亮化学的路；化学是路，通向生物的坑；生物是坑，埋葬学理的人。 文言是火，点亮历史宫灯；历史是灯，照亮社会之路；社会是路，通向哲学大坑；哲学是坑，埋葬文科生。――小A
题目描述

小A“刷题”十分猖狂，明目张胆地“刷题”。他现在在小书童里发现了n样他喜欢的“题目”，每“题”都有他的需要时间，而老师布置了m项作业，每项作业都有它的需要时间及分值，老师规定k分以上算及格。小A只剩r个单位时间，他想在及格的基础上更多地“刷题”。
输入格式

第一行：n m k r。第二行：n个数，代表每“题”他的需要时间。第三行：m个数。表示每项作业它的需要时间。第四行：m个数。代表每项作业它的分值。
输出格式

一个数，代表小A能刷几道题
输入输出样例
输入 #1

3 4 20 100
15 20 50
10 15 40 40
5 5 10 15

输出 #1

2

说明/提示

没有不能及格的情况

对于100%的数据，n≤10,m≤10,k≤50,r≤150n\le 10,m\le 10,k\le 50,r\le 150n≤10,m≤10,k≤50,r≤150

code:
int main(){//01背包
    int m,n,k,r,l,cnt=0;
	cin>>n>>m>>k>>r;
    int t[n+3],hw[m+3],scr[m+3],ans[999]={0};
	memset(ans,0,sizeof(ans));
	for(int i=1;i<=n;i++)
        cin>>t[i];
	for(int i=1;i<=m;i++)
        cin>>hw[i];
	for(int i=1;i<=m;i++)
        cin>>scr[i];
	for(int i=1;i<=n;i++)
		for(int j=r;j>=hw[i];j--)
			ans[j]=max(ans[j],ans[j-hw[i]]+scr[i]);
    for(int i=1;i<=r;i++)
        if(ans[i]>=k){
            l=r-i;
            break;
        }
	sort(t+1,t+n+1); 
    for(int i=1;i<=n;i++){
    	l-=t[i];
    	if(l<0)
            break;
        cnt++;
    }
	cout<<cnt;
	return 0;
}

*/

/*
P1927 防护伞

题目描述

据说 2012 的灾难和太阳黑子的爆发有关。于是地球防卫小队决定制造一个特殊防护 伞，挡住太阳黑子爆发的区域，减少其对地球的影响。由于太阳相对于地球来说实在是太 大了，我们可以把太阳表面看作一个平面，中心定为(0,0)。根据情报，在 2012 年时， 太阳表面上会产生 N 个黑子区域，每个黑子视为一个点。特殊防护伞可以看作一个巨大 的圆面，现在地球防卫小队决定将它的中心定位于某个黑子，然后用伞面挡住其他黑子。 因为制造防护伞的材料成本特别高，所以我们希望伞面尽可能的小。
输入格式

第一行：一个整数 N，表示黑子个数。

第 2 到 N-1 行：每行两个整数，表示黑子的坐标（x, y）。
输出格式

第一行：一个实数，表示伞的面积。
输入输出样例
输入 #1

3

0  1 

-8  -4 

-1  4 

输出 #1

279.6017

说明/提示

【数据范围】

对于 50%的数据： 2≤N≤100。

对于 100%的数据： 2≤N≤1000。

-10000≤x,y≤10000。

【注意】

精确到小数点后 4 位

π=3.1415926535

code:
struct stu{
    int x,y;
};
int main(){
    int n,now,ans=(1<<30);
    cin>>n;
    stu s[n];
    for(int i=0;i<n;i++)
        cin>>s[i].x>>s[i].y;
    for(int i=0;i<n;i++){
        now=0;
        for(int j=0;j<n;j++)
            (i==j)?1:now=max(now,(s[i].x-s[j].x)*(s[i].x-s[j].x)+(s[i].y-s[j].y)*(s[i].y-s[j].y));
        ans=min(ans,now);
    }
    printf("%.4lf",(double)ans*3.1415926535);
    return 0;
}


*/

/*
P1936 水晶灯火灵

题目背景

《爱与愁的故事第五弹・Halloween》第二章。

题目容易吐血请谨慎阅读！
题目描述

爱与愁大神兴高采烈地踏出妖精系道馆――他已经获得了妖精系徽章（鼓掌）！可是一出门就遇到一群パンプジン（Because today is Halloween）！仲谋半？没事，爱与愁大神手上还仅存着一只水晶灯火灵（完克パンプジン）。或许是因为这是爱与愁大神存活的最后一只精灵，水晶灯火灵十分振奋，一击打垮了一群パンプジン。水晶灯火灵使用了一招***（被打上了马赛克？！），刚好符合以下③条规则：

①m,n∈{1,2,??,k}m,n \in \{1,2,\cdots ,k\}m,n∈{1,2,?,k}

②(n2?m×n?m2)2=1(n^2-m\times n-m^2)^2=1(n2?m×n?m2)2=1

③m,nm,nm,n为整数。

Ai Yuchou God was very happy,he wants to know m?+n? how is the biggest.Can you help him?Please output m and n.（以上翻译失败，造成许多不便请谅解）
输入格式

Only one:k。（What？还是失败？）
输出格式

共两行：第一行是m的最大值，第二行是n的最大值。（What？翻译成功了？）
输入输出样例
输入 #1

1995

输出 #1

m=987
n=1597

说明/提示

20%数据：k<=100

100%数据：k<=10^8

又是一道水题……

【广告】妈妈再也不用担心我的等级，任天堂游戏机！

code:
int main(){
    int k,m=1,n=1,o;
    cin>>k;
    while(m+n<=k){
        o=m+n;
        m=n;
        n=o;
    }
    cout<<"m="<<m<<endl<<"n="<<n;
    return 0;
}

*/

/*
P1947 猜数

题目背景

这是一道交互题。
题目描述

珂鄹了你一个 [1,n][1,n][1,n] 之间的整数 kkk，你每次可以询问一个整数 xxx，然后珂刍岣嫠吣 xxx 和 kkk 的大小关系。

你需要用尽可能少的次数猜出珂巯氲氖。

你需要实现一个函数 int Chtholly(int n,int c)，这个函数的作用是在不超过 ccc 次询问中猜对 [1,n][1,n][1,n] 中的一个数，返回值为你最终确定的数。

你可以调用交互库中一个叫做 Seniorious 的函数，其原型为 int Seniorious(int x)，返回值为：

    若 k<xk\lt xk<x，则返回 111。
    若 k>xk\gt xk>x，则返回 ?1-1?1。
    若 k=xk=xk=x，则返回 000。

你调用 Seniorious 函数的次数不超过 ccc 才能得到这个点的分数，否则这个点为 000 分。有关该函数的调用请参考【说明/提示】部分。

由于珂壑换嵝 C++ 语言的交互库，所以你只能使用 C++ 语言（包括 C++，C++11，C++14，C++17）来解决本题。
输入格式

样例输入中三个数分别为 n,c,kn,c,kn,c,k。这些数据你都无法读取。
输出格式

样例输出中第一个数是你猜的 kkk，第二个数是你调用 Seniorious 函数的次数。这些数据你不必输出。
输入输出样例
输入 #1

5 5 3

输出 #1

3 0

说明/提示
样例解释

你要猜的 kkk 为 333。

由于你和珂坌牧橄嗤ǎ所以在没有调用 Seniorious 的情况下就猜出来了。
数据规模与约定

    对于 30%30\%30% 的数据，保证 c=n?1c=n-1c=n?1。
    对于 100%100\%100% 的数据，保证 2≤n≤1062\leq n\leq 10^62≤n≤106，min?(20,n?1)≤c≤n\min(20,n-1)\leq c\leq nmin(20,n?1)≤c≤n。

提示

关于交互题。

样例交互库源代码链接。注意，此交互库仅供测试样例使用，实际评测时的交互库此交互库不同。

如果您不知道如何在本地调试您的代码，请参考这篇文章。

请特别注意，你的答案应该作为函数的返回值给出，你不需要，也不应该向标准输出输出任何内容，否则将无法获得分数。

如果有需要，你可以在选手程序的开头加入一些头文件，当然在本题中这并不是必须的。

交互库给出的函数 Seniorious 无法直接调用，需要在选手程序中用 extern "C" 关键字声明一次。

下面给出本题的模板程序

#include <cstdio>                         // 在本题中并不是必须的

extern "C" int Seniorious(int);           // 在这里需要声明一次交互库给出的函数。

extern "C" int Chtholly(int n, int OvO) { // 在这里实现交互库要求你实现的函数。
  int ans = 1;
  for (int l = 1, r = n, mid = (l + r) >> 1; l <= r; mid = (l + r) >> 1) if (Seniorious(mid) >= 0) {
    r = (ans = mid) - 1;
  } else {
    l = mid + 1;
  }
  return ans;
}

code://看不懂
extern "C" int Seniorious(int);
extern "C" int Chtholly(int n, int OvO){
	int l=1,r=n;
	while(r>l)	{
		int mid=(l+r)/2;
		int res=Seniorious(mid);
		if(res==0)return mid;
		if(res==1)r=mid-1;
		else l=mid+1;
	}
	return l;
}

*/

/*
P1957 口算练习题

题目描述

王老师正在教简单算术运算。细心的王老师收集了i道学生经常做错的口算题，并且想整理编写成一份练习。 编排这些题目是一件繁琐的事情，为此他想用计算机程序来提高工作效率。王老师希望尽量减少输入的工作量，比如5+8的算式最好只要输入5和8，输出的结果要尽量详细以方便后期排版的使用，比如对于上述输入进行处理后输出 5+8=13 以及该算式的总长度6。王老师把这个光荣的任务交给你，请你帮他编程实现以上功能。
输入格式

第一行为数值i

接着的i行为需要输入的算式，每行可能有三个数据或两个数据。

若该行为三个数据则第一个数据表示运算类型，a表示加法运算，b表示减法运算，c表示乘法运算，接着的两个数据表示参加运算的运算数。

若该行为两个数据，则表示本题的运算类型与上一题的运算类型相同，而这两个数据为运算数。
输出格式

输出2*i行。对于每个输入的算式，输出完整的运算式及结果，第二行输出该运算式的总长度
输入输出样例
输入 #1

4
a 64 46
275 125
c 11 99
b 46 64

输出 #1

64+46=110
9
275+125=400
11
11*99=1089
10
46-64=-18
9

说明/提示

数据规模与约定

0<i<=50

运算数为非负整数且小于10000

对于50%的数据，输入的算式都有三个数据，第一个算式一定有三个数据。

code:
int main(){
	char a,s[100],b[10];
    int n,c,d;
    cin>>n;
	while(n--){
		cin>>b;
        if(b[0]>='a' && b[0]<='z'){
			a=b[0];
            cin>>c>>d;
		}else{
			sscanf(b,"%d",&c);
            cin>>d;
        }
        if(a=='a')sprintf(s,"%d+%d=%d",c,d,c+d);
		else if(a=='b')sprintf(s,"%d-%d=%d",c,d,c-d);
		else if(a=='c')sprintf(s,"%d*%d=%d",c,d,c*d);
		cout<<s<<endl<<strlen(s)<<endl;
    }
	return 0;
}

*/

/*
P1958 上学路线

题目描述

你所在城市的街道好像一个棋盘，有a条南北方向的街道和b条东西方向的街道。南北方向的a条街道从西到东依次编号为l到a，而东西方向的b条街道从南到北依次编号为l到b，南北方向的街道i和东西方向的街道j的交点记为(i，j)。

你住在(1，1)处，而学校在(a，b)处，你骑自行车去上学，自行车只能沿着街道走，而且为了缩短时间只允许沿着向东和北的方向行驶。

现在有N个交叉路口在施工(X1，Yl)、(X2，Y2)……，(Xn，Yn)，这些路口是不能通车的。

问你上学一共有多少走法?
输入格式

第一行包含两个整数a和b，并且满足1≤a，b≤16。

第二行包含一个整数N，表示有N个路口在维修(1≤N≤40)。

接下来N行，每行两个整数X_i，Y_i，描述路口的位置。
输出格式

输出一个整数表示从(1，1)到(a，b)的行车路线总数。
输入输出样例
输入 #1

5 4
3
2  2
2  3
4  2

输出 #1

5

code:
int a,b,n,ans,x1,x2,s[20][20];
void dfs(int x,int y){//深搜
    if(x==a && y==b)ans++;
    else if(s[x][y]!=-1)dfs(x,y+1),dfs(x+1,y);
}
int main(){
    cin>>a>>b>>n;
    for(int i=1;i<=n;i++)
        cin>>x1>>x2,s[x1][x2]=-1;
    for(int i=1;i<=a;i++)s[i][b+1]=-1;
    for(int i=1;i<=b;i++)s[a+1][i]=-1;
    dfs(1,1);
    cout<<ans<<endl;
}

*/

/*
P1964 【mc生存】卖东西

题目背景

服务器好好玩
题目描述

lcy0x1去服务器的系统商店卖东西。

一个人的背包有21格。

一开始他的背包里有m件不同的物品（不能卖）。

他要卖n种物品，每种物品有ai件,价值bi,一格可以放ci个，

名字sti（0<sti的长度<100)

相同的物品可以放同一格(只要没放满）。

问他跑一次最多能卖多少钱。
输入格式

第一行m,n(0<=m<=21,0<=n<=100)；

下面n行 ai,bi,ci,sti(0<=ai<=1344,0<=bi<=10000,0<ci<=64)；
输出格式

最多卖的钱s(0<=s<=1000000)；
输入输出样例
输入 #1

20 3

63 1 64 yinshifen

1 10 1 men

1 1 64 yinshifen

输出 #1

64

说明/提示

多重背包

搜索0分！！！

强大的数据

code:
struct T{int mx,own,cost;};
map<string,T> mp;
vector<int> v;
set<string> st;
int space,n,m,ans,a,b,c;
string s;
int main(){//stl
	cin>>m>>n;
	space=21-m;
	for(int i=0;i<n;i++){
		cin>>a>>b>>c>>s;
		mp[s].own+=a,mp[s].cost=b,mp[s].mx=c;
		st.insert(s);
	}
	for(set<string>::iterator it=st.begin();it!=st.end();it++)
		while(mp[*it].own)
			v.push_back(min(mp[*it].own,mp[*it].mx)*mp[*it].cost),
			mp[*it].own=max(0,mp[*it].own-mp[*it].mx);
	sort(v.begin(),v.end());
	int END=max(0,(int)v.size()-space);
	for(int i=v.size()-1;i>=END;i--)
		ans+=v[i];
	cout<<ans;
	return 0;
}

*/

/*
P1968 美元汇率

题目背景

此处省略maxint+1个数
题目描述

在以后的若干天里戴维将学习美元与德国马克的汇率。编写程序帮助戴维何时应买或卖马克或美元，使他从100美元开始，最后能获得最高可能的价值。
输入格式

输入文件的第一行是一个自然数N，1≤N≤100，表示戴维学习汇率的天数。

接下来的N行中每行是一个自然数A，1≤A≤1000。第i+1行的A表示预先知道的第i+1天的平均汇率，在这一天中，戴维既能用100美元买A马克也能用A马克购买100美元。
输出格式

输出文件的第一行也是唯一的一行应输出要求的钱数(单位为美元，保留两位小数)。

注意：考虑到实数算术运算中进位的误差，结果在正确结果0.05美元范围内的被认为是正确的，戴维必须在最后一天结束之前将他的钱都换成美元。
输入输出样例
输入 #1

5
400
300
500
300
250

输出 #1

266.67

说明/提示

样例解释 (无需输出)

Day 1 ... changing 100.0000 美元= 400.0000 马克
Day 2 ... changing 400.0000 马克= 133.3333 美元
Day 3 ... changing 133.3333 美元= 666.6666 马克
Day 5 ... changing 666.6666 马克= 266.6666 美元

update：2017/08/18： 1样例正确答案为266.67

2已经把测试点1改成样例

3spj原先误差是0.01，按照题目要求，重新改为0.05

code:
int main(){//dp
    int n;
    cin>>n;
    int a[n+1];
    for(int i=1;i<=n;i++)
        cin>>a[i];
    double f[n+1][2];
    f[1][0]=100;
    f[1][1]=a[1];
    for(int i=2;i<=n;i++){
        f[i][0]=max(f[i-1][0],(f[i-1][1]/a[i])*100);
        f[i][1]=max(f[i-1][1],f[i-1][0]*a[i]/100);
    }
    printf("%.2f",max(f[n][0],(f[n][1]/a[n])*100));
    return 0;
}

*/

/*
P1969 [NOIP2013 提高组] 积木大赛

题目描述

春春幼儿园举办了一年一度的“积木大赛”。今年比赛的内容是搭建一座宽度为nnn的大厦，大厦可以看成由n块宽度为1的积木组成，第i块积木的最终高度需要是hih_ihi?。

在搭建开始之前，没有任何积木（可以看成nnn块高度为000的积木）。接下来每次操作，小朋友们可以选择一段连续区间[l,r][l, r][l,r]，然后将第第L L L块到第 RRR 块之间（含第L LL 块和第 RR R块）所有积木的高度分别增加111。

小M M M是个聪明的小朋友，她很快想出了建造大厦的最佳策略，使得建造所需的操作次数最少。但她不是一个勤于动手的孩子，所以想请你帮忙实现这个策略，并求出最少的操作次数。
输入格式

包含两行，第一行包含一个整数nnn，表示大厦的宽度。

第二行包含nnn个整数，第i个整数为hih_i hi?。
输出格式

建造所需的最少操作数。
输入输出样例
输入 #1

5
2 3 4 1 2

输出 #1

5

说明/提示

【样例解释】

其中一种可行的最佳方案，依次选择

[1,5][1,5][1,5] [1,3] [1,3][1,3] [2,3][2,3][2,3] [3,3][3,3][3,3] [5,5] [5,5][5,5]

【数据范围】

对于30% 30\%30%的数据，有1≤n≤101 ≤ n ≤ 101≤n≤10；

对于 70%70\%70%的数据，有1≤n≤10001 ≤ n ≤ 10001≤n≤1000；

对于 100%100\%100%的数据，有1≤n≤100000,0≤hi≤100001 ≤ n ≤ 100000,0 ≤ h_i≤ 100001≤n≤100000,0≤hi?≤10000。

code:
int main(){//数论升序作差
    int n,a,last=0,ans=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a;
        if(a>last)ans+=(a-last);
        last=a;
    }
    cout<<ans<<endl;
}

*/

/*
P1976 鸡蛋饼

题目背景

Czyzoiers 都想知道小 x 为什么对鸡蛋饼情有独钟。经过一番逼问，小 x 道出了实情：因为他喜欢圆。
题目描述

最近小 x 又发现了一个关于圆的有趣的问题：在圆上有 2N2N2N 个不同的点，小 x 想用 N 条线段把这些点连接起来（每个点只能连一条线段）， 使所有的线段都不相交，他想知道这样的连接方案有多少种？
输入格式

有且仅有一个正整数 N 。 （N≤2999N \le 2999N≤2999）
输出格式

要求的方案数（结果 ?mod?100000007\bmod 100000007mod100000007）。
输入输出样例
输入 #1

24

输出 #1

4057031

code:
int main(){
    int i,j,k,n;
    cin>>n;
    long long l[n+1]={0};
    l[0]=1;
    l[1]=1;
    for(i=2;i<=n;i++)
        for(j=0;j<=i-1;j++)
            l[i]=(l[j]*l[i-j-1]%100000007+l[i])%100000007;
    cout<<l[n];
}

*/

/*
P1981 [NOIP2013 普及组] 表达式求值

题目描述

给定一个只包含加法和乘法的算术表达式，请你编程计算表达式的值。
输入格式

一行，为需要你计算的表达式，表达式中只包含数字、加法运算符“+++”和乘法运算符“× \times ×”，且没有括号，所有参与运算的数字均为 000 到 231?12^{31}-1231?1 之间的整数。

输入数据保证这一行只有0?9 0-90?9、+++、× \times ×这 1212 12种字符。
输出格式

一个整数，表示这个表达式的值。

注意：当答案长度多于 444 位时，请只输出最后4 44 位，前导0 00 不输出。
输入输出样例
输入 #1

1+1*3+4

输出 #1

8

输入 #2

1+1234567890*1

输出 #2

7891

输入 #3

1+1000000003*1

输出 #3

4

说明/提示

对于 30%30\%30%的数据，0≤0≤0≤表达式中加法运算符和乘法运算符的总数≤100≤100≤100；

对于 80%80\%80%的数据，0≤0≤0≤表达式中加法运算符和乘法运算符的总数≤1000≤1000≤1000；

对于100%100\%100%的数据，0≤0≤0≤表达式中加法运算符和乘法运算符的总数≤100000≤100000≤100000。

code:
int main(){//注：只包含0~9 加乘法 因此除法和减法不合理
    long long shu,sum=0,n;
    char c=0,g;
    bool tf=1;
    while(tf){
        scanf("%lld",&shu);
        tf=(scanf("%c",&g)==1?1:0);
        if(c==0)n=shu;
        if(c=='+')sum=(sum+n)%10000,n=shu;
        else if(c=='*')n=(n*shu)%10000;
        if(!tf)sum=(sum+n)%10000;//在减法是情况下会不符合
        c=g;
    }
    cout<<sum;
    return 0;
}

*/

/*
P1994 有机物燃烧

题目背景

本来准备弄难点的，还是算了吧
题目描述

输入一种有机物，输出与氧气反应化学方程式中CO2和H2O的系数
输入格式

一行，一个字符串，表示有机物
输出格式

两个数，分别为CO2和H2O的系数
输入输出样例
输入 #1

C2H5OH

输出 #1

2 3

说明/提示

只含有C、H、O三种元素

code:
int main(){//化学有机物
    int a[100]={0},t,x;
    char c;
    while(scanf("%c",&c)!=EOF){
        t=scanf("%d",&x);
        if(t==1 && t!=EOF) a[c]+=x;
        else a[c]++;
    }
    if(a['H']%2!=0 || ((2*a['C']+a['H']/2-a['O'])%2!=0 && a['C']!=0))
        cout<<a['C']*2<<" "<<a['H']<<endl;
    else cout<<a['C']<<" "<<a['H']/2<<endl;
    return 0;
}

*/

/*
P1996 约瑟夫问题

题目描述

nnn 个人围成一圈，从第一个人开始报数,数到 mmm 的人出列，再由下一个人重新从 111 开始报数，数到 mmm 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 n-1 名小朋友，而该题是全部出圈。
输入格式

输入两个整数 n,mn,mn,m。
输出格式

输出一行 nnn 个整数，按顺序输出每个出圈人的编号。
输入输出样例
输入 #1

10 3

输出 #1

3 6 9 2 7 1 8 5 10 4

说明/提示

1≤m,n≤1001 \le m, n \le 1001≤m,n≤100

code:
int main(){//约瑟夫环
    int n,m,s=-1;
    cin>>n>>m;
    bool visit[n]={0};
    for(int k=1;k<=n;k++){
        for(int i=0;i<m;i++){
            if(++s>=n)s=0;
            if(visit[s])i--;
        }
        cout<<s+1<<" ";
        visit[s]=true;
    }
    return 0;
}

*/

/*
P2003 [CRCI2007-2008] PLATFORME 平板

题目描述

为了进行一种游戏，现决定搭造一些平板，而各个平板的地址已经选定。基于最普遍的认识，没有任何支持物的平板不可能漂浮在空中。说的更精确些，任意一平板的两端必需有支柱或者它在另一块平板上。

你会得到各个平板在坐标系中的坐标（如左下图）。每一块平板的坐标都是由它的高度（与地板间的垂直距离）和它的水平方位（开始和结束）决定的。每个支柱都距它支撑的平板的边缘半个单位（如图）。

算出支持所有平板的支柱的总长度。

输入格式

第一行包括1个整数N，1 ≤ N ≤ 100，即平板的总数。

接下来的N行每行都是一块平板的坐标，是相应的Y，X1和 X2。即高度和水平的边缘坐标。所有的数都是不大于10000的正整数且满足X2 > X1+1（也可这样理解，每一块平板的长度至少为2）。

输入保证任意两块平板间没有重叠部分。
输出格式

要撑起所有平板所需的支柱的总长度。
输入输出样例
输入 #1

3

1 5 10

3 1 5

5 3 7

输出 #1

14

code:
int n,h,l,r,ans,S[10001*2];
struct Node{
	int h,l,r;
};
bool cmp(Node a,Node b){
	return a.h<b.h;
}
int main(){
	cin>>n;
    Node B[n]={0};
	for(int i=0;i<n;i++){
		cin>>h>>l>>r;
		B[i].h=h;
		B[i].l=2*l;
		B[i].r=2*r;
	}
	sort(B,B+n,cmp);//升序
	for(int i=0;i<n;i++){
		ans=ans+(B[i].h-S[B[i].l+1])+(B[i].h-S[B[i].r-1]);//相加两边
		for(int j=B[i].l+1;j<B[i].r;j++)
			S[j]=B[i].h;
	}
	cout<<ans<<endl;
	return 0;
}

*/

/*
P2008 大朋友的数字

题目背景

在NOIP2013的赛场上，常神牛华丽丽的手残了，小朋友的数字一题只得了10分。于是，他要恶搞一下这道题。
题目描述

有一批大朋友（年龄15岁以上），他们每人手上拿着一个数字，当然这个数字只有1位，也就是0到9之间。每个大朋友的分数为在他之前的最长不下降子序列中所有数之和。（这个序列必须以它作为结尾！）如有多个最长不下降子序列，那么取编号字典序最小的。现在告诉你有n个大朋友，以及他们各自的数字，请你求出他们每个人的分数。
输入格式

输入文件为bignum.in。

第一行，1个数n。

第二行，n个数，分别表示每个人的数字。
输出格式

输出文件为bignum.out。

一行，n个数，分别表示每个人的分数。
输入输出样例
输入 #1

【输入输出样例1】

5

1 2 5 3 4

【输入输出样例2】

5

1 7 5 9 6

输出 #1

【输入输出样例1】

1 3 8 6 10

【输入输出样例2】

1 8 6 17 12

说明/提示

【样例解释1】

五个人分数分别为(1),(1+2),(1+2+5),(1+2+3),(1+2+3+4).

【样例解释2】

五个人分数分别为(1),(1+7),(1+5),(1+7+9){还有一个(1,5,9)},(1+5+6)。

【数据规模】

对于50%的数据，1≤n≤500；

对于80%的数据，1≤n≤1000；

对于100%的数据，1≤n≤10,000。

code:
int main(){
    int n;
    cin>>n;
    int a[n]={0},f[n]={0},sum[n]={0};
	for(int i=0;i<n;++i){
    	cin>>a[i];
    	sum[i]=a[i];
    	for(int j=0;j<i;++j){
    		if(a[i]>=a[j]&&f[i]<f[j]+1)
    			f[i]=f[j]+1,
    			sum[i]=sum[j]+a[i];
		}
	}
	for(int i=0;i<n;i++)
	    cout<<sum[i]<<" ";
	return 0;
}

//该答案有问题
int main(){
    int n,m=0,range=0,sum=0;
    cin>>n;
    int num[n]={0};
    for(int i=0;i<n;i++)
        cin>>num[i];
    for(int i=0;i<n;i++){
        m=0;
        sum=0;
        range=num[i];
        for(int j=0;j<i;j++){
            if(num[j]<range && m<num[j])
                sum+=num[j],m=num[j];
        }
        cout<<sum+range<<" ";
    }
	return 0;
}

*/

/*
P2010 [NOIP2016 普及组] 回文日期

题目描述

在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用888位数字表示一个日期，其中，前444位代表年份，接下来222位代表月 份，最后222位代表日期。显然：一个日期只有一种表示方法，而两个不同的日期的表 示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的8位数字是回文的。现 在，牛牛想知道：在他指定的两个日期之间包含这两个日期本身），有多少个真实存 在的日期是回文的。

一个888位数字是回文的，当且仅当对于所有的i(1≤i≤8)i ( 1 \le i \le 8)i(1≤i≤8)从左向右数的第i个 数字和第9?i9-i9?i个数字（即从右向左数的第iii个数字）是相同的。

例如：

?对于2016年11月19日，用888位数字201611192016111920161119表示，它不是回文的。

?对于2010年1月2日，用888位数字201001022010010220100102表示，它是回文的。

?对于2010年10月2日，用888位数字201010022010100220101002表示，它不是回文的。

每一年中都有121212个月份：

其中，1,3,5,7,8,10,121,3,5,7,8,10,121,3,5,7,8,10,12月每个月有313131天；4,6,9,114,6,9,114,6,9,11月每个月有303030天；而对于222月，闰年时有292929天，平年时有282828天。

一个年份是闰年当且仅当它满足下列两种情况其中的一种：

1.这个年份是444的整数倍，但不是100100100的整数倍；

2.这个年份是400400400的整数倍。

例如：

?以下几个年份都是闰年：2000,2012,20162000,2012,20162000,2012,2016。

?以下几个年份是平年：1900,2011,20141900,2011,20141900,2011,2014。
输入格式

两行，每行包括一个888位数字。

第一行表示牛牛指定的起始日期。

第二行表示牛牛指定的终止日期。

保证date_i date\_i date_i和都是真实存在的日期，且年份部分一定为444位数字，且首位数字不为000。

保证date1 date 1 date1 ―定不晚于date2 date 2 date2。
输出格式

一个整数，表示在date1date1date1和date2date2date2之间，有多少个日期是回文的。
输入输出样例
输入 #1

20110101
20111231

输出 #1

1

输入 #2

20000101
20101231

输出 #2

2

说明/提示

【样例说明】

对于样例1，符合条件的日期是201111022011110220111102。

对于样例2，符合条件的日期是200110022001100220011002和201001022010010220100102。

【子任务】

对于60%60\%60%的数据，满足date1=date2date1 = date2date1=date2。

code:
int a,b,day[15]={0,31,28,31,30,31,30,31,31,30,31,30,31};
int main(){
    cin>>a>>b;
	int m=a/10000,n=b/10000,ans=0;
	for(int i=m;i<=n;i++){
		if(i%4==0)day[2]=29;
		if(i%400!=0&&i%100==0)day[2]=28;
		if( i%10*10+i/10%10<=12 && //月份小于等于12
            i%10*10+i/10%10!=0  && //月份非零
            i/1000+i/100%10*10<=day[i%10*10+i/10%10] && //日期合法
            i/1000+i/100%10*10!=0 && //日期非零
            (i*10000+(i%10*10+i/10%10)*100+i/1000+i/100%10*10)-a>=0 && //日期范围内
            b-(i*10000+(i%10*10+i/10%10)*100+i/1000+i/100%10*10)>=0 )  //日期范围内
			ans++;
		}
	cout<<ans;
	return 0;
}

*/

/*
P2021 faebdc玩扑克

题目背景

faebdc 和 zky 在玩一个小游戏
题目描述

zky 有 nnn 个扑克牌，编号从 111 到 nnn，zky 把它排成一个序列，每次把最上方的扑克牌放在牌堆底，然后把下一张扑克牌拿出来输出，最终输出的序列恰好是从 111 到 nnn，faebdc 问你原序列是什么，因为 faebdc 神脑缫言 O(1)\mathcal O (1)O(1) 的时间得出结果，如果你在 1 s 内答不出来，faebdc 会吃了你。
输入格式

一个整数 n，表示扑克数目。
输出格式

nnn 个数，表示扑克序列。
输入输出样例
输入 #1

13

输出 #1

7 1 12 2 8 3 11 4 9 5 13 6 10 

说明/提示

对于 100%100\%100% 的数据，1≤n≤1061 \le n \le {10}^61≤n≤106。

code:
queue<int>a;
int n,sc[1000005],ans[1000005];
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        a.push(i);
    for(int i=1;!a.empty();i++){
        a.push(a.front());
        a.pop();
        sc[i]=a.front();
        a.pop();
    }
    for(int i=1;i<=n;i++)
        ans[sc[i]]=i;
    for(int i=1;i<=n;i++)
        cout<<ans[i]<<" ";
    return 0;
}

*/

/*
P2026 求一次函数解析式

题目背景

做数学寒假作业的怨念……
题目描述

给定两个整点的坐标，求它们所在直线的函数解析式（一次函数）。
输入格式

输入共两行。

第一行有两个整数x1,y1。表示第一个整点的坐标为(x1,y1)

第二行有两个整数x2,y2。表示第二个整点的坐标为(x2,y2)
输出格式

输出共一行，即这个函数解析式。
输入输出样例
输入 #1

3 6
2 4

输出 #1

y=2x

输入 #2

3 5
2 7

输出 #2

y=-2x+11

输入 #3

3 -1
5 -2

输出 #3

y=-1/2*x+1/2

说明/提示

二乘X表示为2x

二分之一乘X表示为1/2*x

code:
int m,n,p,q,a,b,g;
int gcd(int a, int b) {
	return a % b == 0 ? b : gcd(b, a % b);
}
int main() {
    cin>>m>>n>>p>>q;
	cout<<"y=";
	int t1 = n - q, t2 = m - p, t3 = p * n - m * q, t4 = p - m;
	if(t1 % t2) {
		if(gcd(t1, t2) != 1)g = gcd(t1, t2),t1 /= g,t2 /= g;
		if(t2 < 0) t2 = -t2, t1 = -t1;
		cout<<t1<<"/"<<t2<<"*x";
	} else if(t1 / t2) cout<<t1 / t2<<"x";
	if(t3 % t4) {
		if(gcd(t3, t4) != 1)g = gcd(t3, t4),t3 /= g,t4 /= g;
		if(t4 < 0)	t3 = -t3, t4 = -t4;
		if(t3 < 0) cout<<t3<<"/"<<t4;
		else cout<<"+"<<t3<<"/"<<t4;
	} else if(t3 / t4 < 0) cout<<t3 / t4;
    else if(t3 / t4) cout<<"+"<<t3 / t4; 
	return 0;
}

*/

/*
P2035 [USACO08JAN]iCow B

题目描述

被无止境的农活压榨得筋疲力尽后，Farmer John打算用他在MP3播放器市场新买的iCow来听些音乐，放松一下。FJ的iCow里存了N(1 <= N <= 1,000)首曲子，按1..N依次编号。至于曲子播放的顺序，则是按一个Farmer John自己设计的算法来决定：

* 第i首曲子有一个初始权值R_i(1 <= R_i <= 10,000)。

* 当一首曲子播放完毕，接下来播放的将是所有曲子中权值最大的那首（如果有两首或多首曲子的权值相同，那么这些曲子中编号最小的那首会被选中）。

* 一首曲子在播放结束后，它的权值会被平均地分给其他N-1首曲子，它本身的权值清零。

* 如果一首曲子的权值无法被平均分配（也就是说，无法被N-1整除），那么被N-1除的余数部分将会以1为单位，顺次分配给排名靠前的曲子（也就是说，顺序为曲目1、曲目2...依次下去。当然，刚播放过的那首曲子需要被跳过），直到多出的部分被分配完。

在选定的下一首曲子播放完毕后，这个算法再次被执行，调整曲子的权值，并选出再接下来播放的曲目。

请你计算一下，按FJ的算法，最先播放的T(1 <= T <= 1000)首曲子分别是哪些。
输入格式

第1行: 2个用空格隔开的整数：N 和 T

第2..N+1行: 第i+1行为1个整数：R_i
输出格式

第1..T行: 第i行为1个整数，表示iCow播放的第i首曲子
输入输出样例
输入 #1

3 4
10
8
11

输出 #1

3
1
2
3

说明/提示

每一首曲子播放前，三首曲子的权值分别为：

R_1 R_2 R_3

10 8 11 -> 播放 #3 11/2 = 5, 权值余量 = 1

16 13 0 -> 播放 #1 16/2 = 8

0 21 8 -> 播放 #2 21/2 = 10, 权值余量 = 1

11 0 18 -> 播放 #3 ...

code:
int main(){
	int n,t,maxn,maxh;
	cin>>n>>t;
	int r[n];
	for(int i=0;i<n;i++)	
		cin>>r[i];
	for(int i=0;i<t;i++){
		maxn=-1;
		for(int j=0;j<n;j++)
			if(r[j]>maxn)
				maxn=r[j],maxh=j;
		cout<<maxh+1<<endl;
		for(int j=0;j<n;j++)
			if(j!=maxh)
				r[j]+=(r[maxh]/(n-1));
		maxn=0;
		int t=r[maxh]%(n-1);
		for(int j=0;j<n;j++)
			if(j!=maxh){
				if(!t)break;
				r[j]++;
				t--;
				if(!t)break;
			}
		r[maxh]=0;
    } 
    return 0;
}

*/

/*
P2036 [COCI2008-2009#2] PERKET

题目描述

Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 nnn 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 sss 和苦度 bbb。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。

众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。

另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。
输入格式

第一行一个整数 nnn，表示可供选用的食材种类数。

接下来 nnn 行，每行 222 个整数 sis_isi? 和 bib_ibi?，表示第 iii 种食材的酸度和苦度。
输出格式

一行一个整数，表示可能的总酸度和总苦度的最小绝对差。
输入输出样例
输入 #1

1
3 10

输出 #1

7

输入 #2

2
3 8
5 8

输出 #2

1

输入 #3

4
1 7
2 6
3 8
4 9

输出 #3

1

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，有 1≤n≤101 \leq n \leq 101≤n≤10，且将所有可用食材全部使用产生的总酸度和总苦度小于 1×1091 \times 10^91×109，酸度和苦度不同时为 111 和 000。
说明

    本题满分 707070 分。
    题目译自 COCI2008-2009 CONTEST #2 PERKET，译者 @mnesia。

code:
const int M=15;
int a[M],b[M],n,ans=INT_MAX;//limits.h include
void dfs(int i,int x,int y){
    if(i>n){
        if(!(x==1&&y==0))
            ans=min(abs(x-y),ans);
        return;
    }
    dfs(i+1,x*a[i],y+b[i]);
    dfs(i+1,x,y); 
}
int main(){
    cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i]>>b[i];
    dfs(1,1,0);
    cout<<ans;
    return 0;
}

*/

/*
P2038 [NOIP2014 提高组] 无线网络发射器选址

题目描述

随着智能手机的日益普及，人们对无线网的需求日益增大。某城市决定对城市内的公共场所覆盖无线网。

假设该城市的布局为由严格平行的 129129129 条东西向街道和 129129129 条南北向街道所形成的网格状，并且相邻的平行街道之间的距离都是恒定值 111。东西向街道从北到南依次编号为 0,1,2…1280,1,2 \dots 1280,1,2…128，南北向街道从西到东依次编号为 0,1,2…1280,1,2 \dots 1280,1,2…128。

东西向街道和南北向街道相交形成路口，规定编号为 xxx 的南北向街道和编号为 yyy 的东西向街道形成的路口的坐标是 (x,y)(x, y)(x,y)。在某些路口存在一定数量的公共场所。

由于政府财政问题，只能安装一个大型无线网络发射器。该无线网络发射器的传播范围是一个以该点为中心，边长为 2d2d2d 的正方形。传播范围包括正方形边界。

现在政府有关部门准备安装一个传播参数为 ddd 的无线网络发射器，希望你帮助他们在城市内找出合适的路口作为安装地点，使得覆盖的公共场所最多。
输入格式

第一行包含一个整数 ddd，表示无线网络发射器的传播距离。

第二行包含一个整数 nnn，表示有公共场所的路口数目。

接下来 nnn 行，每行给出三个整数 x,y,kx, y, kx,y,k，中间用一个空格隔开，分别代表路口的坐标 (x,y)(x, y)(x,y) 以及该路口公共场所的数量。同一坐标只会给出一次。
输出格式

输出一行，包含两个整数，用一个空格隔开，分别表示能覆盖最多公共场所的安装地点方案数，以及能覆盖的最多公共场所的数量。
输入输出样例
输入 #1

1  
2  
4 4 10  
6 6 20  
 

输出 #1

1 30

说明/提示

对于100%的数据，1≤d≤20,1≤n≤20,0≤x≤128,0≤y≤128,0<k≤10000001 \leq d \leq 20, 1 \leq n \leq 20, 0 \leq x \leq 128, 0 \leq y \leq 128, 0 < k \leq 10000001≤d≤20,1≤n≤20,0≤x≤128,0≤y≤128,0<k≤1000000

code:
int a[170][170],sum[170][170],d,n,sumn,maxn,x,y,k;
int main(){
	cin>>d>>n;
	for(int i=0;i<n;i++)
		cin>>x>>y>>k,a[x+21][y+21]+=k;
	for(int i=1;i<=169;i++)
        for(int j=1;j<=169;j++)
            sum[i][j]=a[i][j]+sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];
	for(int i=21;i<=149;i++)
	    for(int j=21;j<=149;j++)
	    	if(sum[i+d][j+d]-sum[i+d][j-d-1]-sum[i-d-1][j+d]+sum[i-d-1][j-d-1]>maxn)
			    maxn=sum[i+d][j+d]-sum[i+d][j-d-1]-sum[i-d-1][j+d]+sum[i-d-1][j-d-1],sumn=1;
		    else if(sum[i+d][j+d]-sum[i+d][j-d-1]-sum[i-d-1][j+d]+sum[i-d-1][j-d-1]==maxn) sumn++ ;
	cout<<sumn<<" "<<maxn;
}

*/

/*
P2067 Cytus-Holyknight

题目背景

本人最初作

以此纪念伟大的ios、安卓、PSV平台音乐游戏《cytus》

后续将不断更新。

-------------Chapter V-1-------------

话说两位战士整天靠在一起好无聊啊，于是她们打算――玩游戏！（？）

她们就用剑画了一个十字架，然后开始抛石子，好好玩啊（？？？）

两个人每人有一个石子，当她们丢完后，正在自学数学的小蓝大叫：把他们连起来不就是一次函数吗！！

于是乎，她们就连了起来，然后她们开始计算。此时她们发现一个严重的问题――没有草稿纸！（这什么破问题= =）

由于脑补能力太低，她们只好让你来帮帮忙啦~
题目描述

给出图形（十字架可以视为x轴和y轴），请计算出函数解析式。
输入格式

第一行，一个正整数n，表示该图形大小是n*n；

接下来n行，每行n个字符，1表示坐标轴，x表示石子，0表示空地。

横行的1是x轴，竖列的1是y轴。

上下两行，左右两列的距离恒为1。
输出格式

输出一行，即y=kx+b，或y=kx，y=b，x=b；（k,b为常数）

常数始终保留四位小数
输入输出样例
输入 #1

3
010
111
x1x

输出 #1

y=-1.0000

说明/提示

切记要分类

数据不需判错

100%的数据，3<=n<=16（够水吧）

没学过函数的自己百度

code:
char c[105][105];
int n,xz,yz,x,f=1;
double xl,xr,yl,yr,k,b;
bool jd1,c1,c2;
int main(){
    cin>>n;
	for(int i=1;i<=n;i++)
		for(int j=1;j<=n;j++){
			cin>>c[i][j];
			if(!c1&&c[i][j]=='1'&&c[i-1][j]=='0')xz=i,c1=1;
			if(!c2&&c[i][j]=='1'&&c[i][j-1]=='0')yz=j,c2=1;
			if(!c1&&c[i][j]=='0'&&c[i-1][j]=='1')xz=i-1,c1=1;
			if(!c2&&c[i][j]=='0'&&c[i][j-1]=='1')yz=j-1,c2=1;
			if(c[i][j]=='x' && !jd1)xl=j,yl=i,jd1=1;
            else if (c[i][j]=='x')xr=j,yr=i;
        }
	xl-=yz,xr-=yz,yl=xz-yl,yr=xz-yr;
	if(xl==xr)printf("x=%.4lf\n",xl);
	else{
        k=(yr-yl)/(xr-xl);
        if(k==0)printf("y=%.4lf\n",yl);
        else{
            printf("y=%.4lfx",k);
            b=yl-k*xl;
            if(b>0)cout<<'+';
            if(b!=0)printf("%.4lf\n",b);
        }
    }
	return 0;
} 

*/

/*
P2069 松鼠吃果子

题目描述

有N个一种松鼠喜欢吃的果子由下向上串排成一列，并标号1,2,...N。一只松鼠从最下果子开始向上跳，并且第i次跳可以一次跳过i*i*i除以5的余数+1个果子(=i*i*i%5+1)，并把脚下的果子吃了，如果上面有果子，在重力作用下，都将向下掉下一格。如第1次跳从第一个果子上跳过1*1*1%5+1=2个果子，可跳到第3个果子上，并把第3个果子吃了；第2次从第4个果子上(落在原来第三个果子位置)跳过2*2*2%5+1=4个到第8个果子上，并把第8个吃了；如此...。

当然，总有一次松鼠会跳出这串果子的最前面，设为每K次，它吃不到任何果子了。这时它回到最下面的果子上，重做它的第K次跳，以求吃到果子。如此，问它吃的第m只果子(即第M跳吃到的果子)的标号是什么？
输入格式

一共两行，分别为N和m。（1<=m<=n<=200，并且满足能够跳到第m次）
输出格式

一个数，即它吃的第m只果子的标号
输入输出样例
输入 #1

10 

4

输出 #1

9

说明/提示

注：吃掉的果子依次为3，8，4(回到下面重做第3跳)，9(回到下面重做第4跳)

code:
int main(){//总感觉题目有bug
	int n,m,j,h=1;
	cin>>n>>m;
    int a[n+1];
	for(int i=1;i<=n;i++) 
        a[i]=i; 
	for(int i=1;i<=m;i++){
		j=(i*i*i)%5+1;
		h+=j;
		if(h>n-i+1) h=j+1;
		if(i!=m)
			for(int j=h+1;j<=n-i+1;j++)
				a[j-1]=a[j];
	}
	cout<<a[h]<<endl;
	return 0;
}

*/

/*
P2074 危险区域

题目背景

一个恐怖组织在一座城市中安放了定时炸弹，其威力巨大，现在这里的警长想知道最坏的情况下会有多少街区受威胁。
题目描述

在一个城市有 N×MN \times MN×M 个街区，每个街区由坐标描述，如图所示：
	111 	222 	333 	?\cdots? 	MMM
111 	(1,1)(1,1)(1,1) 	(1,2)(1,2)(1,2) 	(1,3)(1,3)(1,3) 	?\cdots? 	(1,M)(1,M)(1,M)
222 	(2,1)(2,1)(2,1) 	(2,2)(2,2)(2,2) 	(2,3)(2,3)(2,3) 	?\cdots? 	(2,M)(2,M)(2,M)
333 	(3,1)(3,1)(3,1) 	(3,2)(3,2)(3,2) 	(3,3)(3,3)(3,3) 	?\cdots? 	(3,M)(3,M)(3,M)
?\vdots? 				?\ddots? 	
NNN 	(N,1)(N,1)(N,1) 	(N,2)(N,2)(N,2) 	(N,3)(N,3)(N,3) 	?\cdots? 	(N,M)(N,M)(N,M)

现在已知有一个恐怖组织在其中的一个街区安放了定时炸弹，其威力为 ttt，即所有到这个街区的直线距离小于等于 ttt 的街区都会受威胁，已知有 kkk 个可能的炸弹安放位置，现在这里的警长想知道最坏的情况下会有多少街区受威胁。
输入格式

第一行四个正整数 n,m,k,tn,m,k,tn,m,k,t。

接下来 kkk 行每行两个正整数 xi,yix_i,y_ixi?,yi?，描述每个可能安放炸弹的街区。
输出格式

一个正整数为在最坏情况下有多少街区会受威胁。
输入输出样例
输入 #1

4 5 3 2

1 2

3 4

4 5

输出 #1

11

说明/提示

数据规模与约定

对于20%20\%20%的数据 k=1k=1k=1。

对于 50%50\%50% 的数据 1≤n,m≤10001 \le n,m \le 10001≤n,m≤1000，1≤k≤201 \le k \le 201≤k≤20，1≤t≤1001\le t \le 1001≤t≤100。

对于 100%100\%100% 的数据 1≤n,m≤1051 \le n,m \le 10^51≤n,m≤105，1≤k≤501 \le k \le 501≤k≤50，t≤300t \le 300t≤300。

fixed by @Cppsteve\color{#5EB95E}{\textsf{Cppsteve}}Cppsteve

code:#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m,k,t,x,y,ans=0,zd=0;
	cin>>n>>m>>k>>t;
	for(int z=0;z<k;z++){
		cin>>x>>y;
		for(int i=max(x-t,1);i<=min(n,x+t);i++)
			for(int j=max(y-t,1);j<=min(m,y+t);j++)
				if(sqrt((i-x)*(i-x)+(j-y)*(j-y))<=t)
					ans++;
		zd=max(zd,ans);
		ans=0;
	}
	cout<<zd;
	return 0;
}

*/

/*
P2089 烤鸡

题目背景

猪猪 Hanke 得到了一只鸡。
题目描述

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 101010 种配料（芥末、孜然等），每种配料可以放 111 到 333 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 nnn ，请输出这 101010 种配料的所有搭配方案。
输入格式

一个正整数 nnn，表示美味程度。
输出格式

第一行，方案总数。

第二行至结束，101010 个数，表示每种配料所放的质量，按字典序排列。

如果没有符合要求的方法，就只要在第一行输出一个 000。
输入输出样例
输入 #1

11

输出 #1

10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1 

说明/提示

对于 100%100\%100% 的数据，n≤5000n \leq 5000n≤5000。

code:#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,x=0;  
    cin>>n;  
    for (int a=1;a<=3;a++)  
        for (int b=1;b<=3;b++)  
            for (int c=1;c<=3;c++)  
                for (int d=1;d<=3;d++)  
                    for (int e=1;e<=3;e++)  
                        for (int f=1;f<=3;f++)  
                            for (int g=1;g<=3;g++)  
                                for (int h=1;h<=3;h++)  
                                    for (int i=1;i<=3;i++)  
                                        for (int j=1;j<=3;j++)  
                                            if (a+b+c+d+e+f+g+h+i+j==n)  
                                                x++;  
    cout<<x<<endl;  
    for (int a=1;a<=3;a++)  
        for (int b=1;b<=3;b++)  
            for (int c=1;c<=3;c++)  
                for (int d=1;d<=3;d++)  
                    for (int e=1;e<=3;e++)  
                        for (int f=1;f<=3;f++)  
                            for (int g=1;g<=3;g++)  
                                for(int h=1;h<=3;h++)  
                                    for (int i=1;i<=3;i++)  
                                        for (int j=1;j<=3;j++)  
                                            if (a+b+c+d+e+f+g+h+i+j==n)  
                                                cout<<a<<" "<<b<<" "<<c<<" "<<d<<" "<<e<<" "<<f<<" "<<g<<" "<<h<<" "<<i<<" "<<j<<endl;  
	return 0;
}

*/

/*
P2095 营养膳食

题目描述

Mr.L 正在完成自己的增肥计划。

为了增肥，Mr.L 希望吃到更多的脂肪。然而也不能只吃高脂肪食品，那样的话就会导致缺少其他营养。

Mr.L 通过研究发现：真正的营养膳食规定某类食品不宜一次性吃超过若干份。比如就一顿饭来说，肉类不宜吃超过 111 份，鱼类不宜吃超过 111 份，蛋类不宜吃超过 111 份，蔬菜类不宜吃超过 222 份。

Mr.L 想要在营养膳食的情况下吃到更多的脂肪，当然 Mr.L 的食量也是有限的。
输入格式

第一行包含三个正整数 n,mn,mn,m 和 kkk。表示 Mr.L 每顿饭最多可以吃 mmm 份食品，同时有 nnn 种食品供 Mr.L 选择，而这 nnn 种食品分为 kkk 类。

第二行包含 kkk 个不超过 101010 的正整数，表示可以吃 111 到 kkk 类食品的最大份数。

接下来 nnn 行每行包括 222 个正整数，分别表示该食品的脂肪指数 aia_iai? 和所属的类别 bib_ibi?。
输出格式

包括一个数字即 Mr.L 可以吃到的最大脂肪指数和。
输入输出样例
输入 #1

6 6 3
3 3 2
15 1
15 2
10 2
15 2
10 2
5 3

输出 #1

60

说明/提示

对于 100%100\%100% 的数据，1≤n≤2001\leq n\leq 2001≤n≤200，1≤m≤1001\leq m\leq 1001≤m≤100，1≤k≤1001\leq k\leq 1001≤k≤100，1≤ai≤1001\leq a_i\leq 1001≤ai?≤100，1≤bi≤k1\leq b_i\leq k1≤bi?≤k

code:
int b[10001];
struct ben{
	int y,z;
}a[10001];
int cmp(const ben &a,const ben &b){
	return a.y>b.y;
}
int main(){
	int n,m,k,ans=0;;
    cin>>n>>m>>k;
	for(int i=1;i<=k;i++)
		cin>>b[i];
	for(int i=1;i<=n;i++)
		cin>>a[i].y>>a[i].z;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
		if(b[a[i].z]>0&&m>0){
			b[a[i].z]--;
			m--;
			ans+=a[i].y;
		}
    cout<<ans;
	return 0;
} 

*/

/*
P2097 资料分发1

题目描述

有一些电脑，一部分电脑有双向数据线连接。如果一个电脑得到数据，它可以传送到的电脑都可以得到数据。现在，你有这个数据，问你至少将其输入几台电脑，才能使所有电脑得到数据。
输入格式

第一行两个数n，m。n是点数，m是边数。

接下来m行，每行2个整数p，q表示p到q有一条双向数据线。
输出格式

一个整数，表示至少输入的电脑数量。
输入输出样例
输入 #1

4 5
1 2
1 3
2 3
2 1
3 4

输出 #1

1

说明/提示

对于30%的数据：n<=100,m<=1000

对于60%的数据:n<=2000,m<=100000

对于100%的数据：n<=100000, m<=200000

数据不保证没有重边，不保证没有自回环

code:
int n,m,f[100001],x,y,cnt;
int getf(int x) {
	if(f[x]==x) return x;
	else return f[x]=getf(f[x]);
}
int main() {//并查集
	cin>>n>>m;
	for(int i=1; i<=n; i++)
		f[i]=i;
	for(int i=1; i<=m; i++) 
		cin>>x>>y,
	    f[getf(y)]=getf(x);
	for(int i=1; i<=n; i++)
		if(f[i]==i) 
            cnt++;
	cout<<cnt;
	return 0;
}

*/

/*
P2108 学英语

题目描述

为了适应紧张的大学学习生活，小 Z 发愤图强开始复习巩固英语。

由于小 Z 对数学比较有好感，他首先复习了数词。小 Z 花了一整天的时间，终于把关于基数词的知识都搞懂了。于是小 Z 非常兴奋，决定出一些题目考考已经过了英语四级、人称英语帝的小 G。考法很简单：小 Z 给出某个整数 xxx 的英文写法，要求小 D 用阿拉伯数字写出 xxx。

小 Z 会保证以下几点：

    ?999,999,999≤x≤999,999,999-999,999,999 \leq x \leq 999,999,999?999,999,999≤x≤999,999,999

    题目中只会用到以下这些英文单词：

negative, zero, one, two, three, four, five, six, seven, eight, nine, ten

eleven, twelve, thirteen, fourteen, fifteen, sixteen, seventeen, eighteen, nineteen, twenty

thirty, forty, fifty, sixty, seventy, eighty, ninety, hundred, thousand, million

    若 xxx 为负数，题目中第一个单词是 negative，否则任何时候都不会出现 negative 这个词。

    由于小 Z 很牛 B，他不知道像 103103103 这样的数字要写成 one hundred and three 而是直接写成了 one hundred three，就是说小 Z 的所有题目中都没有写 and 这个词（尽管本应该是要写的），请你谅解。

    除了第 4 点， 其他还是基本符合英语的语法规则的， 比如 150015001500 他会写成 one thousand five hundred 而不会写成 fifteen hundred。

小 D 拿到题目后不屑地说了一句：水题！写个程序么好了……

但是小 D 要出去玩（此时应该已经在千里之外爽玩了） ，这个任务就交给你了。
输入格式

一行，题目描述中所说的 xxx 的英文写法。
输出格式

一行， xxx 的阿拉伯数字写法。
输入输出样例
输入 #1

six

输出 #1

6

输入 #2

negative seven hundred twenty nine

输出 #2

-729

输入 #3

one million one hundred one

输出 #3

1000101

输入 #4

eight hundred fourteen thousand twenty two

输出 #4

814022

说明/提示

对于 100%100\%100% 的数据，?999,999,999≤x≤999,999,999-999,999,999 ≤ x ≤ 999,999,999?999,999,999≤x≤999,999,999。

code:
string s;
long long num, now, f;
int main() {
	f = 1;
	while(cin >> s) {
		if(s == "negative")	f = -1;
		if(s == "one")		now++;
		if(s == "two") 	now += 2;
		if(s == "three")	now += 3;
		if(s == "four")	now += 4;
		if(s == "five")	now += 5;
		if(s == "six")		now += 6;
		if(s == "seven")	now += 7;
		if(s == "eight")	now += 8;
		if(s == "nine")	now += 9;
		if(s == "ten")		now += 10;
		if(s == "eleven")	now += 11;
		if(s == "twelve")	now += 12;
		if(s == "thirteen")	now += 13;
		if(s == "fourteen")	now += 14;
		if(s == "fifteen")	now += 15;
		if(s == "sixteen")	now += 16;
		if(s == "seventeen")	now += 17;
		if(s == "eighteen")	now += 18;
		if(s == "nineteen")	now += 19;
		if(s == "twenty")	now += 20;
		if(s == "thirty")	now += 30;
		if(s == "forty")	now += 40;
		if(s == "fifty")	now += 50;
		if(s == "sixty")	now += 60;
		if(s == "seventy")	now += 70;
		if(s == "eighty")	now += 80;
		if(s == "ninety")	now += 90;
		if(s == "hundred")	now *= 100;
		if(s == "thousand")	num += now * 1000, now = 0;
		if(s == "million")	num += now * 1000000, now = 0;
	}
	num += now;
	printf("%lld", num * f);
}

*/

/*
P2118 [NOIP2014 普及组] 比例简化

题目描述

在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有149814981498 人，反对的有 902902902人，那么赞同与反对的比例可以简单的记为1498:9021498:9021498:902。

不过，如果把调查结果就以这种方式呈现出来，大多数人肯定不会满意。因为这个比例的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为5:35:35:3，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。

现给出支持人数A，反对人数BBB，以及一个上限LLL，请你将AAA比BBB化简为AAA’比BBB’，要求在AAA’和BBB’均不大于LLL且AAA’和BBB’互质（两个整数的最大公约数是111）的前提下，AAA’/B/B/B’≥A/B ≥ A/B≥A/B且AAA’/B/B/B’?A/B - A/B?A/B的值尽可能小。

(本题目为2014NOIP普及T2)
输入格式

共一行，包含三个整数A,B,LA,B,LA,B,L，每两个整数之间用一个空格隔开，分别表示支持人数、反对人数以及上限。
输出格式

共一行，包含两个整数AAA’，BBB’，中间用一个空格隔开，表示化简后的比例。
输入输出样例
输入 #1

1498 902 10

输出 #1

5 3

说明/提示

对于100%100\%100%的数据，1≤A≤1,000,000,1≤B≤1,000,000,1≤L≤100,A/B≤L1 ≤ A ≤ 1,000,000,1 ≤ B ≤ 1,000,000,1 ≤ L ≤ 100,A/B ≤ L1≤A≤1,000,000,1≤B≤1,000,000,1≤L≤100,A/B≤L。

code:
int gcd(int x,int y){
    if(y==0) return x;
    return gcd(y,x%y);
}
int main(){
    int i,j,a,b,ansa,ansb,l;
    cin>>a>>b>>l;
    ansa=l;ansb=1;
    for(i=1;i<=l;i++)
        for(j=1;j<=l;j++)
            if(gcd(i,j)==1 && i*b>=j*a && i*ansb<j*ansa)
                ansa=i,ansb=j;
    cout<<ansa<<" "<<ansb;
    return 0;
}

*/

/*
P2141 [NOIP2014 普及组] 珠心算测验

题目描述

珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。

某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？

最近老师出了一些测验题，请你帮忙求出答案。

(本题目为2014NOIP普及T1)
输入格式

共两行，第一行包含一个整数nnn，表示测试题中给出的正整数个数。

第二行有nnn个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。
输出格式

一个整数，表示测验题答案。
输入输出样例
输入 #1

4
1 2 3 4

输出 #1

2

说明/提示

【样例说明】

由1+2=3,1+3=41+2=3,1+3=41+2=3,1+3=4，故满足测试要求的答案为222。

注意，加数和被加数必须是集合中的两个不同的数。

【数据说明】

对于100%100\%100%的数据，3≤n≤1003 ≤ n ≤ 1003≤n≤100，测验题给出的正整数大小不超过10,00010,00010,000。

code:
int n,a[101],cnt;
bool used[101];
int main(){
	cin>>n;
	for(int i=0;i<n;i++)
		cin>>a[i];
	sort(a,a+n,greater<int>());
	for(int i=0;i<n;i++)
		for(int j=i+1;j<n;j++)
			for(int k=j+1;k<=n;k++)
				if(a[j]+a[k]==a[i] && !used[i])
					cnt++,used[i]=true;
	cout<<cnt;
	return 0;
}

*/

/*
P2142 高精度减法

题目描述

高精度减法。
输入格式

两个整数 a,ba,ba,b（第二个可能比第一个大）。
输出格式

结果（是负数要输出负号）。
输入输出样例
输入 #1

2
1

输出 #1

1

说明/提示

    20%20\%20% 数据 a,ba,ba,b 在 long long 范围内；
    100%100\%100% 数据 0<a,b≤10100860<a,b\le 10^{10086}0<a,b≤1010086。


code:
int a[10087],b[10087],f,ta,tb;;
string sa,sb;
int main(){
    cin >> sa >> sb;
    if(sa.size() < sb.size() || (sa.size()==sb.size() && sa<sb))
        swap(sa,sb),f=1;
    for(int i=sa.size()-1;i>=0;i--)
        a[ta++]=sa[i]-'0';
    for(int i=sb.size()-1;i>=0;i--)
        b[tb++]=sb[i]-'0';
    for(int i=0;i<ta;i++){
        a[i]-=b[i];
        if(a[i]<0)
            a[i]+=10,a[i+1]--;
    }
    if(f)cout<<'-',f=0;
    for(int i=ta-1;i>=0;i--){
        if(a[i])f=1;
        if(f || !i)putchar(a[i]+'0');
    }
    return 0;
}

*/

/*
P2241 统计方形（数据加强版）

题目背景

1997年普及组第一题
题目描述

有一个 n×mn \times mn×m 方格的棋盘，求其方格包含多少正方形、长方形（不包含正方形）。
输入格式

一行，两个正整数 n,mn,mn,m（n≤5000,m≤5000n \leq 5000,m \leq 5000n≤5000,m≤5000）。
输出格式

一行，两个正整数，分别表示方格包含多少正方形、长方形（不包含正方形）。
输入输出样例
输入 #1

2 3

输出 #1

8 10

code:
long long n,m,r,s;
int main() {//数论
    cin>>n>>m;
    for(int i=0; i<n; i++)
        for(int j=0; j<m; j++)
            if(i==j) s+=(n-i)*(m-j);
            else r+=(n-i)*(m-j);
    cout<<s<<" "<<r;
    return 0;
}

*/

/*
P2242 公路维修问题

题目描述

由于长期没有得到维修，A国的高速公路上出现了N个坑。为了尽快填补好这N个坑，A国决定对M处地段采取交通管制。为了求解方便，假设A国的高速公路只有一条，而且是笔直的。现在给出N个坑的位置，请你计算，最少要对多远的路段实施交通管制？
输入格式

输入数据共两行，第一行为两个正整数N、M （2<=N<=15000，M<=N）。第二行给出了N个坑的坐标（坐标值均在长整范围内，按从小到大的顺序给出，且不会有两个点坐标相同）。
输出格式

仅一行，为最小长度和。
输入输出样例
输入 #1

18 4
3 4 6 8 14 15 16 17 21 25 26 27 30 31 40 41 42 43

输出 #1

25

说明/提示

[样例说明]

交通管制的地段分别为：3-8，14-21，25-31，40-43。

code:
int n,m,a[15001],ans;
int main(){//数论 反向思维
    cin>>n>>m;
    for(int i=0;i<n;i++)
        cin>>a[i];
    ans=a[n-1]-a[0];
    for(int i=0;i<n-1;i++)
        a[i] = a[i+1] - a[i];
    sort(a,a+n-1);
    for(int i=n-(m-1)-1;i<n-1;i++)
        ans=ans-a[i];
    cout<<ans+m;
    return 0;
}

*/

/*
P2249 【深基13.例1】查找

题目描述

输入 n(n≤106)n(n\le10^6)n(n≤106) 个不超过 10910^9109 的单调不减的（就是后面的数字不小于前面的数字）非负整数 a1,a2,…,ana_1,a_2,\dots,a_{n}a1?,a2?,…,an?，然后进行 m(m≤105)m(m\le10^5)m(m≤105) 次询问。对于每次询问，给出一个整数 q(q≤109)q(q\le10^9)q(q≤109)，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 -1 。
输入格式

第一行 2 个整数 n 和 m，表示数字个数和询问次数。

第二行 n 个整数，表示这些待查询的数字。

第三行 m 个整数，表示询问这些数字的编号，从 1 开始编号。
输出格式

m 个整数表示答案。
输入输出样例
输入 #1

11 3
1 3 3 3 5 7 9 11 13 15 15
1 3 6

输出 #1

1 2 -1 

code:
int a[1000001];
int check(int left,int right,int num){
    if(left==right)
        if(a[left]==num) return left;
        else return -1;
    if(num<=a[(left+right)/2]) check(left,(left+right)/2,num);
    else check((left+right)/2+1,right,num);
}
int main(){
    int n,m,b;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        cin>>a[i];
    for(int i=0;i<m;i++){
        cin>>b;
        cout<<check(1,n,b)<<" ";
    }
    return 0;
}

*/

/*
P2347 [NOIP1996 提高组] 砝码称重

题目描述

设有1g1g1g、2g2g2g、3g3g3g、5g5g5g、10g10g10g、20g20g20g的砝码各若干枚（其总重≤1000 \le 1000≤1000），
输入格式

输入方式：a1,a2,a3,a4,a5,a6a_1 , a_2 ,a_3 , a_4 , a_5 ,a_6a1?,a2?,a3?,a4?,a5?,a6?

（表示1g1g1g砝码有a1a_1a1?个，2g2g2g砝码有a2a_2a2?个，…，20g20g20g砝码有a6a_6a6?个）
输出格式

输出方式：Total=NTotal=NTotal=N

（NNN表示用这些砝码能称出的不同重量的个数，但不包括一个砝码也不用的情况）
输入输出样例
输入 #1

1 1 0 0 0 0

输出 #1

Total=3

说明/提示

【题目来源】

NOIP 1996 提高组第四题

code:
bool dp[1005]={true};//必须标记第一个true 不然会无法赋值(不知为何)
int a[7],b[7]={0,1,2,3,5,10,20},ans,mx;
int main(){
	for(int i=1;i<=6;i++)
		cin>>a[i],mx+=a[i]*b[i];
	for(int i=1;i<=6;i++)
		for(int j=1;j<=a[i];j++)
			for(int k=mx;k>=0;k--)
				if(dp[k]==true)
					dp[k+b[i]]=true;
	for(int i=1;i<=mx;i++)
		if(dp[i])
			ans++;
	cout<<"Total="<<ans;
    return 0;
}

*/

/*
P2360 地下城主

题目描述

你参加了一项秘密任务，在任务过程中你被困在了一个3D的地下监狱里面，任务是计时的，你现在需要在最短的时间里面从地牢里面逃出来继续你的任务。地牢由若干层组成，每一层的形状都是长宽一样的矩形，地牢被分成了若干小格，当小格没有被岩石所占据时，你可以前往所在小格的前方，后方，左方，右方，上层，下层的小格。每走一小格花费一分钟时间。

你能不能顺利的从地牢里面逃出来呢？如果可以，那所需要的最短时间又是多少呢？

//据说出口藏有神器。
输入格式

第一行输入L R C（L为地牢的层数，R为每层小格的行数，C为每层小格的列数，其中1<=L,R,C<=30）。

第二行开始输入L层地牢的格局，每一层有R行，每行有C个小格，两层地牢中间有空行隔开。

输入的文件中，“S”代表你的起始点，“E”代表你所要到达的出口，“#”为小格被岩石占据，“.”表示没有被岩石占据。
输出格式

输出包含一行，当你可以顺利到达出口时请输出：

“Escaped in x minute(s).”，x代表你所花费的最短时间；

否则请输出：“Trapped!”。
输入输出样例
输入 #1

3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E

输出 #1

Escaped in 11 minute(s).

说明/提示

来源：POJ 2251

code:(没看懂)
const int dx[]={0,0,0,0,1,-1},dy[]={1,-1,0,0,0,0},dz[]={0,0,1,-1,0,0};
int l,r,c,posx1,posy1,posz1,posx2,posy2,posz2;
char a[55][55][55];
struct node{
	int x,y,z,t;
};
queue<node> q;
int bfs(int x,int y,int z,int t){
	a[x][y][z]='#';
	q.push(node{x,y,z});
	while(!q.empty()){
		int xx=q.front().x,yy=q.front().y,zz=q.front().z,tt=q.front().t;
		q.pop();
		for(int i=0;i<6;i++)
			if(xx+dx[i]==posx2 && yy+dy[i]==posy2 && zz+dz[i]==posz2) return tt+1;
			else if((xx+dx[i]>=1 && xx+dx[i]<=l && yy+dy[i]>=1 && yy+dy[i]<=r && zz+dz[i]>=1 && zz+dz[i]<=c &&a[xx+dx[i]][yy+dy[i]][zz+dz[i]]!='#'))
				a[xx+dx[i]][yy+dy[i]][zz+dz[i]]='#',q.push(node{xx+dx[i],yy+dy[i],zz+dz[i],tt+1});
	}
	return -1;
}
int main(){//搜索
    cin>>l>>r>>c;
    for(int i=1;i<=l;i++)
        for(int j=1;j<=r;j++)
            for(int k=1;k<=c;k++){
                cin>>a[i][j][k];
                if(a[i][j][k]=='S')posx1=i,posy1=j,posz1=k;
                else if(a[i][j][k]=='E')posx2=i,posy2=j,posz2=k;
            }
    int p=bfs(posx1,posy1,posz1,0);
    if(p!=-1) cout<<"Escaped in "<<p<<" minute(s)."<<endl;
    else cout<<"Trapped!"<<endl;
    return 0;
}

*/

/*
P2362 围栏木桩

题目描述

某农场有一个由按编号排列的n根木桩构成的首尾不相连的围栏。现要在这个围栏中选取一些木桩，按照原有的编号次序排列之后，这些木桩高度成一个升序序列。所谓的升序序列就是序列中的任何一个数都不小于它之前的任何一个数。试编写程序从这个围栏中选取合适的木桩使得选出的木桩个数t最大，并求出选取出t根木桩的方案总数c。
输入格式

文件中的第一行只有一个数m，表明随后有m个问题的描述信息。每个问题的描述信息格式为n h1,h2,h3,…,hn（其中hi（i=1,2,3,…,n）表示第i根木桩的高度。）
输出格式

依次输出每个问题中t和c的解。每行输出一个问题的解。
输入输出样例
输入 #1

3
9 10 1 9 8 7 6 3 4 6
3 100 70 102
6 40 37 23 89 91 12

输出 #1

4 1
2 2
3 3

说明/提示

m≤5,n≤20,hi≤150m\le 5,n\le 20,h_i\le 150m≤5,n≤20,hi?≤150

code:
int n,T,a[25],dp[25],f[25],ans1,ans2;
int main(){
    for(cin>>T;T>0;T--,ans1=0,ans2=0){
        cin>>n;
        for(int i=1;i<=n;i++)
            cin>>a[i],dp[i]=1,f[i]=1;
        for(int i=1;i<=n;i++)
            for(int j=1;j<i;j++)
                if(a[j]<=a[i])
                    if(dp[i]<dp[j]+1) dp[i]=dp[j]+1,f[i]=f[j];
                    else if(dp[i]==dp[j]+1) f[i]+=f[j];
        for(int i=1;i<=n;i++)
            ans1=max(ans1,dp[i]);
        for(int i=1;i<=n;i++)
            ans2+=(ans1==dp[i])*f[i];
        cout<<ans1<<" "<<ans2<<endl;
    }
}

*/

/*
P2368 EXCEEDED WARNING B

题目背景

SGU 107
题目描述

求有多少个平方后末尾为987654321的n位数
输入格式

整数n
输出格式

答案，即[b]“平方后末尾为987654321的n位数”[/b]的个数
输入输出样例
输入 #1

8

输出 #1

0

说明/提示

1≤n≤1 000 000

[b][color=#767676]不要问我暴力能过几个点，我只想说呵呵。[/color][/b]

code:
int main(){//数论
    int n;cin>>n;
    if (n<9) cout<<0;
    else if (n==9) cout<<8;
    else {
        cout<<72;
        for (int i=0;i<n-10;i++) 
            cout<<0;
    }
    return 0;
}

*/

/*
P2369 EXCEEDED WARNING A

题目描述

有这样一些数据，它们均为小于 10910^9109 的非负整数，且个数为 nnn，现在请你输出其中最小的 mmm 个数。

小心溢出，注意 Memory Limit = 4000KiB。
输入格式

第一行以半角空格间隔开的两个非负整数： n,mn, mn,m

接下来的 nnn 行，随机产生的 nnn 个数，保证 323232 位整型变量可以存下。
输出格式

共 mmm 行，即题目描述中的 mmm 个数，从小到大依次输出。
输入输出样例
输入 #1

10 5
2
4
6
8
10
1
3
5
7
9

输出 #1

1
2
3
4
5

说明/提示

数据范围：m<105,n<106m<10^5, n<10^6m<105,n<106。

code:
int n,m;
short num[1000001];
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++) 
        cin>>num[i];
	sort(num,num+n);
	for(int i=0;i<m;i++) 
        cout<<num[i]<<endl;
	return 0;
}

*/

/*
P2372 yyy2015c01挑战算周长

题目背景

yyy2015c01 快速的解决了问题，受到邻居们的赞许，高兴的回到家，把糖给了妈妈，吃了香喷喷的午饭，又睡了一个甜甜的午觉，感觉人生真美好。下午爸爸回到家，听说了 yyy2015c01 帮老师及邻居们解决了难题，准备带她去游乐场玩她平日最喜欢玩的跳舞机作为奖励，yyy2015c01 听了，兴奋的一蹦三尺高。
题目描述

游乐场里人头攒动，每台跳舞机前都围满了人，怎么办呢？人这么多，想玩上估计要等好久了，yyy2015c01 左顾右盼，突然发现一台跳舞机前面没人， “哈哈，被我发现一台没人的，赶快去……”，结果到了面前才发现这台新机器的玩法与众不同，脚下的格子随机位置显示出很多的 X，踩到一个格子，就要根据规则先算出它对应的周长，然后把正确周长输入机器，最后的胜利者还可以获得游乐城的免费游戏券一张，yyy2015c01 心动了，小朋友们，你们可以帮助 yyy2015c01 顺利拿到游戏券么？

游戏规则如下：

新跳舞机踏板上有许多要分析的目标，由脚踩确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的周长。新跳舞机的踏板是一个矩形的网格，里面点 .，表示空的地方；有大写字母 X，表示目标的一部分。

方格中的一个 X 是指一个完整的网格方形区域，包括其边界和目标本身。网格中心的 X 与其边界上 888 个方向的 X 都是相邻的。任何两个相邻的 X，其网格方形区域在边界或拐角处是重叠的，所以它们的网格方形区域是相邻的。一个目标是由一系列相邻 X 的网格方形区域连接起来构成的。在网格 111 中，一个目标填充了全部网格；在网格 222 中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的 X 属于另一个目标。

yyy2015c01 总是能踩到一个 X，以选中包含该 X 的目标，记录脚踩时的坐标。行列号是从左上角开始，从 111 开始编号的。一个有用的统计参数是目标的周长。 假定每个 X 的每条边上有一个方形的单元。

目标中不会包含任何完全封闭的孔。
输入格式

共 M+1M+1M+1 行，第一行为四个正整数 M,N,X,YM,N,X,YM,N,X,Y（中间用空格隔开），表示网格的大小为 MMM 行，NNN 列，且踩中网格的第 XXX 行第 YYY 列方格。后面就是 MMM 行，由字符 . 和 X 构成。
输出格式

共一行，表示选中目标的周长。
输入输出样例
输入 #1

2 2 2 2 
XX
XX

输出 #1

8

输入 #2

6 4 2 3 
.XXX
.XXX
.XXX
...X
..X.
X...

输出 #2

18

说明/提示

1≤M≤201\leq M\leq 201≤M≤20，1≤N≤201\leq N\leq 201≤N≤20，1≤X≤M1\leq X\leq M1≤X≤M，1≤Y≤N1\leq Y\leq N1≤Y≤N。

code:
int m,n,x,y,ans,pd[22][22],dx[8]={-1,-1,1,1,-1,0,0,1},dy[8]={-1,1,-1,1,0,-1,1,0}; 
char k[22][22];
void dfs(int a,int b){
	pd[a][b]=1;
	for(int c=0;c<8;c++){
		int d=dx[c]+a,e=dy[c]+b;
		if(d>0 && d<=m && e>0 && pd[d][e]==0 && k[d][e]=='X')dfs(d,e);
		if(c>3 && (d<=0 || d>m || e<=0 || e>n || k[d][e]!='X'))ans++;
	}
}
int main(){
	cin>>m>>n>>x>>y;
	for(int a=1;a<=m;a++)
		for(int b=1;b<=n;b++)
			cin>>k[a][b];
	dfs(x,y);
    cout<<ans;
	return 0;
}

*/

/*
P2373 yyy2015c01的IDE之Call Stack

题目背景

在2020年的某一天，我们的yyy2015c01同学想要开发一套IDE。
题目描述

作为他开发团队中的一员，你不幸地yyy2015c01被选入了Debugger的开发组。

yyy2015c01设想的Debugger由几部分组成，其中的一个小组件就是Call Stack――中文称之为“调用栈”。

由于IDE目前还是内测版，开发组需要先编一个能识别参数表的Call Stack来看看效果如何。这个任务交由你来完成。

开发组假想的Call Stack能实现识别int和char参数表，以辨别出不同的函数，规则是：

int fac1(int n);

和

int fac1(char n);

是两个不同的函数；但

int Fac1(int n,int m);

和

int FAC1(int x,int y);

被认为是相同的函数。也就是说，这个Call Stack认的不是参数名，而是其类型和忽略大小写的函数名。

注意：int main()可能会出现，也可能不出现；无论它有没有出现，都不能将其算入函数中。

请你编写一个Call Stack，并在所有函数调用完后输出这个程序一共有多少个不完全相同的函数（保证程序中的每个函数至少调用一次）。
输入格式

输入共n+1行：第一行是一个正整数n，表示共有n次调用操作；第2~n+1行每行是一条函数调用信息（严格按照样例输入的格式），保证不会有多余的其他字符。
输出格式

输出共1行：一个正整数m，表示在上述调用中共有多少个参数表不完全相同的函数。
输入输出样例
输入 #1

2
FAC1 (N=233, M=65 'A', A=0)
main ()

输出 #1

1

输入 #2

2
fac1 (N=250)
FAC1 (a=987)

输出 #2

1

说明/提示

每个函数的参数最多有10个,每行的输入数据长度均不超过255。

向本题主人公yyy2015c01同学致敬！

code:
// bool operator < (const vector<bool>&a,const vector<bool>&b){//不写其实没影响
// 	if(a.size() != b.size())
//         return a.size()<b.size();
// 	for(register int i=0;i<a.size();i++)
// 		if(a[i]^b[i])
//             return b[i];
// 	return 0;
// }
set<pair<string,vector<bool> > >st;
string input;
int n;
vector<bool>p;
bool readnxt(){
	bool f=0,tag=0;
	char c=getchar();
	while(c!=','&&c!=')'){
		if(c!='(')tag=1;
		if(c==39)f=1;
		c=getchar();
	}
	if(tag)p.push_back(f);
	return c!=')';
}
int main(){//有点看不懂 stl使用
	cin>>n;
	for(int tp=0;tp<n;tp++){
		cin>>input;
		for(int i=0;i<input.size();++i)
            if(isupper(input[i]))
                input[i]=input[i]-'A'+'a';
		if(input=="main"){
			getline(cin,input);
			continue;
		}
		for(p.clear();readnxt(););
		st.insert(make_pair(input,p));
	}
	cout<<st.size();
    return 0;
}

*/

/*
P2374 搬运工

题目背景

陈老师喜欢网购书籍，经常一次购它个百八十本，然后拿来倒卖牟取暴利。
题目描述

前些天，高一的新同学来了，他便像往常一样兜售他的书，经过一番口舌，同学们决定买他的书，但是陈老师桌上的书有三堆，每一堆都有厚厚的一叠，他要想个办法用最轻松的方式把书拿下来给同学们。但是你想逗一下陈老师，于是你设计一个最累的方式给他。若告诉你这三堆分别有 iii，jjj，kkk 本书，以及每堆从下到上书的质量，每次取书只能从任一堆的最上面取，那么请你设计一个方案，让他花最大的力气取下所有的书。

显然，每次取书陈老师的体力消耗都会加大，这里用体力系数代表，取下第一本书时，体力系数为 111，第二本书时体力系数为 222，依次类推，而每次体力消耗值则为体力系数与书的重量之积。
输入格式

第一行有三个整数，分别为三堆书的数量 iii，jjj，kkk。

第二行至第四行分别为每堆由下至上的书本重量。
输出格式

输出最累方式的体力消耗总值。
输入输出样例
输入 #1

3 2 4
2 3 2
1 5
9 8 7 4

输出 #1

257

说明/提示
数据规模与约定

    对于 50%50\%50% 的数据有 0≤i,j,k<100\le i,j,k\lt100≤i,j,k<10。
    对于 100%100\%100% 的数据有 0≤i,j,k<1000\le i,j,k\lt1000≤i,j,k<100。

最后输出的体力消耗总值在 C++ int 范围内。

code:
int k[4],bok[4][101],f[101][101][101],t;
int main() {//三维dp
	for(int i=1; i<=3; ++i)
		cin>>k[i];
	for(int i=1; i<=3; ++i)
		for(int j=1; j<=k[i]; ++j)
			cin>>bok[i][j];
	for(int i=k[1]; i>=0; --i)
		for(int j=k[2]; j>=0; --j)
			for(int l=k[3]; l>=0; --l) 
				t=k[1]+k[2]+k[3]-(i+j+l),f[i][j][l]=max(max(f[i+1][j][l]+bok[1][i+1]*t,f[i][j+1][l]+bok[2][j+1]*t),f[i][j][l+1]+bok[3][l+1]*t);
    cout<<f[0][0][0];
	return 0;
}

*/

/*
P2392 kkksc03考前临时抱佛脚

题目背景

kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。
题目描述

这次期末考试，kkksc03 需要考 444 科。因此要开始刷习题集，每科都有一个习题集，分别有 s1,s2,s3,s4s_1,s_2,s_3,s_4s1?,s2?,s3?,s4? 道题目，完成每道题目需要一些时间，可能不等（A1,A2,…,As1A_1,A_2,\ldots,A_{s_1}A1?,A2?,…,As1??，B1,B2,…,Bs2B_1,B_2,\ldots,B_{s_2}B1?,B2?,…,Bs2??，C1,C2,…,Cs3C_1,C_2,\ldots,C_{s_3}C1?,C2?,…,Cs3??，D1,D2,…,Ds4D_1,D_2,\ldots,D_{s_4}D1?,D2?,…,Ds4??）。

kkksc03 有一个能力，他的左右两个大脑可以同时计算 222 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。

由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。
输入格式

本题包含 555 行数据：第 111 行，为四个正整数 s1,s2,s3,s4s_1,s_2,s_3,s_4s1?,s2?,s3?,s4?。

第 222 行，为 A1,A2,…,As1A_1,A_2,\ldots,A_{s_1}A1?,A2?,…,As1?? 共 s1s_1s1? 个数，表示第一科习题集每道题目所消耗的时间。

第 333 行，为 B1,B2,…,Bs2B_1,B_2,\ldots,B_{s_2}B1?,B2?,…,Bs2?? 共 s2s_2s2? 个数。

第 444 行，为 C1,C2,…,Cs3C_1,C_2,\ldots,C_{s_3}C1?,C2?,…,Cs3?? 共 s3s_3s3? 个数。

第 555 行，为 D1,D2,…,Ds4D_1,D_2,\ldots,D_{s_4}D1?,D2?,…,Ds4?? 共 s4s_4s4? 个数，意思均同上。
输出格式

输出一行,为复习完毕最短时间。
输入输出样例
输入 #1

1 2 1 3		
5
4 3
6
2 4 3

输出 #1

20

说明/提示

1≤s1,s2,s3,s4≤201\leq s_1,s_2,s_3,s_4\leq 201≤s1?,s2?,s3?,s4?≤20。

1≤A1,A2,…,As1,B1,B2,…,Bs2,C1,C2,…,Cs3,D1,D2,…,Ds4≤601\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq601≤A1?,A2?,…,As1??,B1?,B2?,…,Bs2??,C1?,C2?,…,Cs3??,D1?,D2?,…,Ds4??≤60。

code:
int a[5],sum,t,homework[21],dp[2001];
int main(){
	for(int i=1;i<=4;i++)
		cin>>a[i];
	for(int i=1;i<=4;i++){
		sum=0;	
		for(int j=1;j<=a[i];j++)
			cin>>homework[j],sum+=homework[j];
		for(int j=1;j<=a[i];j++)
			for(int k=sum/2;k>=homework[j];k--)
				dp[k]=max(dp[k],dp[k-homework[j]]+homework[j]);
		t+=sum-dp[sum/2];
		for(int j=1;j<=sum/2;j++)
		    dp[j]=0;
	}
	cout<<t;
	return 0;
}

*/

/*
P2404 自然数的拆分问题

题目描述

任何一个大于1的自然数n，总可以拆分成若干个小于n的自然数之和。现在给你一个自然数n，要求你求出n的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。
输入格式

输入：待拆分的自然数n。
输出格式

输出：若干数的加法式子。
输入输出样例
输入 #1

7

输出 #1

1+1+1+1+1+1+1
1+1+1+1+1+2
1+1+1+1+3
1+1+1+2+2
1+1+1+4
1+1+2+3
1+1+5
1+2+2+2
1+2+4
1+3+3
1+6
2+2+3
2+5
3+4

说明/提示

用回溯做。。。。

n≤8n\le 8n≤8

code:
#include<bits/stdc++.h>
using namespace std;
int a[1000]={1},n;
void search(int s,int t){ 
	for(int i=a[t-1];i<=s;i++)
		if(i<n){
			a[t]=i;
			s-=i;
			if(s==0){
                for(int i=1;i<=t-1;i++)
                    cout<<a[i]<<"+";
                cout<<a[t]<<endl;
            }
            else search(s,t+1);
			s+=i;
		}
}
int main(){
	cin>>n;
	search(n,1);
	return 0;
}

*/

/*
P2429 制杖题

题目描述

求不大于 m 的、 质因数集与给定质数集有交集的自然数之和。
输入格式

第一行二个整数 n，m。

第二行 n 个整数，表示质数集内的元素 p[i]。
输出格式

一个整数，表示答案，对 376544743 取模。
输入输出样例
输入 #1

2 15
3 5

输出 #1

60

说明/提示

样例解释：所有符合条件的数为 3,5,6,9,10,12,15 其和为 60。

・・・ 测试点编号 规模

1 2 3 n*m<=10^7
4 5 n<=2，m<=10^9
6 7 n<=20，m<=10^8
8 9 10 n<=20，m<=10^9
・・・

code:
map<int,bool>l;
long long hrb[201],i,j,k,n,m,s=0,emm=1;
int main(){//stl map
    scanf("%lld%lld",&n,&m);
    for(i=1;i<=n;i++){
        scanf("%lld",&hrb[i]);
        for(k=1;;k++){
            emm=hrb[i]*k;
            if(emm>m)break;
            if(l[emm]==0)l[emm]=1,s=(s+emm)%376544743;
        }
    }
    cout<<s;
}

*/

/*
P2430 严酷的训练

题目背景

Lj的朋友WKY是一名神奇的少年，在同龄人之中有着极高的地位。。。
题目描述

他的老师老王对他的程序水平赞叹不已，于是下决心培养这名小子。

老王的训练方式很奇怪，他会一口气让WKY做很多道题，要求他在规定的时间完成。而老王为了让自己的威信提高，自己也会把这些题都做一遍。

WKY和老王都有一个水平值，他们水平值的比值和做这些题所用时间的比值成反比。比如如果WKY的水平值是1，老王的水平值是2，那么WKY做同一道题的时间就是老王的2倍。

每个题目有他所属的知识点，这我们都知道，比如递归，动归，最短路，网络流。在这里我们不考虑这些事情，我们只知道他们分别是知识点1，知识点2……每一个知识点有他对应的难度，比如动态规划经常难于模拟。

而每一个同一知识点下的题目，对于WKY来讲，都是一样难的。而做出每一道题，老王都有其独特的奖励值。而奖励值和题目的知识点没有必然联系。

现在WKY同学请你帮忙，计算在老王规定的时间内，WKY所能得到最大奖励值是多少 。
输入格式

输入文件包括以下内容：

第一行：

WKY的水平值和老王的水平值。

数据保证WKY的水平值小于老王的水平值（哪怕它不现实），且老王的水平值是WKY的水平值的整数倍。

第二行：

题目的总数m和知识点的总数n。

第三行：

n个整数。第i个整数表示 老王在做第i个知识点的题目所需的时间。

接下来有m行数每一行包括两个整数p，q。p表示该题目所属的知识点，q表示该题目对应的奖励值。

最后一行是规定的时间。
输出格式

输出文件只有一行，表示能到得到的最大奖励值。
输入输出样例
输入 #1

1 2
6 4
1 2 3 4
1 5
2 6
3 3
4 8
3 3
4 5
20

输出 #1

22

说明/提示

对于100%的数据，题目总数<=5000,规定时间<=5000

code:
int a,b,n,m,t,t1[5001],t2[5001],p[5001],q[5001],f[5001];
int main(){
	cin>>a>>b>>m>>n;
	for(int i=1;i<=n;i++)
		cin>>t1[i],t2[i]=t1[i]*(b/a);
	for(int i=1;i<=m;i++)
		cin>>p[i]>>q[i];
	cin>>t;
	for(int i=1;i<=m;i++)
		for(int j=t;j>=t2[p[i]];j--)
			f[j]=max(f[j],f[j-t2[p[i]]]+q[i]);
	cout<<f[t];
	return 0;
}

*/

/*
P2437 蜜蜂路线

题目背景

无
题目描述

一只蜜蜂在下图所示的数字蜂房上爬动,已知它只能从标号小的蜂房爬到标号大的相邻蜂房,现在问你：蜜蜂从蜂房 mmm 开始爬到蜂房 nnn，m<nm<nm<n，有多少种爬行路线？（备注：题面有误，右上角应为 n?1n-1n?1）

输入格式

输入 m,nm,nm,n 的值
输出格式

爬行有多少种路线
输入输出样例
输入 #1

1 14

输出 #1

377

说明/提示

对于100%的数据，M,N≤1000M,N\le 1000M,N≤1000

code:
int n,m,t,a[1001][211];
bool pd=0;
int main(){//斐波那契数列 大数加法 1000位斐波那契数 4.3*10^208位
    cin>>m>>n;
	t=n-m;
	a[0][1]=0,a[1][1]=1,a[2][1]=2;
	for(int i=3;i<=t;i++){
		for(int j=1;j<210;j++) 
		    a[i][j]=a[i-1][j]+a[i-2][j];
		for(int j=1;j<210;j++)
			if(a[i][j]>9)
				a[i][j+1]=a[i][j+1]+a[i][j]/10,a[i][j]=a[i][j]%10;
	}
	for(int i=210;i>=1;i--){
		if(!pd&&a[t][i]==0)continue;
		pd=1;
        cout<<a[t][i];
	}
	return 0;
}

*/

/*
P2548 [AHOI2004]智能探险车

略 https://www.luogu.com.cn/problem/P2548

code:
string s[1001][101];
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=n;i++)
		cin>>s[1][i],s[0][i]=s[1][i];
	for(int i=2;i<=m;++i)
		for(int j=1;j<=n;j++){
			cin>>s[i][j];
			if (s[i][j]!=s[0][j])
				s[0][j]="*";
		}
	for(int i=1;i<=n;i++)
		cout<<s[0][i]<<" ";
	return 0;
}

*/

/*
P2556 [AHOI2002]黑白图像压缩

题目描述

选修基础生物基因学的时候， 小可可在家里做了一次图像学试验。 她知道：整个图像其实就是若干个图像点(称作像素)的序列，假定序列中像素的个数总是 8 的倍数， 于是每八个像素可以转换成一个叫做字节的数， 从而这个表示图像的像素序列就被转换成了字节的序列。

所谓的字节就是一个八位的二进制数(当然，为了便于书写，人们经常用它的十进制形式来表示)。这八个像素从前向后依次对应于字节从高位到低位的八个位， 用 0 来表示白色像素、 1 来表示黑色像素。 这种表示方法叫做位图法。 例如字节序列 210、 0、255 表示了 8*3=24 个像素， 由于对应的二进制形式是 11010010、 00000000、11111111， 所以这 24 个像素的颜色依次是黑、 黑、 白、 黑、 白、 白、 黑、 白、白、白、白、白、白、白、白、白、黑、黑、黑、黑、黑、黑、黑、黑。

小可可想： 其实图像中存在着很多连续的同色像素段， 也许换一种方式表达图像能够减少图像的数据量。 她的思路是： 把像素按照颜色分成若干个片段， 同一个片段中各像素颜色相同， 且连续的同色像素都在同一个片段中。同时已知每个片段的最大长度小于 128。

每一个像素片段都是用一个二进制字节量来表示， 最高位表示片段中像素的颜色， 而低七位表示片段中像素的数目。注意：不存在长度为 0 的像素片段。这种表示法叫做像素片段法。

例如位图表示法的字节序列 210、 0、 255 对应的像素序列可以分成七个片段，分别是： 11、 0、 1、 00、 1、 000000000、 11111111。如果用像素片段法来表示的话，二进制字节序列应该写成 10000010、 00000001、 10000001、00000010、 10000001、 00001001、 10001000， 而其对应于十进制字节序列就是 130、 1、 129、 2、 129、 9、 136。

像素片段法是否能有效地减少图像的数据存储量呢？小可可不知道如何用数学的方法加以证明， 于是决心对手头上的图像做些试验， 看看该方法是否真的有效。 请你编写程序完成图像信息的转换， 以协助小可可完成这项试验。
输入格式

文件中以一行的形式存放了一个图像的信息。第一个数是正整数 nnn ，表明该图像有 nnn 个像素。随后有 n8\frac{n}{8}8n? 个十进制形式的字节量，表示该图像的位图信息。相邻数之间用一个空白字符隔开。
输出格式

以一行的形式输出以像素片段表示法表示的图像信息，各个数都以

十进制的形式出现，相邻数之间用一个空白字符隔开。
输入输出样例
输入 #1

8 0

输出 #1

8

输入 #2

24 210 0 255

输出 #2

130 1 129 2 129 9 136

说明/提示

1≤n≤8×1041\leq n\leq 8\times 10^41≤n≤8×104。

code:
int n,dq=2,add,x,wz[10];
int main(){
    cin>>n;
    for(int i=1;i<=n/8;i++){
        cin>>x;
        for(int j=8;j>0;j--)
            wz[j]=x%2,x=x/2;
        for(int j=1;j<=8;j++)     
            if(dq!=wz[j]){
                if(dq!=2)
                    cout<<add+128*dq<<" ";
                dq=wz[j];
                add=1;
            }
            else add++;
    }
    cout<<add+128*dq;
}

*/

/*
P2562 [AHOI2002]Kitty猫基因编码

题目描述

小可可选修了基础生物基因学。教授告诉大家 Super Samuel 星球上 Kitty猫的基因的长度都是 2 的正整数次幂 )， 全是由两种不同的基因单元组成的。 这两种不同的基因单元分别记成 0 和 1，于是 Kitty 猫基因可以写成一个 01 串表达式 。

为了便于分析和降低数据存储量，教授发明了 ABC 编码规则。该编码规则是不断地按照

对 Kitty 猫基因 01 串表达式 进行改写， 直至最终被改写成只含有字符 “ A”、“ B”、“ C”的符号串。

请你编写程序帮助小可可求出 Kitty 猫基因的 ABC 编码以协助教授开展科研工作。
输入格式

文件中以一行的形式存放了一个 Kitty 猫基因的 01 串表达式。
输出格式

以一行的形式输出这个 Kitty 猫基因的 ABC 编码。
输入输出样例
输入 #1

00

输出 #1

A

输入 #2

01001011

输出 #2

CCCABACCBAB

说明/提示

给出的01字符串长度Len≤256Len\leq 256Len≤256

code:
string a;
string t(string a,int n){
    if(a.find('1')==-1)return "A";
    if(a.find('0')==-1)return "B";
    //string.find("a")   输出a在string中的位置 未找到返回-1
    return "C"+t(a.substr(0,n/2),n/2)+t(a.substr(n/2,n/2),n/2);
    //string.substr(a,b) 输出string从a到b的
}
int main(){//string用法
    cin>>a;
    cout<<t(a,a.size());
    return 0;
}

*/

/*
P2563 [AHOI2001]质数和分解

题目描述

任何大于 111 的自然数 nnn 都可以写成若干个大于等于 222 且小于等于 nnn 的质数之和表达式(包括只有一个数构成的和表达式的情况)，并且可能有不止一种质数和的形式。例如，999 的质数和表达式就有四种本质不同的形式：

9=2+5+2=2+3+2+2=3+3+3=2+79 = 2 + 5 + 2 = 2 + 3 + 2 + 2 = 3 + 3 + 3 = 2 + 79=2+5+2=2+3+2+2=3+3+3=2+7 。

这里所谓两个本质相同的表达式是指可以通过交换其中一个表达式中参加和运算的各个数的位置而直接得到另一个表达式。

试编程求解自然数 nnn 可以写成多少种本质不同的质数和表达式。
输入格式

文件中的每一行存放一个自然数 n(2≤n≤200)n(2 \leq n \leq 200)n(2≤n≤200) 。
输出格式

依次输出每一个自然数 nnn 的本质不同的质数和表达式的数目。
输入输出样例
输入 #1

2
200

输出 #1

1
9845164

code:
int n,su[201],f[201];
bool pan(int x){//是否质数
    for(int i=2;i<=sqrt(x);i++)
        if(x%i==0) 
            return 0;
    return 1;
}
int main(){
    while(cin>>n){
        int num=0;
        for(int i=2;i<=n;i++)
            if(pan(i))
                su[++num]=i;        
        memset(f,0,sizeof(f));f[0]=1;
        for(int i=1;i<=num;i++)
            for(int j=su[i];j<=200;j++)
                f[j]+=f[j-su[i]];
        cout<<f[n]<<endl;
    }
    return 0;
}

*/

/*
P2614 计算器弹琴

题目描述

总所周知，计算器可以拿来干很多它本不应该干的事情，比如写作文。（参看洛谷P2549）

小A发现了一个计算器的另一个隐藏功能――弹琴。

http://www.bilibili.com/video/av2205500/

如果按上一个键，比如说1，就会发出中音“Do”。

这边给出按键音高表

+ 低音Fa
< 低音So
* 低音La
/ 低音Xi
1 中音Do
2 中音Re
3 中音Mi
4 中音Fa
5 中音So
6 中音La
7 高音Xi
8 高音Do
9 高音Re
= 高音Mi
% 高音Fa
C 高音So
M 高音La

现在小A搞到了一份乐谱――我们称为计算器谱，一种变形的简谱。

时值（也就是按的时间长度）是这么记录的，例如：

1 是四分音符，占1拍。

1- 是二分音符，占2拍。

1--- 是全音符，占四拍。

对于小于四分音符的音符，我们用嵌套括号表示，例如

(1(34(56))2)

1和2在一层括号中，是八分音符，占0.5拍。

3和4在两层括号中，是16分音符，占0.25拍。

5和6在三层括号中，是32分音符，占1/8拍。当然实际上比较少见。

括号中不会出现‘-’这个符号。

不会出现四层或以上的括号。

在一个音符后面添加一个附点即“.”表示这个音符延长1/2倍。

例如 1-.是3拍，1.是1.5拍，(3.(45.))3是3/4拍，4是1/4拍，5是3/8拍。

附点不会连续添加两个或以上，也不会出现超过四拍的音符。

不考虑其他的乐理符号。

另外整个乐谱会给一个速度，整数，意思是一分钟多少拍。

为了美观，乐谱可以随便换行、添加空格。这个忽略即可。

现在小A想知道，按完这个谱子，需要多少时间（单位：秒）
输入格式

第一行，两个整数n,T，表示谱子行数以及速度（拍每分）

接下来n行，给出乐谱。
输出格式

一个整数，表示演奏需要花费的时间，单位秒，舍去小数部分。
输入输出样例
输入 #1

2 60
3345 5432 1123 322-
3345 5432 1123 211-

输出 #1

32

输入 #2

5 120
3(1.(3))55 8(7.(6))65 655(3.(1)) (4.(4))32- 
3(1.(2))35 8(7.(6))65 655(4.(3)) (2.(3))21- 
2.(3)44 6(6.(6))(5.(4))3 3.(5)88 (9.(8)7.(6))5-
=.(=)(9.(8))7 9.(8)(7.(6))5  8(856543) (2.(3))43- 
=.(=)(9.(8))7 9.(8)(7.(6))5  8(857654) (3.(4))21- 

输出 #2

40

说明/提示

样例1说明：（一共32拍，每分钟60拍，所以是32秒。对了，这是欢乐颂的开头部分）

样例2说明：（一共80拍，别问我怎么数的，一分钟120拍的话，是40秒。至于这是什么曲子？根据相关的法律政策，该部分未予显示。）

http://bd.kuwo.cn/yinyue/4641527

对于40%的数据，没有附点没有括号

对于100%的数据，括号层数不会超过3层，不超过100行，每行不超过100个字符。

对于其中的一个数据，是《千本樱》。

code:
long long n,T,st,Length;
double itime=0;
string s;
int main(){//模拟
    ios::sync_with_stdio(false);//cincout输入输出取消存入缓冲区 增加输入输出的运行速度
    cin>>n>>T;
    while(cin>>s){
        st=0;
        Length=s.length();
        while(Length--)
            switch(s[s.length()-Length-1]){
                case ' ':
                case '\r':
                case '\n':break;
                case '(':st++;break;
                case ')':st--;break;
                case '.':itime+=pow(0.5,st+1);break;
                default:itime+=pow(0.5,st);
        }
    }
    cout<<(int)itime*60/T;
    return 0;
}

*/

/*
P2615 [NOIP2015 提高组] 神奇的幻方

题目描述

幻方是一种很神奇的 N?NN*NN?N 矩阵：它由数字 1,2,3,???,N×N1,2,3,\cdots \cdots ,N \times N1,2,3,??,N×N 构成，且每行、每列及两条对角线上的数字之和都相同。

当 NNN 为奇数时，我们可以通过下方法构建一个幻方：

首先将 111 写在第一行的中间。

之后，按如下方式从小到大依次填写每个数 K(K=2,3,??,N×N)K (K=2,3,\cdots,N \times N)K(K=2,3,?,N×N) ：

    若 (K?1)(K-1)(K?1) 在第一行但不在最后一列，则将 KKK 填在最后一行， (K?1)(K-1)(K?1) 所在列的右一列；
    若 (K?1)(K-1)(K?1) 在最后一列但不在第一行，则将 KKK 填在第一列， (K?1)(K-1)(K?1) 所在行的上一行；
    若 (K?1)(K-1)(K?1) 在第一行最后一列，则将 KKK 填在 (K?1)(K-1)(K?1) 的正下方；
    若 (K?1)(K-1)(K?1) 既不在第一行，也不在最后一列，如果 (K?1)(K-1)(K?1) 的右上方还未填数，则将 KKK 填在 (K?1)(K-1)(K?1) 的右上方，否则将 KKK 填在 (K?1)(K-1)(K?1) 的正下方。

现给定 NNN ，请按上述方法构造 N×NN \times NN×N 的幻方。
输入格式

一个正整数 NNN ，即幻方的大小。
输出格式

共 NNN 行 ，每行 NNN 个整数，即按上述方法构造出的 N×NN \times NN×N 的幻方，相邻两个整数之间用单空格隔开。
输入输出样例
输入 #1

3

输出 #1

8 1 6
3 5 7
4 9 2

输入 #2

25

输出 #2

327 354 381 408 435 462 489 516 543 570 597 624 1 28 55 82 109 136 163 190 217 244 271 298 325
353 380 407 434 461 488 515 542 569 596 623 25 27 54 81 108 135 162 189 216 243 270 297 324 326
379 406 433 460 487 514 541 568 595 622 24 26 53 80 107 134 161 188 215 242 269 296 323 350 352
405 432 459 486 513 540 567 594 621 23 50 52 79 106 133 160 187 214 241 268 295 322 349 351 378
431 458 485 512 539 566 593 620 22 49 51 78 105 132 159 186 213 240 267 294 321 348 375 377 404
457 484 511 538 565 592 619 21 48 75 77 104 131 158 185 212 239 266 293 320 347 374 376 403 430
483 510 537 564 591 618 20 47 74 76 103 130 157 184 211 238 265 292 319 346 373 400 402 429 456
509 536 563 590 617 19 46 73 100 102 129 156 183 210 237 264 291 318 345 372 399 401 428 455 482
535 562 589 616 18 45 72 99 101 128 155 182 209 236 263 290 317 344 371 398 425 427 454 481 508
561 588 615 17 44 71 98 125 127 154 181 208 235 262 289 316 343 370 397 424 426 453 480 507 534
587 614 16 43 70 97 124 126 153 180 207 234 261 288 315 342 369 396 423 450 452 479 506 533 560
613 15 42 69 96 123 150 152 179 206 233 260 287 314 341 368 395 422 449 451 478 505 532 559 586
14 41 68 95 122 149 151 178 205 232 259 286 313 340 367 394 421 448 475 477 504 531 558 585 612
40 67 94 121 148 175 177 204 231 258 285 312 339 366 393 420 447 474 476 503 530 557 584 611 13
66 93 120 147 174 176 203 230 257 284 311 338 365 392 419 446 473 500 502 529 556 583 610 12 39
92 119 146 173 200 202 229 256 283 310 337 364 391 418 445 472 499 501 528 555 582 609 11 38 65
118 145 172 199 201 228 255 282 309 336 363 390 417 444 471 498 525 527 554 581 608 10 37 64 91
144 171 198 225 227 254 281 308 335 362 389 416 443 470 497 524 526 553 580 607 9 36 63 90 117
170 197 224 226 253 280 307 334 361 388 415 442 469 496 523 550 552 579 606 8 35 62 89 116 143
196 223 250 252 279 306 333 360 387 414 441 468 495 522 549 551 578 605 7 34 61 88 115 142 169
222 249 251 278 305 332 359 386 413 440 467 494 521 548 575 577 604 6 33 60 87 114 141 168 195
248 275 277 304 331 358 385 412 439 466 493 520 547 574 576 603 5 32 59 86 113 140 167 194 221
274 276 303 330 357 384 411 438 465 492 519 546 573 600 602 4 31 58 85 112 139 166 193 220 247
300 302 329 356 383 410 437 464 491 518 545 572 599 601 3 30 57 84 111 138 165 192 219 246 273
301 328 355 382 409 436 463 490 517 544 571 598 625 2 29 56 83 110 137 164 191 218 245 272 299

说明/提示

对于100%100\%100%的数据，对于全部数据， 1≤N≤391 \leq N \leq 391≤N≤39 且 NNN 为奇数。

NOIp2015 提高组 d1t1

code:
int n,a[40][40],x,y;
int main(){//模拟 
	scanf("%d",&n);
	x=1,y=(n+1)/2;
	for(int i=1;i<=n*n;i++){
		a[x][y]=i;
		if(!a[(x-2+n)%n+1][y%n+1]) x=(x-2+n)%n+1,y=y%n+1;
		else x=x%n+1;
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++)
			cout<<a[i][j]<<" ";
        cout<<endl;
	}
} 

*/

/*
P2616 [USACO10JAN]Buying Feed, II S

题目描述

Farmer John needs to travel to town to pick up K (1 <= K <= 100) pounds of feed. Driving D miles with K pounds of feed in his truck costs D*K cents.

The county feed lot has N (1 <= N <= 100) stores (conveniently numbered 1..N) that sell feed. Each store is located on a segment of the X axis whose length is E (1 <= E <= 350). Store i is at location X_i (0 < X_i < E) on the number line and can sell FJ as much as F_i (1 <= F_i <= 100) pounds of feed at a cost of C_i (1 <= C_i <= 1,000,000) cents per pound. Amazingly, a given point on the X axis might have more than one store.

FJ starts at location 0 on this number line and can drive only in the positive direction, ultimately arriving at location E, with at least K pounds of feed. He can stop at any of the feed stores along the way and buy any amount of feed up to the the store's limit.

What is the minimum amount FJ has to pay to buy and transport the K pounds of feed? FJ knows there is a solution.

Consider a sample where FJ needs two pounds of feed from three stores (locations: 1, 3, and 4) on a number line whose range is 0..5:

0   1   2   3   4   5 
+---|---+---|---|---+ 
    1       1   1      Available pounds of feed 
    1       2   2      Cents per pound 

It is best for FJ to buy one pound of feed from both the second and third stores. He must pay two cents to buy each pound of feed for a total cost of 4. When FJ travels from 3 to 4 he is moving 1 unit of length and he has 1 pound of feed so he must pay 1*1 = 1 cents.

When FJ travels from 4 to 5 he is moving one unit and he has 2 pounds of feed so he must pay 1*2 = 2 cents.

The total cost is 4+1+2 = 7 cents.

FJ开车去买K份食物，如果他的车上有X份食物。每走一里就花费X元。 FJ的城市是一条线，总共E里路，有E+1个地方，标号0~E。 FJ从0开始走，到E结束（不能往回走），要买K份食物。 城里有N个商店，每个商店的位置是X_i（一个点上可能有多个商店），有F_i份食物，每份C_i元。 问到达E并买K份食物的最小花费
输入格式

输出格式

输入输出样例
输入 #1

2 5 3
3 1 2
4 1 2
1 1 1

输出 #1

7

code:
long long k,e,n,ans,t;
struct node{
	int x,f,c;
}a[550];
bool cmp(node x,node y){return x.c<y.c;}
int main(){cin>>k>>e>>n;
	for(int i=1;i<=n;i++)
		cin>>a[i].x>>a[i].f>>a[i].c,a[i].c+=e-a[i].x;
	sort(a+1,a+n+1,cmp);
	for(int i=1;i<=n;i++)
		if(t+a[i].f>k){
			ans+=(k-t)*a[i].c,cout<<ans;
	        return 0;
		}
		else ans+=a[i].f*a[i].c,t+=a[i].f;
}

*/