#include <bits/stdc++.h>
#include <initializer_list>
#include <unordered_map>
#include <bits/stdc++.h>
#include <stdexcept>
#include <algorithm>
#include <iostream>
#include <string.h>
#include <stdio.h>
#include <fstream>
#include <sstream>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <vector>
#include <memory>
#include <string>
#include <ctime>
#include <cmath>
#include <deque>
#include <list>
#include <map>

using namespace std;

/*
P1000 超级玛丽游戏

题目背景

本题是洛谷的试机题目，可以帮助了解洛谷的使用。

建议完成本题目后继续尝试P1001、P1008。

另外强烈推荐新用户必读贴
题目描述

超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景。

                ********
               ************
               ####....#.
             #..###.....##....
             ###.......######              ###            ###
                ...........               #...#          #...#
               ##*#######                 #.#.#          #.#.#
            ####*******######             #.#.#          #.#.#
           ...#***.****.*###....          #...#          #...#
           ....**********##.....           ###            ###
           ....****    *****....
             ####        ####
           ######        ######
##############################################################
#...#......#.##...#......#.##...#......#.##------------------#
###########################################------------------#
#..#....#....##..#....#....##..#....#....#####################
##########################################    #----------#
#.....#......##.....#......##.....#......#    #----------#
##########################################    #----------#
#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#
##########################################    ############

输入格式

无
输出格式

如描述
输入输出样例

无

code:
int main() {
  std::cout << R"(                ********
               ************
               ####....#.
             #..###.....##....
             ###.......######              ###            ###
                ...........               #...#          #...#
               ##*#######                 #.#.#          #.#.#
            ####*******######             #.#.#          #.#.#
           ...#***.****.*###....          #...#          #...#
           ....**********##.....           ###            ###
           ....****    *****....
             ####        ####
           ######        ######
##############################################################
#...#......#.##...#......#.##...#......#.##------------------#
###########################################------------------#
#..#....#....##..#....#....##..#....#....#####################
##########################################    #----------#
#.....#......##.....#......##.....#......#    #----------#
##########################################    #----------#
#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#
##########################################    ############ )";
}

*/

/*
P1001 A+B Problem

题目背景

强烈推荐新用户必读贴

不熟悉算法竞赛的选手请看这里：

算法竞赛中要求的输出格式中，不能有多余的内容，这也包括了“请输入整数a和b”这一类的提示用户输入信息的内容。若包含了这些内容，将会被认为是 Wrong Answer，即洛谷上的 WA。忽略每一行结尾的空格，以及最后一行之后，多余的换行符。





若因此类问题出现本机（看起来） AC，提交 WA 的现象，请勿认为是洛谷评测机出了问题，而是你的代码中可能存在多余的输出

息。用户可以参考在题目末尾提供的代码。

另外请善用应用中的在线IDE功能，以避免不同平台的评测中所产生的一些问题。

还有一点很重要的是，请不要在对应的题目下面发自己的题解，请发布到题解区域中，否则将处以删除-禁言的处罚。若发现无法提交题解则表明本题题解数量过多。
题目描述

输入两个整数 a,ba,ba,b，输出它们的和（OaO,ObO≤109|a|,|b|\leq 10^9OaO,ObO≤109）。

注意

    Pascal 使用 integer 会爆掉哦！
    有负数哦！
    C/C++ 的 main 函数必须是 int 类型，而且最后要 return 0。这不仅对洛谷其他题目有效，而且也是 NOIP/NO
 /CSP 比赛的要求！

好吧，同志们，我们就从这一题开始，向着大牛的路进发。

    任何一个伟大的思想，都有一个微不足道的开始。

输入格式

两个整数以空格分开。
输出格式

一个整数。
输入输出样例
输入 #1

20 30

输出 #1

50

code:
int main()
{
int a,b;
cin>>a>>b;
cout<<a+b;
}

*/

/*
P1014 [NOIP1999 普及组] Cantor 表

题目描述

现代数学的著名证明之一是 Georg Cantor 证明了有理数是可枚举的。他是用下面这一张表来证
 这一命题的：

1/11/11/1 , 1/21/21/2 , 1/31/31/3 , 1/41/41/4, 1/51/51/5, …

2/12/12/1, 2/22/22/2 , 2/32/32/3, 2/42/42/4, …

3/13/13/1 , 3/23/23/2, 3/33/33/3, …

4/14/14/1, 4/24/24/2, …

5/15/15/1, …

…

我们以 Z 字形给上表的每一项编号。第一项是 1/11/11/1，然后是 1/21/21/2，2/12/12/1，3/13/13/1，2/22/22/2，…
 输入格式

整数NNN（1≤N≤1071 \leq N \leq 10^71≤N≤107）。
输出格式

表中的第 NNN 项。
输入输出样例
输入 #1

7

输出 #1

1/4

code:
int main()
{
    int a,b=1;
    cin>>a;
    if(a==1)
    {
        cout<<"1/1";
    }
    else
    {
        for(int i=1;i<a;i++)
        {
            a=a-i;
            if(a==1)
            {
                b=b+1;
                break;
            }
            else if(a<=0)
            {
                break;
            }
            b=b+1;
        }
        cout<<(b+1-a)<<"/"<<a;
    }
    return 0;
}

*/

/*
P1024 [NOIP2001 提高组] 一元三次方程求解

题目描述

有形如：ax3+bx2+cx+d=0a x^3 + b x^2 + c x + d = 0ax3+bx2+cx+d=0 这样的一个一元
次方程。给出该方程中各项的系数（a,b,c,da,b,c,da,b,c,d 均为实数），并约定该方程存在三个不同实根（根的范围在 ?100
100?100 至 100100100 之间）
 且根与根之差的绝对值 ≥1\ge 1≥1。要求由小到大依次在同一行输出这三个
根(根与根之间留有空格)，并精确到小数点后 222 位。





提示：记方程 f(x)=0f(x) = 0f(x)=0，若存在 222 个数 x1x_1x1? 和 x2x_2x2?，且 x1<x2x_1 < x_2x1?<x2?，f(x1)×f(x2)
 0f(x_1) \times f(x_2) <
0f(x1?)×f(x2?)<0，则在 (x1,x2)(x_1, x_2)(x1 ,x2?) 之
一定有一个根。 输入格式

一行，444 个实数 a,b,c,da, b, c, da,b,c,d。
输出格式

一行，333 个实根，从小到大输出，并精确到小数点后 222 位。
输入输出样例
输入 #1

1 -5 -4 20

输出 #1

-2.00 2.00 5.00

说明/提示

【题目来源】

NOIP 2001 提高组第一题

code:
double a,b,c,d;
double fc(double x)
{
    return a*x*x*x+b*x*x+c*x+d;
}
int main()
{
    double l,r,m,x1,x2;
    int s=0,i;
    scanf("%lf%lf%lf%lf",&a,&b,&c,&d);  //输入
    for (i=-100;i<100;i++)
    {
        l=i;
        r=i+1;
        x1=fc(l);
        x2=fc(r);
        if(!x1)
        {
            printf("%.2lf ",l);
            s++;
        }      //判断左端点，是零点直接输出。
                        
                        //不能判断右端点，会重复。
        if(x1*x2<0)                             //区间内有根。
        {
            while(r-l>=0.001)                     //二分控制精度。
            {
                m=(l+r)/2;  //middle
                if(fc(m)*fc(r)<=0)
                   l=m;
                else
                   r=m;   //计算中点处函数值缩小区间。
            }
            printf("%.2lf ",r);
            //输出右端点。
            s++;
        }
        if (s==3)
            break;
            //找到三个就退出大概会省一点时间
    }
    return 0;
}
*/

/*
P1035 [NOIP2002 普及组] 级数求和

题目描述

已知：Sn=1+1/2+1/3+…+1/nS_n= 1+1/2+1
3+…+1/nSn?=1+1/2+1/3+…+1/n。显然对于任意一个整数 kkk，当 nnn 足够大的时候，Sn>kS_n>kSn?>k。



现给出一个整数 kkk，要求计算出一个最小的 nnn，使得 Sn>kS_n>kSn?>k。
 输入格式

一个正整数 kkk。
输出格式

一个正整数 nnn。
输入输出样例
输入 #1

1

输出 #1

2

说明/提示

【数据范围】

对于 100%100\%100% 的数据，1≤k≤151\le k \le 151≤k≤15。

【题目来源】

NOIP 2002 普及组第一题

code:
int main()
{
    double a,n,s=1;
    cin>>a;
    if(a<1)
    {
    cout<<"1";
    }
    else
    {
    n=1;
    while(a>=s)
    {
    n=n+1;
    s=s+1/n;
    }
    }
    cout<<n;
    return 0;
}

*/

/*
P1046 [NOIP2005 普及组] 陶陶摘苹果

题目描述

陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 101010 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 303030 厘米高的板凳，当她不能直接

 手摘到苹果的时候，就会踩到板凳上再试试。


现在已知 101010 个苹果到地面的
度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。
输入格式

输入包括两行数据。第一行包含 101010 个 100100100 到 200200200 之间（包括 100100100 和 200200200 ）的整数（以厘米为单位）分别表示 10
 010
个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 100100100 到 120120120 之间（包含 100100100 和
 120120120
）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。

 输出格式

输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。
输入输出样例
输入 #1

100 200 150 140 129 134 167 198 200 111
110

输出 #1

5

说明/提示

【题目来源】

NOIP 2005 普及组第一题

code:
int main()
{
    int a[10],b,n=0;
    for(int i=0;i<10;i++)
    {
    cin>>a[i];
    }
    cin>>b;
    for(int i=0;i<10;i++)
    {
    if(a[i]<=(b+30))n++;
    }
    cout<<n;
    return 0;
}

*/

/*
P1047 [NOIP2005 普及组] 校门外的树

题目描述

某校大门外长度为 lll 的马路上有一排树，每两棵相邻的树之间的间隔都是 111 米。我们可以把马路看成一个数轴，马路的一端在数轴 000 的位置，另一端在 lll 的位置；数轴上的每个整数点，即 0,1

 2,…,l0,1,2,\dots,l0,1,2,…,l，都种有一棵树。


由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。
输入格式

第一行有两个整数，分别表示马路的长度 lll 和区域的数目 mmm。

接下来 mmm 行，每行两个整数 u,vu, vu,v，表示一个区域的起始点和终止点的坐标。
输出格式

输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。
输入输出样例
输入 #1

500 3
150 300
100 200
470 471

输出 #1

298

说明/提示

【数据范围】

    对于 20%20\%20% 的数据，保证区域之间没有重合的部分。
    对于 100%100\%100% 的数据，保证 1≤l≤1041 \leq l \leq 10^41≤l≤104，1≤m≤1001 \leq m \leq 1001≤m≤100，0≤u≤v≤
 0 \leq u \leq v \leq l0≤u≤v≤l。

【题目来源】

NOIP 2005 普及组第二题

code:
int main()
{
    bool a[10000];
    int l,m,u,v,n=0;
    cin>>l>>m;
    for(int i=0;i<=l;i++)a[i]=1;
    for(int i=0;i<m;i++)
    {
    cin>>u>>v;
    for(int j=u;j<=v;j++)a[j]=0;
    }
    for(int i=0;i<=l;i++)
    {
    if(a[i]==1)n++;
    }
    cout<<n;
    return 0;
}

*/

/*
P1059 [NOIP2006 普及组] 明明的随机数

题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了NNN个111到100010001000之间的随机整数(N≤100)(N≤100)(N≤100)，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。
输入格式

输入有两行，第111行为111个正整数，表示所生成的随机数的个数NNN

第222行有NNN个用空格隔开的正整数，为所产生的随机数。
输出格式

输出也是两行，第111行为111个正整数MMM，表示不相同的随机数的个数。

第222行为MMM个用空格隔开的正整数，为从小到大排好序的不相同的随机数。
输入输出样例
输入 #1

10
20 40 32 67 40 20 89 300 400 15

输出 #1

8
15 20 32 40 67 89 300 400

说明/提示

NOIP 2006 普及组 第一题

code:
int main()
{
    int n,m[100],i=0;
    cin>>n;
    for(int j=0;j<n;j++)cin>>m[j];
    sort(m,m+n);
    unique(m,m+n);
    while(m[i]<m[i+1])i++;
    cout<<i+1<<endl;
    for(int j=0;j<i;j++)cout<<m[j]<<" ";
    cout<<m[i];
    return 0;
}

*/

/*
P1075 [NOIP2012 普及组] 质因数分解

题目描述

已知正整数nnn是两个不同的质数的乘积，试求出两者中较大的那个质数。
输入格式

一个正整数nnn。
输出格式

一个正整数ppp，即较大的那个质数。
输入输出样例
输入 #1

21

输出 #1

7

说明/提示

n≤2×109n\le 2\times 10^9n≤2×109

NOIP 2012 普及组 第一题

code:
int main()
{
    int n,p;
    cin>>n;
    for(int i=2;i<sqrt(n);i++)
    {
    if(n%i==0)
    {
    cout<<n/i;
    break;
    }
    }
    return 0;
}

*/

/*
P1085 [NOIP2004 普及组] 不高兴的津津

题目描述

津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。
输入格式

输入包括777行数据，分别表示周一到周日的日程安排。每行包括两个小于101010的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。
输出格式

一个数字。如果不会不高兴则输出000，如果会则输出最不高兴的是周几（用1,2,3,4,5,6,71, 2, 3, 4, 5, 6, 71,2,3,4,5,6,7分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天


上不高兴的程度相当，则输出时
最靠前的一天。
输入输出样例
输入 #1

5 3
6 2
7 2
5 3
5 4
0 4
0 6

输出 #1

3

说明/提示

noip2004普及组第1题

code:
int main()
{
    int n,m,max=8,t=0,p=1;
    for(int i=0;i<7;i++)
    {
    cin>>n>>m;
    if((n+m)>max)
    {
    t=p;
    max=n+m;
    }
    p++;
    }
    cout<<t;
    return 0;
}

*/

/*
P1089 [NOIP2004 提高组] 津津的储蓄计划

题目描述

津津的零花钱一直都是自己管理。每个月的月初妈妈给津津300300300元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。

为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上20%20\%20%还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于100100100元或恰好100100100元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。

例如111111月初津津手中还有838383元，妈妈给了津津300300300元。津津预计111111月的花销是180180180元，那么她就会在妈妈那里存200200200元，自己留下183183183元。到了111111月月末，津津手中会剩下333元钱。

津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。

现在请你根据2004年1月到12月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到2004年年末，妈妈将津津平常存的钱加上20％还给津津之后，津津手中会有多少钱。
输入格式

121212行数据，每行包含一个小于350350350的非负整数，分别表示111月到121212月津津的预算。
输出格式

一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出?X-X?X，XXX表示出现这种情况的第一个月；否则输出到200420042004年年末津津手中会有多少钱。

注意，洛谷不需要进行文件输入输出，而是标准输入输出。
输入输出样例
输入 #1

290
230
280
200
300
170
340
50
90
80
200
60

输出 #1

-7

输入 #2

290
230
280
200
300
170
330
50
90
80
200
60

输出 #2

1580

code:
int main()
{
    int n,s=0,g=0;
    for(int i=0;i<12;i++)
    {
    cin>>n;
    s=s+300;
    if((s-n)/100>0)
    {
    g=g+(s-n)/100;
    s=s-(s-n)/100*100;
    }
    s=s-n;
    if(s<0)
    {
    cout<<-(i+1);
    break;
    }
    else if(i==11)
    {
    cout<<g*100*1.2+s;
    }
    }
    return 0;
}

*/

/*
P1116 车厢重组

题目描述

在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转180180180度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。
输入格式

共两行。

第一行是车厢总数N(≤10000)N( \le 10000)N(≤10000)。

第二行是NNN个不同的数表示初始的车厢顺序。
输出格式

一个整数，最少的旋转次数。
输入输出样例
输入 #1

4
4 3 2 1

输出 #1

6

说明/提示

code:
int main()
{
    int n,sum=0;
    cin>>n;
    int m[n];
    for(int i=0;i<n;i++)cin>>m[i];
    for(int i=0;i<n;i++)
        for(int j=0;j<i;j++)
            if (m[j] > m[i])sum++;
    cout<<sum;
    return 0;
}

*/

/*
P1146 硬币翻转

题目描述

在桌面上有一排硬币，共NNN枚，每一枚硬币均为正面朝上。现在要把所有的硬币翻转成反面朝上，规则是每次可翻转任意N?1N-1N?1枚硬币（正面向上的被翻转为反面向上，反之亦然）。求一个最短的操作序列（将每次翻转N-1枚硬币成为一次操作）。
输入格式

一个自然数NNN（NNN为不大于100100100的偶数）。
输出格式

第一行包含一个整数SSS，表示最少需要的操作次数。接下来的SSS行每行分别表示每次操作后桌上硬币的状态（一行包含NNN个整数（000或111），表示每个硬币的状态：000DD正面向上，和111DD反面向上，不允许出现多余空格）。

对于有多种操作方案的情况，则只需操作的字典序最小输出一种。

注：操作的字典序：对于一次操作，1表示翻转，0表示不反转。

但是需要你输出的是每一次操作完的状态，0表示正面朝上，1表示反面朝上。
输入输出样例
输入 #1

4

输出 #1

4
0111
1100
0001
1111

code:
int main()
{
    int n,sum=0;
    cin>>n;
    cout<<n<<endl;
    bool m[n+1]={0};
    for(int i=0;i<n;i++)
    {
    for(int j=0;j<n;j++)
    {
    if(j!=i)m[j]=!(m[j]);
    }
    for(int i=0;i<n;i++)cout<<m[i];
    cout<<endl;
    }
    return 0;
}

*/

/*
P1150 Peter的烟

题目描述

Peter 有 nnn 根
，他每吸完一根烟就把烟蒂保存起来，k(k>1)k(k>1)k(k>1)个烟蒂可以换一个新的烟，那么 Peter 最终能吸到多少根烟呢？
 输入格式

每组测试数据一行包括两个整数 n,kn, kn,k（1<n,k≤1081 < n, k \le 10^81<n,k≤108）。
输出格式

对于每组测试数据，输出一行包括一个整数表示最终烟的根数。
输入输出样例
输入 #1

4 3

输出 #1

5

输入 #2

10 3

输出 #2

14

说明/提示

对于 100%100\%100% 的数据，1<n,k≤1081<n, k \le 10^81<n,k≤108。


code:
int main()
{
    int n,k,sum=0;
    cin>>n>>k;
    sum=sum+n;
    while(n/k>0)
    {
    sum=sum+n/k;
    n=n%k+n/k;
    }
    cout<<sum;
    return 0;
}

*/

/*
P1151 子数整数

题目描述

对于一个五位数a1a2a3a4a5a_1a_2a_3a_4a_5a1?a2?a3?a4?a5?，可将其拆分为三个子数：

sub1=a1a2a3sub_1=a_1a_2a_3sub1?=a1?a2?a3?

sub2=a2a3a4sub_2=a_2a_3a_4sub2?=a2?a3?a4?

sub3=a3a4a5sub_3=a_3a_4a_5sub3?=a3?a4?a5?

例如，五位数202072020720207可以拆分成

sub1=202sub_1=202sub1?=202

sub2=020(=20)sub_2=020(=20)sub2?=020(=20)

sub3=207sub_3=207sub3?=207

现在给定一个正整数KKK，要求你编程求出100001000010000到300003000030000之间所有满足下述条件的五位数，条件是这些五位数的三个子数sub1,sub2,sub3sub_1,sub_2,sub_3sub1?,sub2?,sub3?都可被KKK整除。
输入格式

一个正整数K
输出格式

每一行为一个满足条件的五位数，要求从小到大输出。不得重复输出或遗漏。如果无解，则输出“No”。
输入输出样例
输入 #1

15

输出 #1

22555
25555
28555
30000

说明/提示

0<K<10000<K<10000<K<1000

code:
int main()
{
    int n,m=0;
    cin>>n;
    for(int i=10000;i<=30000;i++)
    {
    if((i/100)%n==0 && ((i/10)%1000)%n==0 && (i%1000)%n==0)
    {
    cout<<i<<endl;
    m++;
    }
    }
    if(m==0)cout<<"No";
    return 0;
}

*/

/*
P1152 欢乐的跳

题目描述

一个nnn个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了[1,n?1][1,n-1][1,n?1]之间的所有整数，则称之符合“欢乐的跳”，如数组14231 4 2 31423符合“欢乐的跳”，因为差的绝对值分别为：3,2,13,2,13,2,1。



给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。
输入格式

每组测试数据第一行以一个整数n(1≤n≤1000)n(1 \le n \le 1000)n(1≤n≤1000)开始，接下来nnn个空格隔开的

[?108-10^8?108,10810^8108]之间的整数。
输出格式

对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出"Jolly"，否则输出"Not jolly"。
 输入输出样例 输入 #1

4 1 4 2 3

输出 #1

Jolly

输入 #2

5 1 4 2 -1 6

输出 #2

Not jolly

说明/提示

1≤n≤10001 \le n \le 10001≤n≤1000

code:
int main()
{
    int n,nm=0;
    cin>>n;
    int m[n];
    for(int i=0;i<n;i++)cin>>m[i];
    int mi[n-1];
    for(int i=0;i<n-1;i++)mi[i]=abs(m[i]-m[i+1]);
    sort(mi,mi+n-1);
    for(int i=0;i<n-2;i++)
    {
    if((abs(mi[i]-mi[i+1]))!=1)
    {
    cout<<"Not jolly";
    break;
    }
    nm++;
    }
    if(nm==n-2)cout<<"Jolly";
    return 0;
}

*/

/*
P1161 开灯

题目描述

在一条无限长的路上，有一排无限长的路灯，编号为1,2,3,4,…1,2,3,4,…1,2,3,4,…。

每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。

在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：

指定两个数，a,ta,ta,t（aaa为实数，ttt为正整数）。将编号为[a],[2×a],[3×a],…,[t×a][a],[2 \times a],[3 \times a],…,[t \times a][a],[2×a]

[3×a],…,[t×a]的灯的开关各按一次。其中[k][k][k]表示
数kkk的整数部分。

在小明进行了nnn次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。

幸好，小明还记得之前的nnn次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？
输入格式

第一行一个正整数nnn，表示nnn次操作。

接下来有nnn行，每行两个数，ai,tia_i,t_iai?,ti?。其中aia_iai?是实数，小数点后一定有666位，tit_iti?是正整数。
输出格式

仅一个正整数，那盏开着的灯的编号。
输入输出样例
输入 #1

3
1.618034 13
2.618034 7
1.000000 21

输出 #1

20

说明/提示

记T=t1+t2+t3+…+tnT=t_1+t_2+t_3+…+t_nT=t1?+t2?+t3?+…+tn?。

对于30%30\%30%的数据，满足T≤1000T \le 1000T≤1000

对于80%80\%80%的数据，满足T≤200000T \le 200000T≤200000

对于100%100\%100%的数据，满足T≤2000000T \le 2000000T≤2000000

对于100%100\%100%的数据，满足n≤5000,1≤ai<1000,1≤ti≤Tn \le 5000,1 \le a_i<1000,1 \le t_i \le Tn≤5000,1≤a
 ?<1000,1≤ti?≤T

数据保证，在经过nnn次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 iii 来说，ti×ait_i\times a_iti?×ai? 的最大值不超过 2000000。


code:

int main()
{
    int n;
    cin>>n;
    double a[n],t[n];
    for(int i=0;i<n;i++)cin>>a[i]>>t[i];
    bool lt[2000000]={0};
    for(int i=0;i<n;i++)
    {
    for(int j=1;j<=t[i];j++)
    {
    if(j*a[i]<=2000000)
    {
    lt[int(j*a[i])]=!lt[int(j*a[i])];
    }
    }
    }
    for(int i=0;i<2000000;i++)
    if(lt[i]==1)cout<<i;
    return 0;
}

*/

/*
P1179 [NOIP2010 普及组] 数字统计

题目描述

请统计某个给定范围[L,R][L, R][L,R]的所有整数中，数字 222 出现的次数。

比如给定范围[2,22][2, 22][2,22]，数字2 22 在数 22 2中出现了 111 次，在数12 1212 中出现 111 次，在数 202020 中出现 11 1次，在数 21 中
 现 111 次，在数 222222 中出现 22 2次
所以数字2 22 在该范围内一共出现了 666次。 输入格式

222个正整数 LLL 和 RRR，之间用一个空格隔开。
输出格式

数字 22 2出现的次数。
输入输出样例
输入 #1

2 22

输出 #1

6

输入 #2

2 100

输出 #2

20

说明/提示

1≤L≤R≤1000001 ≤ L ≤R≤ 1000001≤L≤R≤100000。

code:
int main()
{
    int L,R,n=0;
    cin>>L>>R;
    for(int i=L;i<=R;i++)
    {
    if(i%10-2==0)n++;
    if(i/10%10-2==0)n++;
    if(i/100%10-2==0)n++;
    if(i/1000%10-2==0)n++;
    if(i/10000%10-2==0)n++;
    if(i/100000%10-2==0)n++;
    }
    cout<<n;
    return 0;
}

*/

/*
P1181 数列分段Section I

题目描述

对于给定的一个长度为NNN的正整数数列AiA_iAi?，现要将其分成连续的若干段，并且每段和不超过MMM（可以等于MMM），问最少能将其分成多少段使得满足要求。
输入格式

第1行包含两个正整数N,MN,MN,M，表示了数列AiA_iAi?的长度与每段和的最大值，第222行包含NNN个空格隔开的非负整数AiA_iAi?，如题目所述。
输出格式

一个正整数，输出最少划分的段数。
输入输出样例
输入 #1

5 6
4 2 4 5 1

输出 #1

3

说明/提示

对于20%20\%20%的数据，有N≤10N≤10N≤10；

对于40%40\%40%的数据，有N≤1000N≤1000N≤1000；

对于100%100\%100%的数据，有N≤100000,M≤109N≤100000,M≤10^9N≤100000,M≤109，MMM大于所有数的最小值，AiA_iAi?之和不超过10910^9109。

将数列如下划分：

[4][24][51][4][2 4][5 1][4][24][51]

第一段和为444，第222段和为666，第333段和为666均满足和不超过M=6M=6M=6，并可以证明333是最少划分的段数。

code:
int main()
{
    int n,m;
    cin>>n>>m;
    int a[100002],ans=n+1;
    for(int i=1;i<=n;i++)
    {
    cin>>a[i];
    if(a[i]+a[i-1]<=m)
    {
    a[i]+=a[i-1];
    ans--;
    }
    }
    cout<<ans;
    return 0;
}

*/

/*
P1200 [USACO1.1]你的飞碟在这儿Your Ride Is Here

题目描述

众所周知，在每一个彗星后都有一只UFO。这些UFO时常来收集地球上的忠诚支持者。不幸的是，他们的飞碟每次出行都只能带上一组支持者。因此，他们要用一种聪明的方案让这些小组提前知道谁会被彗星带走。他们为每个彗星起了一个名字，通过这些名字来决定这个小组是不是被带走的那个特定的小组（你认为是谁给这些彗星取的名字呢？）。关于如何搭配的细节会在下面告诉你；你的任务是写一个程序，通过小组名和彗星名来决定这个小组是否能被那颗彗星后面的UFO带走。

小组名和彗星名都以下列方式转换成一个数字：最终的数字就是名字中所有字母的积，其中AAA是111，ZZZ是262626。例如，USACOUSACOUSACO小组就是21×19×1×3×15=1795521 \times 19 \times 1 \times 3 \times 15=1795521×19×1×3×15=17955。如果小组的数字?mod?47 \bmod 47mod47等于彗星的数字?mod?47 


 bmod
47mod47,你就得告诉这个小组需要准备好被带走！（记住 a?mod?ba \bmod bam
db”是aaa除以bbb的余数；34?mod?1034 \bmod 1034mod10等于444）




写出一个程序，读入彗星名和小组名并算出用上面的方案能否将两个名字搭配起来，如果能搭配，就输出“GO”，否则输出“STAY”。小组名和彗星名均是没有空格或标点的一串大写字母（不超过666个字母）。
输入格式

第1行：一个长度为111到666的大写字母串，表示彗星的名字。

第2行：一个长度为111到666的大写字母串，表示队伍的名字。
输出格式

无
输入输出样例
输入 #1

COMETQ
HVNGAT

输出 #1

GO

输入 #2

ABSTAR
USACO

输出 #2

STAY

说明/提示

题目翻译来自NOCOW。

USACO Training Section 1.1

code:
int main()
{
    int a = 1 , b = 1;
        char v;
        while ( (v = cin.get() ) != '\n') a *= v - 'A' + 1;
        while ( (v = cin.get() ) != '\n') b *= v - 'A' + 1;
        if (a % 47 == b % 47) cout << "GO";
        else cout << "STAY";
    return 0;
}

*/

/*
P1296 奶牛的耳语

题目描述

在你的养牛场，所有的奶牛都养在一排呈直线的牛栏中。一共有 nnn 头奶牛，其中第 iii 头牛在直线上所处的位置可以用一个整数坐标 pi(0≤pi≤108)p_i(0\le p_i \le 10^8)pi?(0≤pi?≤108)


来表示。在无聊的日子里，奶牛们常常在自己的牛栏里与其它奶牛交流一些八卦新闻。每头奶牛发出的声音响度是一样的，而由于声波的能量衰减，某头奶牛发出的声音只能被与它距离不超过 d(0≤d≤10
 )d(0 \le d \le 10^4)d(0≤d≤1 4)
的奶牛所听到，这样这对奶牛就称为可以相互交流的。现在给出所有奶牛的位置和声音所能传播的最远距离 ddd ，请你编个程序来计算你的养牛场里究竟有多少对可以相互交流的奶牛。



 输入格式

第一行包含两个整数 n,dn,dn,d。

第二行包含 nnn 个整数，每个整数都是一个坐标 pip_ipi?，描述一头奶牛在直线上的位置。
 输出格式

一个数，表示养牛场中可以相互交流奶牛的对数。
输入输出样例
输入 #1

5 10
10 12 16 37 40

输出 #1

4

说明/提示

数据规模

对于 40%40\%40% 的数据，1≤n≤1031 \leq n \leq 10^31≤n≤103。

对于 100%100\%100% 的数据，1≤n≤1061 \leq n \leq 10^61≤n≤106。

code:
int main()
{
    int n,d,r,j,mid;
    cin>>n>>d;
    int xy[n+1];
    for(int i=1;i<=n;i++)cin>>xy[i];
    sort(xy+1,xy+n+1);
    int sum=0;
    for(int i=1;i<=n-1;i++)
    {
    j=i+1;r=n;
    while(j<r){
        mid=(j+r+1)/2;
        if(xy[mid]-xy[i]<=d) j=mid;
        else r=mid-1;
        }
    sum=sum+j-i;
    if(xy[j]-xy[i]>d) sum--;
    }
    cout<<sum;
    return 0;
}

*/

/*
P1304 哥德巴赫猜想

题目描述

输入一个偶数 N(N<=10000)
(N<=10000)N(N<=10000)，验证4~N所有偶数是否符合哥德巴赫猜想：任一大于 2 的偶数都可写成两个质数之和。如果一个数不止一种分法，则输出第一个加数相比其他分法最小的
案。例如 10，1

=
+7=5+5，则 10=5+5 是错误答案。
 输入格式

第一行N
输出格式

4=2+2 6=3+3 …… N=x+y
输入输出样例
输入 #1

10

输出 #1

4=2+2
6=3+3
8=3+5
10=3+7

code:
bool zhishu(int x)
{
        for(int i = 2;i * i <= x;i++)
        {
        if(x % i == 0)
        return false;
        }
        return true;
}
int main()
{
    int n;
    cin>>n;
    if(n>=4)cout<<"4=2+2"<<endl;
    for(int i=6;i<=n;i=i+2)
    {
    cout<<i<<"=";
    for(int j=3;j<=n/2;j=j+2)
    {
        if(zhishu(j)&&zhishu(i-j))
        {
        cout<<j<<"+"<<i-j;
        break;
        };
    }
    cout<<endl;
    }
    return 0;
}

*/

/*
P1307 [NOIP2011 普及组] 数字反转

题目描述

给定一个整数，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例2）。
输入格式

一个整数 NNN
输出格式

一个整数，表示反转后的新数。
输入输出样例
输入 #1

123

输出 #1

321

输入 #2

-380

输出 #2

-83

说明/提示

数据范围

?1,000,000,000≤N≤1,000,000,000-1,000,000,000≤N≤1,000,000,000 ?1,000,00
,000≤N≤1,000,000,000。

noip2011普及组第一题

code:
int main()
{
string n;
int m=0;
cin>>n;
if(int(n[0])==45)
{
cout<<"-";
for(int i=n.length()-1;i>0;i--)
if(int(n[i])!=48)
{
    m++;
    cout<<int(n[i])-48;
}
else
{
    if(m!=0)cout<<int(n[i])-48;
}
}
else
for(int i=n.length()-1;i>=0;i--)
if(int(n[i])!=48)
{
m++;
cout<<int(n[i])-48;
}else
{
if(m!=0)cout<<int(n[i])-48;
}
return 0;
}

*/

/*
P1317 低洼地

题目描述

一组数，分别表示地平线的高度变化。高度值为整数，相邻高度用直线连接。找出并统计有多少个可能积水的低洼地？

如图：地高变化为 0 1 0 2 1 2 0 0 2 0

输入格式

两行，第一行n,表示有n个数。第2行连续n个数表示地平线高度变化的数据，保证首尾为0。(3<=n<=10000,0<=高度<=1000)
输出格式

一个数，可能积水低洼地的数目。
输入输出样例
输入 #1

10
0 1 0 2 1 2 0 0 2 0

输出 #1

3

code:
int main()
{
int n,ni,t=0;
cin>>n;
int m[n];
for(int i=0;i<n;i++)cin>>m[i];
for(int i=1;i<n-1;i++)
{
    if(m[i]<m[i+1])
    {
        if(m[i-1]>m[i])
        {
        t++;
        }
        else if(m[i-1]==m[i])
        {
            ni=i;
            while(m[i-1]==m[ni])
                {
                    i--;
                    if(i<0)
                        {
                        i=ni;
                        break;
                        }
                    if(m[i-1]!=m[ni])
                        {
                        break;
                        }
                }
            if(m[i-1]>m[ni])
            {
            t++;
            }
            i=ni;
        }
    }
}
cout<<t;
return 0;
}

*/

/*
P1319 压缩技术

题目描述

设某汉字由N × N的0和1的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个0，第二个数表示接下来连续有几个1，第三个数再接下来连续有几个0，第四个数接着连续几个1，以此类推……

例如: 以下汉字点阵图案：

0001000
0001000
0001111
0001000
0001000
0001000
1111111

对应的压缩码是： 7 3 1 6 1 6 4 3 1 6 1 6 1 3 7 （第一个数是N ,其余各位表示交替表示0和1 的个数，压缩码保证 N 
 N=交替的各位数之和） 输入格式

一行，压缩码。
输出格式

汉字点阵图（点阵符号之间不留空格）。（3<=N<=200）
输入输出样例
输入 #1

7 3 1 6 1 6 4 3 1 6 1 6 1 3 7

输出 #1

0001000
0001000
0001111
0001000
0001000
0001000
1111111

code:
int main()
{

int n,m,ti=0,t=0;
cin>>n;
int map[n*n+10];
while(cin>>m)
{
if(t%2==0)
{
    for(int i=0;i<m;i++)
    {
    map[ti]=0;
    ti++;
    }
}
else
{
    for(int i=0;i<m;i++)
    {
    map[ti]=1;
    ti++;
    }
}
t++;
}
for(int i=0;i<n*n;i++)
    {
    cout<<map[i];
    if((i+1)%n==0)cout<<endl;
    }
return 0;
}

*/

/*
P1320 压缩技术（续集版）

题目描述

设某汉字由N × N的0和1的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个0，第二个数表示接下来连续有几个1，第三个数再接下来连续有几个0，第四个数接着连续几个1，以此类推……

例如: 以下汉字点阵图案：

0001000
0001000
0001111
0001000
0001000
0001000
1111111

对应的压缩码是： 7 3 1 6 1 6 4 3 1 6 1 6 1 3 7 （第一个数是N ,其余各位表示交替表示0和1 的个数，压缩码保证 N×
 = 交替的各位数之和） 输入格式

汉字点阵图（点阵符号之间不留空格）。（3<=N<=200）
输出格式

一行，压缩码。
输入输出样例
输入 #1

0001000
0001000
0001111
0001000
0001000
0001000
1111111

输出 #1

7 3 1 6 1 6 4 3 1 6 1 6 1 3 7

coede:
int main()
{
char a,b='0';
int n,ans[40001],zz=1;
while(cin>>a)
{
n++;
if(a==b)
ans[zz]++;
else
{
zz++;
ans[zz]++;
b=a;
}
}
cout<<sqrt(n);
for(int i=1 ; i<=zz ; i++)cout<<" "<<ans[i];
return 0;
}

*/

/*
P1321 单词覆盖还原

题目描述

一个长度为 l(3≤l≤255)l(3\le l\le255)l(3≤l≤255) 的字符串中被反复贴有 boy 和 girl 两单词，后贴上的可能覆盖已贴上的单词（没有被覆盖的用句点表示），最终每个单词至

有一个字符没有被覆盖。问贴有几个 boy 几个 girl？
 输入格式

一行被被反复贴有boy和girl两单词的字符串。
输出格式

两行，两个整数。第一行为boy的个数，第二行为girl的个数。
输入输出样例
输入 #1

......boyogirlyy......girl.......

输出 #1

4
2

code:

int main()
{
string n;
cin>>n;
int j=0,k=0;
for(int i=0;i<n.length()-2;i++)
if(n[i]=='b' || n[i+1]=='o' || n[i+2]=='y')j++;
for(int i=0;i<n.length()-3;i++)
if(n[i]=='g' || n[i+1]=='i' || n[i+2]=='r' || n[i+3]=='l')k++;
cout<<j<<endl<<k<<endl;
return 0;
}

*/

/*
P1420 最长连号

题目描述

输入 nnn 个正整数，要求输出最长的连号的长度。

连号指从小到大连续自然数。
输入格式

第一行，一个整数 nnn。

第二行，nnn 个整数 aia_iai?，之间用空格隔开。
输出格式

一个数，最长连号的个数。
输入输出样例
输入 #1

10
3 5 6 2 3 4 5 6 8 9

输出 #1

5

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 1≤n≤1041 \leq n \leq 10^41≤n≤104，1≤ai≤1091 \leq a_i \leq 10^91≤ai?≤109。


code:
int main()
{
int n,j=0,k=0;
cin>>n;
int m[n];
for(int i=0;i<n;i++)cin>>m[i];
for(int i=0;i<n-1;i++)
{
if(m[i]+1==m[i+1])k++;
else
{
if(k>j)j=k;
k=0;
}
}
cout<<j+1;
return 0;
}

*/

/*
P1421 小玉买文具

题目描述

班主任给小玉一个任务，到文具店里买尽量多的签字笔。已知一只签字笔的价格是 111 元 999 角，而班主任给小玉的钱是 aaa 元 bbb 角，小玉想知道，她最多能买多少只签字笔呢。



 输入格式

输入只有一行两个整数，分别表示 aaa 和 bbb。
输出格式

输出一行一个整数，表示小玉最多能买多少只签字笔。
输入输出样例
输入 #1

10 3

输出 #1

5

说明/提示
数据规模与约定

对于全部的测试点，保证 0≤a≤1040 \leq a \leq 10^40≤a≤104，0≤b≤90 \leq b \leq 90≤b≤9。


code:
int main(){
    int a,b,m;
    cin>>a>>b;
    m=10*a+b;
    cout<<m/19<<endl;
    return 0;
}

*/

/*
P1422 小玉家的电费

题目描述

夏天到了，各家各户的用电量都增加了许多，相应的电费也交的更多了。小玉家今天收到了一份电费通知单。小玉看到上面写：据闽价电[2006]27号规定，月用电量在150千瓦时及以下部分按每千瓦时0.4463元执行，月用电量在151~400千瓦时的部分按每千瓦时0.4663元执行，月用电量在401千瓦时及以上部分按每千瓦时0.5663元执行;小玉想自己验证一下，电费通知单上应交电费的数目到底是否正确呢。请编写一个程序，已知用电总计，根据电价规定，计算出应交的电费应该是多少。
输入格式

输入一个整数，表示用电总计（单位以千瓦时计），不超过10000。
输出格式

输出一个数，保留到小数点后1位（单位以元计，保留到小数点后1位）。
输入输出样例
输入 #1

267

输出 #1

121.5

code:
int main(){
    double t,e;
    cin>>t;
    if(t<=150)e=0.4463*t;
    else if(t<=400)e=(0.4463*150+0.4663*(t-150));
    else e=(0.4463*150+0.4663*250+0.5663*(t-400));
    cout<<int((e*10)+0.5)/10.0;
    return 0;
}

*/

/*
P1423 小玉在游泳

题目描述

小玉开心的在游泳，可是她很快难过的发现，自己的力气不够，游泳好累哦。已知小玉第一步能游2米，可是随着越来越累，力气越来越小，她接下来的每一步都只能游出上一步距离的98%。现在小玉想知道，如果要游到距离x米的地方，她需要游多少步呢。请你编程解决这个问题。
输入格式

输入一个数字（不一定是整数，小于100m），表示要游的目标距离。
输出格式

输出一个整数，表示小玉一共需要游多少步。
输入输出样例
输入 #1

4.3

输出 #1

3

code:
int main(){
    int i=1;
    double o=1.0,step=0.0,t=2.0;
    cin>>step;
    if(step<=2)
    cout<<1;
    else
    {
    while(t<=step)
    {
    o=o*0.98;
    t=t+2*o;
    i++;
    }
    cout<<i;
    }
    return 0;
}

*/

/*
P1424 小鱼的航程(改进版)

题目背景

原来的题目太简单，现改进让小鱼周末也休息，请已经做过重做该题。
题目描述

有一只小鱼，它平日每天游泳 250 公里，周末休息（实行双休日)，假设从周 x(1≤x≤7)x(1\le x \le 7)x(1≤x≤7) 开始算起，过了 n(n≤106)n(n\le 10^6)n
 n≤106) 天
后，小鱼一共累计游泳了多少公里呢？ 输入格式

输入两个整数x,n(表示从周x算起，经过n天）。
输出格式

输出一个整数，表示小鱼累计游泳了多少公里。
输入输出样例
输入 #1

3 10

输出 #1

2000

code:
int main(){
    int n,m,day=0;
    cin>>n>>m;
    day=m/7*5;
    m=m-m/7*7;
    for(int i=n;i<n+m;i++)
    {
    if(i==6 || i==7)day--;
    day++;
    }
    cout<<250*day;
    return 0;
}

*/

/*
P1425 小鱼的游泳时间

题目描述

伦敦奥运会要到了，小鱼在拼命练习游泳准备参加游泳比赛，可怜的小鱼并不知道鱼类是不能参加人类的奥运会的。

这一天，小鱼给自己的游泳时间做了精确的计时（本题中的计时都按24小时制计算），它发现自己从a时b分一直游泳到当天的c时d分，请你帮小鱼计算一下，它这天一共游了多少时间呢？

小鱼游的好辛苦呀，你可不要算错了哦。
输入格式

一行内输入 4 个整数，分别表示 a, b, c, d。
输出格式

一行内输出 2 个整数 e 和 f，用空格间隔，依次表示小鱼这天一
游了多少小时多少分钟。其中表示分钟的整数 f 应该小于60。
 输入输出样例 输入 #1

12 50 19 10

输出 #1

6 20

说明/提示

对于全部测试数据，0≤a,c≤240\le a,c \le 240≤a,c≤24，0≤b,d≤600\le b,d \le 600≤b,d≤60，且结束时间一定晚于开始时间。


code:
int main(){
    int a,b,c,d;
    cin>>a>>b>>c>>d;
    a=c-a;
    if(b>d)
    {
    a--;
    b=d-b+60;
    cout<<a<<" "<<b;
    }else if(b==d)
    {
    cout<<a<<" "<<00;
    }else
    {
    b=d-b;
    cout<<a<<" "<<b;
    }
    return 0;
}

*/

/*
P1426 小鱼会有危险吗

题目描述

有一次，小鱼要从 A 处沿直线往右边游，小鱼第一秒可以游 777 米，从第二秒开始每秒游的距离只有前一秒的 98%98\%98%。有个极其邪恶的猎人在距离 A 处右

 sss 米的地方，安装了一个隐蔽的探测器，探测器左右 xxx 米之内是探测范围。一旦小鱼进入探测器的范围，探测器就会在这一秒结束时把信号传递给那个猎
，猎人在一秒后就要对探测器范围内的水域进行抓捕，这时如果小鱼还在这范围内
危险了。也就是说小鱼一旦进入探测器范围，如果能在下 111 秒的时间内马上游出探测器的范围，还是安全的。现在给出 sss 和 xxx 的数据，请你判断小鱼会不
有危险？
 果有危险输出 y，没有危险输出 n。

 输入格式

一行内输入两个实数，用空格分隔，表示 sss 和 xxx。
输出格式

一行内输出'y'或者'n'表示小鱼是否会有危险。
输入输出样例
输入 #1

14 1

输出 #1

n

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 1≤s,x≤1001 \leq s,x\le1001≤s,x≤100，
数点后最多有 666 位小数。 

code:
int main(){
    double s,x,l=0.0,v=7.0;
    cin>>s>>x;
    while(l<s-x)
    {
    l=l+v;
    v=0.98*v;
    }
    if(v*0.98<=s+x-l)cout<<'y';
    else cout<<'n';
    return 0;
}

*/

/*
P1427 小鱼的数字游戏

题目描述

小鱼最近被要求参加一个数字游戏，要求它把看到的一串数字 aia_iai?（长度不一定，以 000 结束），记住了然后反着念出来（表示结束的数字 000 就不要念出


了）。这对小鱼的那点记忆力来说实在是太难了，你也不想想小鱼的整个脑袋才多大，其中一部分还是好吃的肉！所以请你帮小鱼编程解决这个问题。

输入格式

一行内输入一串整数，以 000 结束，以空格间隔。
输出格式

一行内倒着输出这一串整数，以空格间隔。
输入输出样例
输入 #1

3 65 23 5 34 1 30 0

输出 #1

30 1 34 5 23 65 3

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 0≤ai≤231?10 \leq a_i \leq 2^{31} - 10≤ai?≤231?1，数字个数不超过 
 00100100。 

code:
int main(){
    int m[102],i=0;
    cin>>m[i];
    while(m[i]!=0)
    {
    i++;
    cin>>m[i];
    }
    for(int j=i-1;j>0;j--)cout<<m[j]<<" ";
    cout<<m[0];
    return 0;
}

*/

/*
P1428 小鱼比可爱

题目描述

人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度可能一样。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。
输入格式

第一行输入一个整数 nnn，表示鱼的数目。

第二行内输入 nnn 个整数，用空格间隔，依次表示从左到右每只小鱼的可爱程度。
输出格式

行内输出 nnn 个整数，用空格间隔，依次表示每只小鱼眼中有多少只鱼不如自己可爱。
输入输出样例
输入 #1

6
4 3 0 5 1 2

输出 #1

0 0 0 3 1 2

说明/提示

对于 100%100\%100% 的数据，n≤100n\leq 100n≤100。

code:
int main(){
    int n,t=0;
    cin>>n;
    int m[n];
    for(int i=0;i<n;i++)cin>>m[i];
    for(int i=0;i<n;i++)
    {
    t=0;
    for(int j=0;j<i;j++)if(m[j]<m[i])t++;
    cout<<t<<" ";
    }
    return 0;
}

*/

/*
P1482 Cantor表（升级版）

题目描述

现代数学的著名证明之一是Georg Cantor证明了有理数是可枚举的。他是用下面
一张表来证明这一命题的：

1/1 1/2 1/3 1/4 1/5 …

2/1 2/2 2/3 2/4 …

3/1 3/2 3/3 …

4/1 4/2 …

5/1 …

… 这
与NOIp1999第一题不同的是：这次需输入两个分数（不一定是最简分数），算出这两个分数的积（注意该约分的要约分）后输出积在原表的第几列第几行（若积是整数或1/积，则以“积/1”或“1/积”结算）。
输入格式

共两行。每行输入一个分数（不一定是最简分数）。
输出格式

两个整数，表示输入的两个分数的积在表中的第几列第几行，注意该约分的要约分。
输入输出样例
输入 #1

4/5
5/4

输出 #1

1 1

说明/提示

所有数据：两个分数的分母和分子均小于10000

code:
int gcd(int a,int b){
    if (!b)return a;
    else return gcd(b,a%b);
}
int main(){
    ios::sync_with_stdio(false);
    int a,b,c,d,t;
    char hh;
    cin>>a>>hh>>b>>c>>hh>>d;
    a*=c;b*=d;
    t=gcd(a,b);
    cout<<b/t<<" "<<a/t;
    return 0;//庄严地结束
}

*/

/*
P1534 不高兴的津津（升级版）

题目描述

津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每天妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。

这次与NOIp2004普及组第一题不同的是：假设津津不会因为其它事不高兴，但是她的不高兴会（当然高兴也会）持续到第二天。请你帮忙检查一下津津以后n天的日程安排，看看以后n天她会不会不高兴（计算方法：用昨天不高兴程度加上今天上课总时间减去8后得到的数作为今天不高兴程度）；输出以后n天结束后不高兴程度和是多少。
输入格式

第1行：一个数n

第2行~第n+1行：每行两个数，表示这天上学时间和课外补习班时间
输出格式

一个数，这n天过后的不高兴程度和
输入输出样例
输入 #1

7
5 3
6 2
7 2
5 3
5 4
0 4
0 6

输出 #1

-2

说明/提示

所有数据：上学时间和上课时间各不超过8，和不超过16，n<=3000

code:
int main(){
    int n,sum=0,t=0;
    cin>>n;
    int x[n],y[n];
    for(int i=0;i<n;i++)cin>>x[i]>>y[i];
    for(int i=0;i<n;i++)
    {
    sum=sum+x[i]+y[i]-8;
    t=t+sum;
    }
    cout<<t;
    return 0;
}

*/

/*
P1548 [NOIP1997 普及组] 棋盘问题

题目描述

设有一个N×MN \times MN×M方格的棋
(1≤N≤100,1≤M≤100)(1≤N≤100,1≤M≤100)(1≤N≤100,1≤M≤100)

求出该棋盘中包含有多少个正方形、多少个长方形（不包括正方形）。

例如：当 N=2,M=3N=2, M=3N=2,M=3时：

正方形的个数有888个：即边长为111的正方形有666个；

边长为222的正方形有222个。

长方形的个数有101010个：

即

2×12 \times 12×1的长方形有444个

1×21 \times 21×2的长方形有333个：

3×13 \times 13×1的长方形有222个：

3×23 \times 23×2的长方形有111个：

如上例：输入：2,32,32,3

输出：8,108,108,10
输入格式

N,MN,MN,M
输出格式

正方形的个数与长方形的个数
输入输出样例
输入 #1

2 3

输出 #1

8 10

说明/提示

【题目来源】

NOIP 1997 普及组第一题

code:
int main(){
    int n,m,t,f=0,c=0;
    cin>>n>>m;
    if(n>m){t=m;m=n;n=t;}
    t=0;
    for(int i=0;i<n;i++)
    {
    f=f+(n-t)*(m-t);
    t++;
    }
    cout<<f<<" "<<((1+n)*(1+m)*n*m)/4-f;
    return 0;
}

*/

/*
P1554 梦中的统计

题目背景

Bessie 处于半梦半醒的状态。过了一会儿，她意识到她在数数，不能入睡。
题目描述

Bessie的大脑反应灵敏，仿佛真实地看到了她数过的一个又一个数。她开始注意每一个数码（0…90 \ldots 90…9）：每一个数码在计数的过程中出现过多少次？



给出两个整数 MMM 和 NNN （1≤M≤N≤2×1091 \leq M \leq N \leq 2 \times 10^91≤M≤N≤2×109 以及 N?M
 5×105N-M \leq 5 \times 
0^5N?M≤5×105），求每一个数码出现了多少次。 输入格式

第 111 行: 两个用空格分开的整数 MMM 和 NNN。
输出格式

第 111 行: 十个用空格分开的整数，分别表示数码 0…90 \ldots 90…9 在序列中出现的次数。
 输入输出样例 输入 #1

129 137

输出 #1

1 10 2 9 1 1 1 1 0 1

code:
int main(){
    int n,m;
    int num[10]={0};
    cin>>n>>m;
    for(int i=n;i<=m;i++)for(int tmp=i;tmp;tmp/=10)num[tmp%10]++;
        for(int i=0;i<=9;i++)cout<<num[i]<<" ";
    return 0;
}

*/

/*
P1567 统计天数

题目描述

炎热的夏日，KC 非常的不爽。他宁可忍受
极的寒冷，也不愿忍受厦门的夏天。最近，他开始研究天气的变化。他希望用研究的结果预测未来的天气。

经历千辛万苦，他收集了连续 N(1≤N≤106)N(1 \leq N \leq 10^6)N(1≤N≤106) 的最高气温数据。



现在，他想知道最高气温一直上升的最长连续天数。
输入格式

第 1 行：一个整数 NNN 。1≤N≤1061 \leq N \leq 10^61≤N≤106

第 2 行：NNN个空格隔开的整数，表示连续 NNN 天的最高气温。0≤0 \leq0≤ 最高气温 ≤109\leq 10^9≤109 。
 输出格式

1 行：一个整数，表示最高气温一直上升的最长连续天数。
输入输出样例
输入 #1

10
1 2 3 2 4 5 6 8 5 9

输出 #1

5

code:
int main(){
    int n,t=0,k=0;
    cin>>n;
    int m[n];
    for(int i=0;i<n;i++)cin>>m[i];
    for(int i=0;i<n-1;i++)
    {
    if(m[i]<m[i+1])t++;
    else
    {
    if(t>k)k=t;
    t=0;
    }
    if(i==n-2 && t>k)k=t;
    }
    cout<<k+1;
    return 0;
}

*/

/*
P1568 赛跑

题目背景

赛跑
题目描述

SH的跑步成绩一直不太理想。为了帮助SH提高成绩，KC决定和他进行一次赛跑。比赛的起点设在农场主的屋前，他们同时出发，沿着同一方向，直到跑到终点----农场远处的一棵树下。

他们的跑步速度在一些时间段内是恒定的。比如：SH在前３个时间段速度是５，接着６个时间段内速度是１０。他们的比赛总时间相同。他们希望能统计出在整个比赛过程中领先顺序的变化次数。举个例子，某个时刻SH领先，下个时刻KC领先，这就是一次领先顺序的变化；如果某个时刻SH领先，接下来一段时间KC赶上来并和SH齐头并进，但最终还是超过了SH，这也是一次领先顺序的变化。
输入格式

第１行：N和M（1 <= N, M <= 1000）。

接下来的N行：每行两个整数，描述SH跑步的一段，分别表示该段SH跑步的速度和持续这种速度的时间。所有的数据范围 [1..1000]。


再接下来的M行：每行两个整数，描述KC跑步的一段，分别表示该段KC跑步的速度和持续这种速度的时间。所有的数据范围 [1..1000]。
 输出格式

一行：整个比赛过程中领先顺序的变化次数。
输入输出样例
输入 #1

4 3
1 2
4 1
1 1
2 10
2 3
1 2
3 9

输出 #1

2

说明/提示

输入：SH在前２个单位时间内速度是１，接着１个单位时间内速度是４，接着１个单位时间内速度是１，最后１０个单位时间内速度是２。KC在前３个个单位时间内速度是２，接着２个单位时间内速度是１，最后9个单位时间内速度是３。

输出：比赛开始后KC领先，直到第５个单位时间SH超过KC（第一次领先顺序变化），接着第７个单位时间时，KC又反超SH，变成领先（第二次领先顺序变化）。

code:
int main(){
    int n,m,pn,pm,vn[1001],vm[1001],tn[1001],tm[1001],dn=0,dm=0,ans=0;
    bool rec;
        cin>>n>>m;
        for (int i=1;i<=n;i++)cin>>vn[i]>>tn[i];
        for (int i=1;i<=m;i++)cin>>vm[i]>>tm[i];
        pn=pm=1;
        for (int i=0;;i++){
                tn[pn]--;tm[pm]--;
                dn+=vn[pn];dm+=vm[pm];
                if (!tn[pn]) pn++;
                if (!tm[pm]) pm++;
                if (i==0&&dn>dm) rec=0;
                else if (i==0&&dn<dm) rec=1;
                if (dn<dm&&!rec) rec=!rec,ans++;
                else if (dn>dm&&rec) rec=!rec,ans++;
                if (pn==n+1||pm==m+1) break;
        }
        cout<<ans;
        return 0;
}*/

/*
P1590 失踪的7

题目描述

远古的Pascal人也使用阿拉伯数字来进行计数，但是他们又不喜欢使用7，因为他们认为7是一个不吉祥的数字，所以Pascal数字8其实表示的是自然数中的7，18表示的是自然数中的16。下面计算一下，在正整数n范围以内包含有多少个Pascal数字。
输入格式

第一行为正整数t，接下来t行，每行一个正整数n(≤2^32-1)。

输入的是Pascal数字

t≤10000t \leq 10000t≤10000
输出格式

对于每个正整数n，输出n以内的Pascal数的个数。
输入输出样例
输入 #1

2
10
20

输出 #1

9
18

code:
typedef long long ll;
int T,t;
ll p,x,ans;
int main(){
        for (scanf("%d",&T);T;T--){
                for (p=1,ans=0,scanf("%lld",&x);x;x/=10,p*=9){
                        t=x%10;
                        if (t>=7) t--;
                        ans+=p*t;
                }
                printf("%lld\n",ans);
        }
}

*/

/*
P1597 语句解析

题目背景

木有背景……
题目描述

一串长度不超过 255 的 PASCAL 语言代码，只有 a,b,c 3 个变量，而且只有赋值语句，赋值只能是一个一位的数字或一个变

，每条赋值语句的格式是 [变量]:=[变量或一位整数];。未赋值的变量值为 0输出 a、b、c 的值。
 输入格式

一串(<255)PASCAL语言，只有a,b,c 3个变量，而且只有赋值语句
赋值只能是一个一位的数字或一个变量，未赋值的变量值为0。
输出格式

输出a,b,c 最终的值。
输入输出样例
输入 #1

a:=3;b:=4;c:=5;

输出 #1

3 4 5

code:
int main(){
int a[3];char s1,s2;
    while (scanf("%c:=%c;",&s1,&s2)==2)
     a[s1-'a']=s2>='0' && s2<='9' ? s2-'0' : a[s2-'a'];
    printf("%d %d %d",a[0],a[1],a[2]);
    //答案精妙 抄之
}

*/

/*
P1614 爱与愁的心痛

题目背景

（本道题目隐藏了两首歌名，找找看哪~~~）

《爱与愁的故事第一弹・heartache》第一章。

《我为歌狂》当中伍思凯神曲《舞月光》居然没赢给萨顶顶，爱与愁大神心痛啊~~~而且最近还有一些令人伤心的事情，都让人心痛（最近真的很烦哈)……
题目描述

最近有 nnn 个不爽的事
每句话都有一个正整数刺痛值（心理承受力极差）。爱与愁大神想知道连续 mmm 个刺痛值的和的最小值是多少，但是由于业务繁忙，爱与愁大神只好请你编个程序告诉他。



输入格式

第一行有两个用空格隔开的整数，分别代表 nnn 和 mmm。

第 222 到第 (n+1)(n + 1)(n+1) 行，每行一个整数，第 (i+1)(i + 1)(i+1) 行的整数 aia_iai? 代表第 iii 件事的刺痛值 aia_iai?。
 输出格式

输出一行一个整数，表示连续 mmm 个刺痛值的和的最小值是多少。
输入输出样例
输入 #1

8 3
1
4
7
3
1
2
4
3

输出 #1

6

说明/提示
数据规模与约定

    对于 30%30\%30% 的数据，保证 n≤20n \leq 20n≤20。
    对于 60%60\%60% 的数据，保证 n≤100n \leq 100n≤100。
    对于 90%90\%90% 的数据，保证 n≤103n \leq 10^3n≤103。
    对于 100%100\%100% 的数据，保证 0≤m≤n≤3×1030 \leq m \leq n \leq 3 \times 10^30≤m≤n≤3×103，1≤ai≤1
 01 \leq a_i \leq 1001≤ai?≤100。

code:
int main(){
    int n,m,hrt[3010],ans,sum;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        scanf("%d",&hrt[i]);
        if(i<=m){
        sum+=hrt[i];
        ans=sum;
        }
        else ans=min(ans,sum=sum+hrt[i]-hrt[i-m]);
    }
    cout<<ans;
    return 0;
}

*/

/*
P1615 西游记公司

题目背景

一道极其无厘头的题目
题目描述

事情是这样的：西游记中的孙沙猪（孙杀猪）三徒弟在西天取经之后开始进入厦门大学经贸系学习经济，在1个小时的学习后，他们用暴力手段毕业了。然后，他们创办了三个公司――“花果山生态旅游山庄集团公司”“高老庄猪肉美食城有限公司”“流沙河轮渡有限公司”。虽然这三家公司出自“经卷出版社”社长唐三藏的徒弟们，但是仍然保持着0元以下的财政收入。于是，他们想到了一个无聊的方法――向别人偷！是这样的：如果猪八戒知道孙悟空要偷猪八戒的平底锅，猪八戒就不能去抢沙和尚的保时捷。现在，作为猪八戒手下首席智士（智障人士）的你，要帮助既聪明又愚蠢的猪八戒用那种不正当的手段挽救这个公司！你可以这样做：你已经知道孙悟空什么时候要来偷猪八戒的东西，而猪八戒又要在什么时间去抢沙和尚的东西，又知道猪八戒每秒钟可以偷沙和尚1台笔记本电脑，帮猪八戒算一算，自己在有限的时间内能偷到沙和尚多少台电脑，使得他有足够的时间来防御大师兄。
输入格式

第一行：时:分:秒（表示猪八戒打算去偷沙和尚笔记本电脑的时间）

第二行：时:分:秒（表示孙悟空打算去偷猪八戒平底锅的时间）

注：时间可能有前导0，也有可能没有。

第三行：猪八戒每秒可以偷沙和尚几台笔记本电脑

确保第一行的时间要比第二行的时间来得早。
输出格式

一个整数，有可能大于int(2^31-2)，表示猪八戒能偷沙和尚笔记本的个数
输入输出样例
输入 #1

00:0:00
0:00:10
10

输出 #1

100

说明/提示

数据范围：

00:00:00到23:59:59

数量<=32767

code:
int main(){
    long long a,b,c,x,y,z,t;char m;
    cin>>a>>m>>b>>m>>c>>x>>m>>y>>m>>z>>t;
    cout<<((x-a)*3600+(y-b)*60+(z-c))*t;
    return 0;
}

*/

/*
P1634 禽兽的传染病

题目背景

mxj 的启发。
题目描述

禽兽患传染病了。一个禽兽会每轮传染 xxx 个禽兽。试问 nnn 轮传染后有多少禽兽被传染？
 输入格式

两个非负整数 xxx 和 nnn。
输出格式

一个整数，即被传染的禽兽数。
输入输出样例
输入 #1

10 2

输出 #1

121

说明/提示

保证 x,nx,nx,n 以及答案都在 646464 位无符号整数的表示范围内。

code:
int main(){
    long long x,n,u=1;
    cin>>x>>n;
    for(int i=0;i<n;i++)u=u+u*x;
    cout<<u;
    return 0;
}

*/

/*
P1652 圆

题目描述

给出 nnn 个圆,保证任意两个圆都不相交。
然后给出两个点 (x1,y1),(x2,y
)(x_1,y_1),(x_2,y_2)(x1?,y1?),(x2?,y2?)，保证均不在某个圆上，要从 (x1,y1)→(x2,y2)(x_1,y_1) \to (x_2
y_2)(x1?,y1?) (x2?,y2?) 画条曲
，问这条曲线最少穿过多少次圆的边界？ 输入格式

第一行为一个整数 nnn，表示圆的个数；

第二行是 nnn 个整数，表示 nnn 个圆的 xxx 坐标；

第三行是 nnn 个整数，表示 nnn 个圆的 yyy 坐标；

第四行是 nnn 个整数，表示 nnn 个圆的半径 rrr；

第五行是四个整数 x1,y1,x2,y2x_1,y_1,x_2,y_2x1?,y1?,x2?,y2?。
输出格式

仅一个整数，表示最少要穿过多少次圆的边界。
输入输出样例
输入 #1

7
1 -3 2 5 -4 12 12
1 -1 2 5 5 1 1
8 1 2 1 1 1 2
-5 1 12 1

输出 #1

3

说明/提示

【数据范围】
对于 100%100\%100% 的数据，1≤n≤501\le n \le 501≤n≤50，OxO,OyO≤1000|x|,|y| \le 1000OxO,OyO≤1000，1≤r≤10001 \le 
 \le 10001≤r≤1000。 保证圆之间没有公共点。

code:
int main(){
    int x[60],y[60],r[60],n,x1,y1,x2,y2,ans=0;
        scanf("%d",&n);
        for(int i=1;i<=n;i++) scanf("%d",&x[i]);
        for(int i=1;i<=n;i++) scanf("%d",&y[i]);
        for(int i=1;i<=n;i++) scanf("%d",&r[i]);
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        for(int i=1;i<=n;i++)
          if(((sqrt((x1-x[i])*(x1-x[i])+(y1-y[i])*(y1-y[i])))<r[i])^(sqrt((x2-x[i])*(x2-x[i])+(y2-y[i])*(y2-y[i])))<r[i])
            ans++; 
        printf("%d",ans); 
        return 0;
}*/

/*
P1664 每日打卡心情好

题目背景

在洛谷中，打卡不只是一个简单的鼠标点击动作，通过每天在洛谷打卡，可以清晰地记录下自己在洛谷学习的足迹。通过每天打卡，来不断地暗示自己：我又在洛谷学习了一天，进而帮助自己培养恒心、耐心、细心。此外，通过打卡，还可以获取经验值奖励，经验值的多少在一定程度上反映了你在洛谷的资历和成就。通过打卡累积活跃值，渐渐升级，会让你感觉“离神脑嚼丛浇了”。
题目描述

洛谷的打卡系统与其他网站的打卡系统一样，连续”打卡天数越多，每次打卡获得的奖励也就越多，同时连续天数加上一天。然而，于其他网站只要一天不打卡，连续天数就要清零。与其他网站不同的是，洛谷的打卡更具有人性化，如果多天不打卡，连续天数仅仅只是减少，当遗漏天数越少，减少的天数也就越少。规则是减少 2n?12^{n-1}2n?1 天，nnn 为连续遗漏天数。连续天数在下一次打卡时清算，打卡连续天数不会小于 000。也就是说，如果每隔一天打卡，那么连续天数就不会变了。







当连续天数达到以下天数时，给予不同的活跃值奖励：

111 天：奖励 111（千里之行，始于足下）

333 天：奖励 222（坚持 333 天了，加油！）

777 天：奖励 333（曜日轮回）

303030 天：奖励 444（月圆月缺，习惯养成）

120120120 天：奖励 555（坚持四个月了！）

365365365 天：奖励 666（一年四季都坚持下来了！真不容易！）

小 a N
N天前在洛谷注册了一个账号，虽然当时立志每天都要打卡，但发现这不太容易做到。现在知道他 NNN 天的的打卡记录，小 a 希望得知他通过打卡，在 NNN 天能获得多少活跃值？


输入格式

第 111 行一个整数 NNN。

接下来 NNN 行，每行一个整数 111 或 000，代表当天是否打过卡。
输出格式

一个整数，表示获得的活跃值！
输入输出样例
输入 #1

12
1
1
1
1
1
0
0
0
1
0
1
1

输出 #1

12

说明/提示

第 111 天：111//开始打卡！获得 111 点经验，共 111 点，连续 111 天。

第 222 天：111//获得 111 点经验，共 222 点，连续 222 天。

第 333 天：111//获得 222 点经验，共 444 点，连续 333 天。

第 444 天：111//获得 222 点经验，共 666 点，连续 444 天

第 555 天：111//获得 222 点经验，共 888 点，连续 555 天

第 666 天：000//由于要去趟火星，没有网络不得已而断签

第 777 天：000

第 888 天：000

第 999 天：111//我回来了，可惜连续天数变成 5?4=15-4=15?4=1 天了TQT……获得 111 点经验，共 999 点，连续 222 天



第 101010 天：000//啊，事情太多给忘了

第 111111 天：111//连续天数变成 2?1=12-1=12?1=1 天。获得 111 点经验，共 101010 点，连续 222 天。



第 121212 天：111//获得 222 点经验，共 121212 点，连续 333 天。

小a：弄个自动打卡机，怎么样？

kkksc03：这不符合洛谷的规则的！

1≤N≤1031\leq N\leq 10^31≤N≤103。

code:
int main(){
    int n,t=0,a,d=0,m=0;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a;
        if(a==1){
            if(m>0) d-=pow(2,m-1);
            if(d<0) d=0;
            t++;d++;m=0;
            if(d>=3) t++;
            if(d>=7) t++;
            if(d>=30) t++;
            if(d>=120) t++;
            if(d>=365) t++;
        }else if(a==0) m++;
    }
    printf("%d",t);
    return 0;
}

*/

/*
P1720 月落乌啼算钱（斐波那契数列）

题目背景

（本道题目木有隐藏歌曲……不用猜了……）

《爱与愁的故事第一弹・heartache》最终章。

吃完 pizza，月落乌啼知道超出自己的预算了。为了不在爱与愁大神面前献丑，只好还是硬着头皮去算钱……
题目描述

算完钱后，月落乌啼想着：“你 TMD 坑我，（以下用闽南语读）归粒靠杯靠亩诶，（以下用英读）是伊特游！”于是当爱与愁大神问多少钱时，月落乌啼说了一堆乱码。爱与愁大神说：“算了算了，我只问第n样菜价格多少？”月落乌啼写出了：

由于爱与愁大神学过编程，于是就用 111 分钟的时间求出了 FnF_nFn? 的结果。月落乌啼为此大吃一惊。你能学学爱与愁大神求出 FnF_nFn? 的值吗？
输入格式

一行一个自然数 nnn。
输出格式

只有 111 行一个实数 FnF_nFn?，保留两位小数。
输入输出样例
输入 #1

6

输出 #1

8.00

说明/提示

对于所有数据：0≤n≤480 \leq n\leq 480≤n≤48。

code:
int main(){
    long long a=1,b=1,c=0;int n,i;cin>>n;
    for (i=3;i<=n;i++){
        c=a+b;
        a=b;
        b=c;
    }
    cout<<c<<".00";
    return 0;
}

*/

/*
P1739 表达式括号匹配

题目描述

假设一个表达式有英文字母（小写）、运算符（+，―，*，/）和左右小（圆）括号构成，以“@”作为表达式的结束符。请编写一个程序检查表达式中的左右圆括号是否匹配，若匹配，则返回“YES”；否则返回“NO”。表达式长度小于255，左圆括号少于20个。
输入格式

一行：表达式
输出格式

一行：“YES” 或“NO”
输入输出样例
输入 #1

2*(x+y)/(1-x)@

输出 #1

YES

输入 #2

(25+x)*(a*(a+b+b)@

输出 #2

NO

说明/提示

表达式长度小于255，左圆括号少于20个

code:
int main(){
    int n=0;
    char c;
    while(cin>>c){
        if(c=='@'){
        if(n==0)cout<<"YES";
        else cout<<"NO";
        break;
        }
        if(c=='(')n++;
        if(c==')')n--;
        if(n<0){
        cout<<"NO";
        break;
        }
    }
    return 0;
}*/

/*
P1765 手机

题目描述

一般的手机的键盘是这样的：

要按出英文字母就必须要按数字键多下。例如要按出 x 就得按 9 两下，第一下会出 w，而第二下会把 w 变成 x。0 键按一下会出一个空格。



你的任务是读取若干句只包含英文小写字母和空格的句子，求出要在手机上打出这个句子至少需要按多少下键盘。
输入格式

一行句子，只包含英文小写字母和空格，且不超过 200 个字符。
输出格式

一行一个整数，表示按键盘的总次数。
输入输出样例
输入 #1

i have a dream

输出 #1

23

说明/提示

NOI导刊2010普及（10）

code:
int main(){
    int n=0;
    string c;
        getline(cin,c);
    for(int i=0;i<(c.length());i++){
    if(c[i]==' ')n++;
    if(c[i]=='a' || c[i]=='d' || c[i]=='g' || c[i]=='j' || c[i]=='m' ||
c[i]=='p' || c[i]=='t' || c[i]=='w')n++; if(c[i]=='b' || c[i]=='e' || c[i]=='h'
|| c[i]=='k' || c[i]=='n' || c[i]=='q' || c[i]=='u' || c[i]=='x')n=n+2;
    if(c[i]=='c' || c[i]=='f' || c[i]=='i' || c[i]=='l' || c[i]=='o' ||
c[i]=='r' || c[i]=='v' || c[i]=='y')n=n+3; if(c[i]=='s' || c[i]=='z')n=n+4;
    }
    cout<<n;
    return 0;
}

*/

/*
P1789 【Mc生存】插火把

题目背景

初一党应该都知道......
题目描述

话说有一天 linyorson 在“我的世界”开了一个 n×nn \times nn×n（n≤100n \le 100n≤100）的方阵，现在他有 mmm 个火把和 kkk 个萤石，分别
 在 (x1,y1)?(xm,ym)(x_1, y_1
 \sim (x_m, y_m)(x1?,y1?)?(xm?,ym?) 和 (o1,p1)?(ok,pk)(o_ ,
p_1) \sim (o_k, p_k)(o1?,p1?)?(ok?,pk?) 的位置，没有光或没
东西的地方会生成怪物。请问在这个方阵中有几个点会 成怪物？


P.S. 火把的照亮范围是：

    |暗|暗| 光 |暗|暗|
    |暗|光| 光 |光|暗|
    |光|光|火把|光|光|
    |暗|光| 光 |光|暗|
    |暗|暗| 光 |暗|暗|

萤石：

    |光|光| 光 |光|光|
    |光|光| 光 |光|光|
    |光|光|萤石|光|光|
    |光|光| 光 |光|光|
    |光|光| 光 |光|光|

输入格式

输入共 m+k+1m + k + 1m+k+1 行。
第一行为 n,m,kn, m, kn,m,k。
第 222 到第 m+1m + 1m+1 行分别是火把的位置 xi,yix_i, y_ixi?,yi?。
 第 m+2m + 2m+2 到第 m+k+1m + k + 1m+k+1 行分别是萤石的位置 oi,pio_i, p_ioi?,pi?。



注：可能没有萤石，但一定有火把。

所有数据保证在 int 范围内。
输出格式

有几个点会生出怪物。
输入输出样例
输入 #1

5 1 0
3 3

输出 #1

12

code:
int main(){
    int n,m,k,x,y,o,p,ans=0;
    int
dx1[13]={2,0,-2,0,1,1,1,0,0,0,-1,-1,-1},dy1[13]={0,2,0,-2,0,1,-1,1,0,-1,0,1,-1},
        dx2[25]={-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2},
        dy2[25]={-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2};
    cin>>n>>m>>k;
    int a[n+5][n+5];
    memset(a,0,sizeof(a));
    for(int i=1;i<=m;i++){
        cin>>x>>y;
        for(int j=0;j<13;j++)
        a[x+dx1[j]][y+dy1[j]]=1;
        }
    for(int i=1;i<=k;i++){
        cin>>o>>p;
        for(int j=0;j<25;j++)
        a[o+dx2[j]][p+dy2[j]]=1;
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(a[i][j]==0)
            ans++;
    cout<<ans;
    return 0;
}

*/

/*
P1830 轰炸III

题目背景

一个大小为N*M的城市遭到了X次轰炸，每次都炸了一个每条边都与边界平行的矩形。
题目描述

在轰炸后，有Y个关键点，指挥官想知道，它们有没有受到过轰炸，如果有，被炸了几次，最后一次是第几轮。
输入格式

第一行，四个整数：n、m、x、y。

以下x行，每行四个整数：x1、y1、x2、y2，表示被轰炸的矩形的左上角坐标和右下角坐标（比如1 3 7 10就表示被轰炸的地方是从(1,3)到(7,10)的矩形）。



再以下y行，每行两个整数，表示这个关键点的坐标。
输出格式

共y行，

每行第一个字符为Y或N，表示是否被轰炸，若为Y，在一个空格后为两个整数，表示被炸了几次和最后一次是第几轮。
输入输出样例
输入 #1

10 10 2 3
1 1 5 5
5 5 10 10
3 2
5 5
7 1

输出 #1

Y 1 1
Y 2 2
N

说明/提示

数据很弱！！！直接模拟！！！！

1<=N,M<=100

code:
int a[101][101],b[101][101];
using namespace std;
int main(){
    int n,m,x,y,xx,yy,xxx,yyy;
    cin>>n>>m>>x>>y;
    for(int i=1;i<=x;++i){
        cin>>xx>>yy>>xxx>>yyy;
        for(int ii=xx;ii<=xxx;++ii)
            for(int jj=yy;jj<=yyy;++jj){
              ++a[ii][jj];b[ii][jj]=i;
            }
        }
    for(int i=1;i<=y;++i){
        cin>>xx>>yy;
        if(a[xx][yy]==0)cout<<"N\n";
        else cout<<"Y "<<a[xx][yy]<<' '<<b[xx][yy]<<"\n";
    }
    return 0;
}

*/

/*
P1838 三子棋I

题目描述

小a和uim喜欢互相切磋三子棋。三子棋大家都玩过是吗？就是在九宫格里面OOXX（别想歪了），谁连成3个就赢了。

由于小a比较愚蠢，uim总是让他先。

我们用9个数字表示棋盘位置：

123 456 789 所有的棋谱都是已经结束的棋局，要么一方获胜，要么平局。

今天，他们下了一下午的棋，小a为了提高技术，录下了很多棋谱。他想知道，一盘棋结束时，到底是谁赢。
输入格式

一行，一串数字，表示落子的地点。小a总是先下
输出格式

一行，如果小a赢，输出“xiaoa wins.”。如果uim赢，输出“uim wins.”。如果平局，输出“drew.”
 输入输出样例 输入 #1

5237649

输出 #1

xiaoa wins.

输入 #2

539128647

输出 #2

drew.

code:
int main()
{
    int i,x,p=0,q=0,r=0,a[1111]; string s;
    cin>>s;   //读入
    for (i=0;i<s.size();i++){
    x=int(s[i])-48;
    a[x]=i%2;   //一维数组模拟
    }
    if (a[1]==a[5]&&a[5]==a[9]) {
        if (a[1]==0) p=1; 
        else q=1; r=1;
        }
    //如同K样的对角线 
    if (a[3]==a[5]&&a[5]==a[7]) {
        if (a[3]==0) p=1; 
        else q=1; r=1;
        }
    //如图L样的对角线（复制上面直接修改） 
    for (i=1;i<=3;i++) 
        if(a[i]==a[i+3]&&a[i+3]==a[i+6]) {
            if (a[i]==0) p=1;
            else q=1; r=1;
            }
    //每列判断是否一致 
    for (i=1;i<=9;i+=3) 
        if (a[i]==a[i+1]&&a[i+1]==a[i+2]) {
            if(a[i]==0) p=1; 
            else q=1; r=1;
    }
    //每行判断是否一致 
    if (p&&!q) cout<<"xiaoa"; 
    if(q) cout<<"uim"; 
    if(r) {
        cout<<" wins."; 
        return 0;
    }
    //输出 cout<<"drew.";
}

*/

/*
P1851 好朋友

题目背景

小可可和所有其他同学的手腕上都戴有一个射频识别序列号码牌，这样老师就可以方便的计算出他们的人数。很多同学都有一个“好朋友” 。如果 AAA 的序列号的约数之和恰好等于 BBB 的序列号，那么 AAA 的好朋友就是 BBB。在这里，一个数的约数不包括这个数本身。因为一些同学的号码约数和大于其他任何同学的号码，所以这些同学没有好朋友。一些同学有一个“非常好友” 。当两


 同学互为“好朋友”时，他们就是一对“非常好友” 。注意在这道题中，忽略那些自己是自己的“非常好友”的情况。



 题目描述

给定一个序列号 sss，找出序列号不小于 sss 的第一对“非常好友” 。
输入格式

只有一行一个整数 sss，即给定的序列号下界。
输出格式

输出一行两个用空格隔开的整数 aaa 和 bbb 。

aaa 表示第一个序列号不小于 sss 的有“非常好友”的同学，bbb 是 aaa 的“非常好友” 。
输入输出样例
输入 #1

206

输出 #1

220 284

说明/提示
数据规模与约定

    对于 100%100\%100% 的数据，保证 6≤s≤1.8×1046\le s\le1.8\times10^46≤s
1.8×104。

code:
int main(){
    int a[17]={284,1210,2924,5564,6386,10856,14595,18416,66992,71145,76084,87633,88730};
    int b[17]={220,1184,2620,5020,6232,10744,12285,17296,66928,67095,63020,69615,79750};
    int s;
    cin>>s;
    for(int i=0;i<=15;i++){
        if(b[i]>=s){cout<<b[i]<<' '<<a[i];return 0;}
        if(a[i]>=s){cout<<a[i]<<' '<<b[i];return 0;}
    }
    return 0;
}

*/

/*
P1867 【Mc生存】经验值

题目背景

初一福利第2弹。。。
题目描述

话说 clearman 在 MC 世界开了个祥艺奶牛场，用熔浆、TNT 等丧心病狂的折磨牛，获取牛肉、牛奶等刷经验。他想知道他到底达到什么层次



他总共进行了 nnn 项操作，每次操作要付出 xxx 生命值（初始生命是 101010 点，初一党都知道！并且要先计算付出的生命值，如果小于等于 000，则死亡，本次即以下操作都无效。但切记

 付出生命值可以是负数，也就是说可以回复 ?x-x?x 点生命值，但上限只能是 101010！切记！），每次操作可以
得 aaa 经验值（不能为负），他最后能达到 mmm
 级 ttt 经验。



P.S. 关于等级

初始等级为 000。每加 2m2^m2m（mmm 为当前等级）点经验可升一级。

1、假设 clearman 一共得到 151515 点经验，那么他应该为 444 级（ 15?1?2?4?8=015-1-2-4-8=015?1?2?4?8=0）
 000 点经验。 2、假设 clearman 一共获得 393939 点经验，那么
 应该为 555 级（ 39?1?2?4?8?16=839-1-2-4-8-16=839?1?2?
?8?16=8）加 888 点经验。 输入格式

第一行一个正整数 nnn，表示操作个数。

接下来 nnn 行，每行两个数，为 clearman 的一次操作。
输出格式

一行，为等级和经验值。
输入输出样例
输入 #1

2
5.5 15
4.5 24

输出 #1

4 0

说明/提示

数据很弱，人肉输的，但是很坑。。。

【数据范围】
对于 100%100\%100% 的数据，1≤n≤201\le n \le 201≤n≤20。

code:
int main(){
    int n,x,sum=0;
    double blood=10,t;
        cin>>n;
        while(n--){
                cin>>t>>x;
                blood=min(blood-t,10.0);
                if(blood<=0) break;
                sum+=x;
        }
        cout<<floor(log(sum+1)/log(2))<<"
"<<sum+1-pow(2,floor(log(sum+1)/log(2))); return 0;
}

*/

/*
P1876 开灯

题目背景

该题的题目是不是感到很眼熟呢?

事实上，如果你懂的方法，该题的代码简直不能再短。

但是如果你不懂得呢？那。。。（自己去想）
题目描述

首先所有的灯都是关的（注意是关！），编号为 111 的人走过来，把是 111 的倍数的灯全部打开，编号为 222 的人把是 222 的倍数的灯全部关上，编号为 333 的人又把是 333 的倍

 的灯开的关上，关的开起来……直到第 NNN 个人为止。


给定 NNN，求 NNN 轮之后，还有哪几盏是开着的。
输入格式

一个数 NNN，表示灯的个数和操作的轮数。
输出格式

若干数，表示开着的电灯编号。
输入输出样例
输入 #1

5

输出 #1

1 4

说明/提示

【数据范围】

对于 100%100 \%100% 的数据，1≤N≤2401 \le N \le 2^{40}1≤N≤240。

【其他说明】

数学题！

code:
int main(){
    long long n;cin>>n;
    for(int i=1;i*i<=n;i++)
    cout<<i*i<<" ";
} 

*/

/*
P1887 乘积最大3

题目描述

请你找出 MMM 个和为 NNN 的正整数，他们的乘积要尽可能的大。

输出字典序最小的一种方案。
输入格式

一行，两个正整数 N,MN,MN,M
输出格式

MMM 个和为 NNN 的，乘积尽可能的大的正整数。
输入输出样例
输入 #1

6 3

输出 #1

2 2 2

说明/提示

对于100%的数据，1≤N≤109,1≤M≤1061 \le N \le 10^{9},1 \le M \le 10^{6}1≤N≤109,1≤M≤1
 6。数据保证 N≥MN \geq MN≥M。

code:
int main(){
    int a,b,i,n,ans;
    cin>>a>>b;
    n=a%b;
    ans=a/b;
    for(i=n;i<b;++i)cout<<ans<<" ";
    for(i=0;i<n;++i)cout<<ans+1<<" ";
    return 0;
}

*/

/*
P1888 三角函数

题目描述

输入一组勾股数 a,b,c（a≠b≠c）a,b,c（a\neq b\neq c）a,b,c（a=b=c），用分数格式输
 其较小锐角的正弦值。（要求约分。） 输入格式

一行，包含三个正整数，即勾股数 a,b,ca,b,ca,b,c（无大小顺序）。
输出格式

一行，包含一个分数，即较小锐角的正弦值
输入输出样例
输入 #1

3 5 4

输出 #1

3/5

说明/提示

数据保证：a,b,ca,b,ca,b,c 为正整数且 ∈[1,109]\in [1,10^9]∈[1,109]。

code:
int main(){
    int num[3],gcd;
        for(int i=0;i<3;i++)cin>>num[i];
        sort(num,num+3);
        for(gcd=num[0];gcd>1;gcd--)if(num[0]%gcd==0&&num[2]%gcd==0)break;
        cout<<num[0]/gcd<<"/"<<num[2]/gcd;
}

*/

/*
P1897 电梯里的爱情

题目背景

木有……
题目描述

细心的同事发现，小 W 最近喜欢乘电梯上上下下，究其原因，
许只有小W自己知道：在电梯里经常可以遇到他心中的女神 PR。


电梯其实是个很暧昧的地方，只有在电梯里，小 W 才有勇气如此近距离接近女神，虽然觉得有点不自在，但次数多了，女神也习惯了小 W 的

在，甚至熟悉到仿佛不说上句话自己也都觉得不合适了。可是，他们的谈话也仅仅限于今天天气不错啊或是你吃了吗之类的，往往在对方微笑点头后就再次陷入难堪的沉默之中。 于是，小 W 便在陪伴女神的同时，也关注着电梯中显示的楼层数字，并且

注意到电梯每向上运行一层需要 666 秒钟，向下运行一层需要 444 秒钟，每开门一次需要 555 秒（如果有人到达才开门），并且每下一个人需要加 111 秒。






特别指出，电梯最开始在 000 层，并且最后必须再回到 000 层才算一趟任务结束。假设在开始的时候已知电梯内的每个人要去的楼层，你能计算出完成本趟任

需要的总时间吗?

这是个很简单的问题，要知道，小 W 已经修炼到快速心算出结果的境界，现在你来编程试试吧！
 输入格式

共 222 行

第 111 行，一个正整数 nnn，表示乘坐电梯的人数。

第 222 行，nnn 个正整数，aia_{i}ai? 表示第 iii 个人要去的楼层。
 输出格式

仅 111 行，一个正整数，表示完成这趟任务需要的时间。
输入输出样例
输入 #1

4
2 4 3 2

输出 #1

59

说明/提示

对于 60%60\%60% 的数据 0<n<1040<n<10^40<n<104

对于 100%100\%100% 的数据 0<n<1050<n<10^50<n<105，0<ai≤2×1070<a_{i}\leq 2\times 10^70<ai?≤2×10
 。

code:
int main(){
    int n,ans,b,a[20000001]={0},fl;
        scanf("%d",&n);
        for (int i=1;i<=n;i++){
                scanf("%d",&b);
                a[b]++;
        }
        for (int i=1;i<=20000000;i++){
                if (a[i]){
                        ans+=(i-fl)*6+5+a[i];
                        fl=i;
                }
        }
        printf("%d\n",ans+fl*4);
        return 0;
}

*/

/*
P1909 [NOIP2016 普及组] 买铅笔

题目描述

P老师需要去商店买n支铅笔作为小朋友们参加NOIP的礼物。她发现商店一共有 333种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起 见，P老师决定只买同一种包装的铅笔。





商店不允许将铅笔的包装拆开，因此P老师可能需要购买超过nnn支铅笔才够给小朋 友们发礼物。



现在P老师想知道，在商店每种包装的数量都足够的情况下，要买够至少nnn支铅笔最少需要花费多少钱。
输入格式

第一行包含一个正整数nnn，表示需要的铅笔数量。

接下来三行，每行用222个正整数描述一种包装的铅笔：其中第111个整数表示这种 包装内铅笔的数量，第222个整数表示这种包装的价格。



保证所有的777个数都是不超过100001000010000的正整数。
输出格式

111个整数，表示P老师最少需要花费的钱。
输入输出样例
输入 #1

57
2 2
50 30
30 27

输出 #1

54

输入 #2

9998
128 233
128 2333
128 666

输出 #2

18407

输入 #3

9999
101 1111
1 9999
1111 9999

输出 #3

89991

说明/提示

铅笔的三种包装分别是：

    222支装，价格为222;
    505050支装，价格为303030;
    303030支装，价格为272727。

P老师需要购买至少575757支铅笔。

如果她选择购买第一种包装，那么她需要购买292929份，共计2×29=582 \times 29 = 582×29=58支，需要花费的钱为2×29=582 \times 29 = 582×29=58



实际上，P老师会选择购买第三种包装，这样需要买222份。虽然最后买到的铅笔数 量更多了，为30×2=6030 \times 2 = 6030×2=60支，但花费却减少为27×2=5427 \times 2 = 5

 27×2=54，比第一种少。


对于第二种包装，虽然每支铅笔的价格是最低的，但要够发必须买222份，实际的花费达到了 30×2=6030 \times 2 = 6030×2=60，因此P老师也不会选择。



所以最后输出的答案是545454。

【子任务】

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试 只解决一部分测试数据。



每个测试点的数据规模及特点如下表：

上表中“整倍数”的意义为：若为KKK，表示对应数据所需要的铅笔数量nnn―定是每种包装铅笔数量的整倍数（这意味着一定可以不用多买铅笔)。



code:
int i,j,k,n,m,w,ans;
int main(){
    scanf("%d",&n);
    for(i=0;i<3;i++){
        scanf("%d%d",&j,&k);m=j;w=k;//输入并存下初始的价格与数量
        while(j<n){j<<=1;k<<=1;}//价格与数量不断*2直到数量大于n
        while(j>n){j-=m;k-=w;}//x2有可能导致买太多了，减去一些
        while(j<n){j+=m;k+=w;}//减去之后又可能太少了，加上一些
        //其实就是大幅度地上调，然后做一些微调
        if(k<ans||ans==0)ans=k;//判断是否是最小花费
    }
    printf("%d\n",ans);
    return 0;//输出并返回
}

*/

/*
P1914 小书童――凯撒密码

题目背景

某Xm迷上了“小书童”，有一天登陆时忘记密码了（他没绑定邮箱or手机），于是便把问题抛给了神哪恪
题目描述

Xm虽然忘记密码，但他还记得密码是由一个字符串组成。密码是由原文字符串（由不超过 50 个小写字母组成）中每个字母向后移动 nnn 位形成的。z 的下一个字母是 a，如此循环。他现在找到了移动前的原文字符串及 nnn，请你求出密码。



 输入格式

第一行：n。第二行：未移动前的一串字母
输出格式

一行，是此Xm的密码
输入输出样例
输入 #1

1
qwe

输出 #1

rxf

说明/提示

字符串长度<=50

code:
int main(){
    int n;
    cin>>n;
    char
m,t[52]={'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'};
    while(cin>>m)
    {
    for(int i=0;i<26;i++)
    if(t[i]==m)
    {
    cout<<t[i+n];break;
    }
    }
        return 0;
}

*/

/*
P1917 三子棋II

题目描述

小a和uim喜欢互相切磋三子棋。三子棋大家都玩过是吗？就是在九宫格里面OOXX（别想歪了），谁连成3个就赢了。

虽然小a很努力地记录棋谱，可还是下不过uim。

由于小a比较愚蠢，uim总是让他先。小a下的第一个子一定是在中心。

这回小a希望使用计策。目前棋局刚开始，棋盘上不到3颗棋子，小a想知道，根据目前的局势，他有没有必胜策略（也就是自己以最佳方案下棋，无论对手怎么下，自己必胜）。
输入格式

3行，表示棋局，O表示小a，X表示uim,-表示没有落子。保证棋子数<=3
输出格式

2行，

第一行，如果小a赢，输出“xiaoa will win.”。如果小a必败，输出“uim will win.”。如果不知道，输出“Dont know.”



第二行，输出他们已经下了几个棋子。
输入输出样例
输入 #1

---
-O-
---

输出 #1

Dont know.
1

输入 #2

---
-O-
-XO

输出 #2

xiaoa will win.
3

code:
int main(){
        char a[5][5];
    int s=0,dk[5],af[5],sm=1;
        for(int i=1;i<=3;i++){
                for(int j=1;j<=3;j++){
                        cin>>a[i][j];
                        if(a[i][j]!='-')s++;
                        if(a[i][j]=='X'){
           sm++;
           dk[sm]=i;af[sm]=j;
                        }
                }
        }
        if(s==1||s==0){
                cout<<"Dont know."<<endl<<s;return 0;
        }
        if(s==2){
                if(dk[2]==1&&af[2]==2||dk[2]==2&&af[2]==1||dk[2]==2&&af[2]==3||dk[2]==3&&af[2]==2){
                        cout<<"xiaoa will win."<<endl<<s;return 0;
                }
                else cout<<"Dont know."<<endl<<s;
        }
        if(s==3){
                if(dk[2]==1&&af[2]==2||dk[2]==2&&af[2]==1||dk[2]==2&&af[2]==3||dk[2]==3&&af[2]==2){
                        cout<<"xiaoa will win."<<endl<<s;return 0;
                }
                else cout<<"Dont know."<<endl<<s;
        }
        return 0;
}

*/

/*
P1980 [NOIP2013 普及组] 计数问题

题目描述

试计算在区间 111 到 nn n的所有整数中，数字x(0≤x≤9) x(0 ≤ x ≤ 9)x(0≤x≤9)共出现了多少次？例如，在 111到11 11 11中，即在

1,2,3,4,5,6,7,8,9,10,111,2,3,4,5,6,7,8,9,10,111,2,3,4,5,6,7,8,9,10,11 中，数字 11
 出现了 444 次。 输入格式

222个整数n,xn,xn,x，之间用一个空格隔开。
输出格式

111个整数，表示xxx出现的次数。
输入输出样例
输入 #1

11 1

输出 #1

4

说明/提示

对于 100%100\%100%的数据，1≤n≤1,000,000,0≤x≤91≤ n ≤ 1,000,000,0 ≤ x ≤ 91≤n≤1,000,000,0≤x≤9。


code:
int main(){
        int i,n,m,p,k,t=0;cin>>n>>m;
    for(i=1;i<=n;i++){
        p=i;
        while(p!=0){
            k=p%10;
            p=p/10;
            if(k==m) t++;
        }
    }
    cout<<t;
        return 0;
}

*/

/*
P2006 赵神牛的游戏

题目描述

在 DNF 中，赵神牛有一个缔造者，他一共有 kkk 点法力值，一共有 mmm 个技能，每个技能耗费的法力值为 aia_iai?，可以造成的伤害为 bib_ibi?，而 boss

 的体力值为 nnn，请你求出它放哪个技能，才可以打死 boss。


当然，赵神牛技术很菜，他一局只放一个技能,不过每个技能都可以放无数次。
输入格式

第一行有三个整数，分别表示 k,m,nk,m,nk,m,n。

后面 mmm 行，每行两个整数，第 (i+1)(i + 1)(i+1) 行的整数表示耗费的法力值 aia_iai? 和造成的伤害 bib_ibi?。
 输出格式

输出仅一行，既可以杀死 boss 的技能序号，如果有多个，按从小到大的顺序输
，中间用一个空格隔开；如果没有技能能杀死 boss，输出 -1。
 输入输出样例 输入 #1

100 3 5000
20 1000
90 1
110 10000

输出 #1

1

输入 #2

50 4 10
60 100
70 1000
80 1000
90 0

输出 #2

-1

说明/提示
数据规模与约定

对于全部的测试点，满足：

    0≤n,m,k≤3×1040\le n,m,k\le 3\times 10^40≤n,m,k≤3×104,
    1≤ai,bi≤21474836471 \leq a_i,b_i\le 214
4836471≤ai?,bi?≤2147483647。

code:
int t,n,b,c,h,f;
int main() {
    cin>>t>>n>>b;
    for(int i=1; i<=n; i++) {
        cin>>c>>h;
        if((!c&&h)||(c&&(t/c)*h>=b))
            f=1,cout<<i<<' ';
    }
    if(!f)cout<<-1;
    return 0;
}

*/

/*
P2043 质因子分解

题目描述

对N!进行质因子分解。
输入格式

输入数据仅有一行包含一个正整数N，N<=10000。
输出格式

输出数据包含若干行，每行两个正整数p,a，中间用一个空格隔开。表示N!包含a个质因子p,要求按p的值从小到大输出。
输入输出样例
输入 #1

10

输出 #1

2 8
3 4
5 2
7 1

说明/提示

10!=3628800=(2^8)*(3^4)*(5^2)*7

code:
int a[10001]={0},n;
int main(){
    cin>>n;
    for (int i=2;i<=n;i++){
        int i2=i;
        for (int j=2;j<=i;j++) while(i2%j==0){a[j]++; i2/=j;}
    }
    for (int i=1;i<=n;i++)if (a[i]!=0)cout<<i<<" "<<a[i]<<endl;
}

*/

/*
P2077 红绿灯

题目描述

在一个城市，有一条笔直的公路，在这条公路上有 NNN 个十字路口，每个路口都设有一个红绿灯，已知相邻的两个路口距离为 AiA_iAi? 千米

(1≤i<N)(1\le i < N)(1≤i<N)，每个路口的红灯时间为 RiR_iRi?，绿灯时间为 GiG_iGi?，没有黄灯，现在有一辆车从距离 111 号十字路口 MMM
千米的位置出发，且此时所有路口的红绿灯刚

从红灯跳到绿灯，问这辆车通过每个路口的时间(不能闯红灯，这辆车的速度为 111 千米每分钟)。



 输入格式

第一行两个正整数 NNN 和 MMM

第二行 N?1N-1N?1 个正整数 AiA_iAi?

第三行 NNN 个正整数 RiR_iRi?，为红灯时间（分钟）

第四行 NNN 个正整数 GiG_iGi?，为绿灯时间（分钟）
输出格式

共 NNN 行，每行一个正整数，为这辆车通过每个十字路口的最早时间。
输入输出样例
输入 #1

5 3
2 4 3 2
3 4 3 4 3
2 3 2 3 1

输出 #1

5
7
11
14
16

说明/提示

对于 50%50\%50% 的数据 N≤1000N\le 1000N≤1000；

对于 100%100\%100% 的数据 N≤105N\le 10^5N≤105，M,Ai≤10M,A_i\le 10M,Ai?≤10，Ri，Gi≤
 R_i，G_i\le 5Ri?，Gi?≤5。

code:
int main(){
    int n,m;cin>>n>>m;
    int a[n];
    for(int i=0;i<n-1;i++)cin>>a[i];
    int r[n+1],g[n+1];
    for(int i=0;i<n;i++)cin>>r[i];
    for(int i=0;i<n;i++)cin>>g[i];
    for(int i=0;i<n;i++){
        if (i>=1) m+=a[i-1];
        if(g[i]<m%(r[i]+g[i])) m+=(r[i]+g[i]-m%(r[i]+g[i]));
        cout<<m<<endl;
    }
        return 0;
}

*/

/*
P2084 进制转换

题目背景

无
题目描述

今天小明学会了进制转换，比如（10101）2 ，那么它的十进制表示的式子就是 :

1*2^4+0*2^3+1*2^2+0*2^1+1*2^0，

那么请你编程实现，将一个M进制的数N转换成十进制表示的式子。

注意：当系数为0时，该单项式要省略。
输入格式

两个数，M和N，中间用空格隔开。
输出格式

共一行，一个十进制表示的式子。
输入输出样例
输入 #1

2 10101

输出 #1

1*2^4+1*2^2+1*2^0

说明/提示

对于100%的数据，1<M<10，N的位数不超过1000。

code:
int main(){
    int m;
    char c[1001];
    cin>>m;
    gets(c);
    for (int i=1;i<strlen(c);i++){
    if(i!=1&&c[i]!='0') printf("+");
    if (c[i]=='0') continue;
    cout<<c[i]<<"*"<<m<<"^"<<strlen(c)-i-1;
    }
}

*/

/*
P2181 对角线

题目描述

对于一个 nnn 个顶点的凸多边
，它的任何三条对角线都不会交于一点。请求出图形中对角线交点的个数。

例如，666 边形：

输入格式

输入只有一行一个整数 nnn，代表边数。
输出格式

输出一行一个整数代表答案。
输入输出样例
输入 #1

3

输出 #1

0

输入 #2

6

输出 #2

15

说明/提示
数据规模与约定

    对于 50%50 \%50% 的数据，保证 3≤n≤1003 \leq n \leq 1003≤n≤100。
    对于 100%100 \%100% 的数据，保证 3≤n≤1053 \leq n \leq 10^53≤n≤105。


code:
unsigned long long n;
int main(){
    cin>>n;
    cout<<(n*(n-1)/2*(n-2)/3*(n-3)/4);
    return 0;
}

*/

/*
P2192 HXY玩卡片

题目描述

HXY得到了一些卡片，这些卡片上标有数字 000 或 555 。现在她可以选择其中一些卡片排成一列，使得排出的一列数字组成的数最大，
 满足被 90909
 整除这个条件。同时，这个数必须为合法的某个非负整数，即不能含有前导 000 ，即 000 不能作为这串数的首位。但是特殊地，整数 000 满足条件。如果不能排出这样的数，输出“?1-1?1”。






 输入格式

第一行，卡片的个数 nnn 。

第二行，分别给出了这 nnn 个数（只能为数字 555 或 000 ）。
输出格式

仅一行，如果可以排出，则输出这个数。否则输出-1。
输入输出样例
输入 #1

4
5 0 5 0

输出 #1

0

输入 #2

11
5 5 5 5 5 5 5 5 0 5 5

输出 #2

5555555550

输入 #3

2
5 5

输出 #3

-1

说明/提示

数据范围：

对于 30%30\%30% 的数据，n≤10n\le 10n≤10 ；

对于 20%20\%20% 的数据，仅含数字 555 ；

对于 100%100\%100% 的数据，n≤1000n\le 1000n≤1000 。

code:
int main() {
    int n,z,f,a,f1,i;
    cin>>n;
    for(i=0; i<n; i++) {
        cin>>a;
        if(a==0)z++;
        else if(a==5)f++;
    }
    if(f>=9&&z>0) {
        f1=f/9*9;
        for(i=0; i<f1; i++)cout<<'5';
        for(i=0; i<z; i++)cout<<'0';
    } else if(z>0){
        cout<<'0';
    } else cout<<"-1";
    return 0;
}

*/

/*
P2356 弹珠游戏

题目背景

元宵节不放假挺郁闷的，于是时间机智的改到了星期6一整天！
题目描述

MedalPluS 和他的小伙伴 NOIRP 发掘了一个骨灰级别的游戏――超级弹珠。

游戏的内容是：在一个 n*n 的矩阵里，有若干个敌人，你的弹珠可以摧毁敌人，但只

能攻击你所在的行、列里的所有敌人，然后你就可以获得他们的分数之和，现在请你选择

一个你的位置，使得能击杀的敌人最多，注意，你不能和敌人在一个地方
输入格式

输入有两行，第一行一个正整数 n，接下来 n 行，每行 n 列，如果有敌人则为一个正整数，否则为 0
 输出格式

输出共一行，最多分数，如果连你的容身之地都没有，请输出“Bad Game!”
输入输出样例
输入 #1

4
1 1 1 0
1 1 1 1
1 1 1 1
0 1 1 1

输出 #1

6

说明/提示

送分题，客官请拿好，(*^__^*) 嘻嘻……

【数据范围】

对于 30%的数据，1≤n≤10

对于 100%的数据，1≤n≤1000，保证容身之地的数量小于 10000

code:
int n,s[5000][5000],maxn;
bool u=0;
int NOIRP(int x,int y){
    int ans=0;
    for(int i=1; i<=n; i++)if(s[x][i])ans+=s[x][i];
    for(int i=1; i<=n; i++)if(s[i][y])ans+=s[i][y];
    return ans;
}
int main(){
    cin>>n;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n; j++)
            cin>>s[i][j];
    for(int i=1; i<=n; i++)
        for(int j=1; j<=n;j++)
            if(!s[i][j])u=1,maxn=max(NOIRP(i,j),maxn);
    if(!u)cout<<"Bad Game!";
    else cout<<maxn; return 0;
}

*/

/*
P2393 yyy loves Maths II

题目背景

上次Xm redbag 可把 yyy 气坏了，yyy 说他只是小学生，Xm redbag 这次不坑他了。
题目描述

redbag 给了 yyy 很多个数，要 yyy 计算这些数的和。

必须要快，redbag 只给了 yyy 111 秒的时间！！！
输入格式

一行，很多个数。
输出格式

一行，一个实数(四舍五入精确到 555 位小数)，表示这些数的和。
输入输出样例
输入 #1

1

输出 #1

1.00000

说明/提示

对于 100%100\%100% 的数据，所有数 ≤233,333,333 \le 233,333,333 ≤233,333,333，保证在小数点
 最多有 666 位数，最多共有 5×1045\times 10^45×104 个数。




code:
int main(){
    long double a,sum;
    if(scanf("%Lf",&a)!=EOF){
        sum+=a*1000000;
        main();
    }
    else printf("%.5Lf",sum/1000000);
    return 0;
}

*/

/*
P2394 yyy loves Chemistry I

题目背景

因为会吃回车,所以放到题目描述里了喵~
题目描述

[故事背景]

从前,有个人叫yyy,他特别喜欢化学,尤其是一些很危(zuo)险(si)的实验.

[题目背景]

这一天,他开始研究起了一个神奇又有趣的方程式

2Na + 2H2O ==== 2NaOH + H2↑

[问题描述]

现在yyy将一块质量为xg的钠投入很多的水中,然后开始收集氢气.

最终,我们知道,后来,这块钠在水中游动着消失了.而yyy很厉害,把氢气全收集起来了.

已知每投入了23克的钠,就会生成1克的氢气.

那么现在yyy收集了多少克氢气呢?
输入格式

一行,一个实数x,代表yyy将多少克钠投入了水中

输入文件行末一定不会有一只回车啦~
输出格式

一行,一个实数(四舍五入精确到8位小数),代表生成了多少克氢气
输入输出样例
输入 #1

0.23

输出 #1

0.01000000

说明/提示

[数据规模]

对于100%的数据,0<x<=1

[提示]

你想知道x有几位小数吗?才不给你呢>_<

我只知道空间限制是4M,时间限制是0.1s,而且如果你把数字全读下来的话可能就MLE咯~

kkksc:没有数据范围怎么行!输入文件不超过5M!

出题人:怎么能这样!差评!我不好挖坑了!

code:
int main(){
    long double x;
    scanf("%15Lf",&x);
    printf ( "%.8Lf", x / 23 );
    return 0;
}

*/

/*
P2415 集合求和

题目描述

给定一个集合s（集合元素数量<=30），求出此集合所有子集元素之和。
输入格式

集合中的元素（元素<=1000）
输出格式

和
输入输出样例
输入 #1

2 3

输出 #1

10

说明/提示

子集为：

[] [2] [3] [2 3] 2+3+2+3=10

保证结果在10^18以内。

code:
int main(){
    int a[31],i=0,j;
    long long s=0;
    while(cin>>a[i++]);
    for(j=0;j<i;j++){
        s+=a[j];
    }
    s*=pow(2,i-2);
    cout<<s;
    return 0;
}

*/

/*
P2433 【深基1-2】小学数学 N 合一

题目描述
问题 1

请输出 I love Luogu!
问题 2

这里有 10 个苹果，小A 拿走了 2 个，Uim 拿走了 4 个，八尾勇拿走剩下的所有的苹果。我们想知道：



    小A 和 Uim 两个人一共拿走多少苹果？
    八尾勇能拿走多少苹果？

现在需要编写一个程序，输出两个数字作为答案，中间使用空格分开。
问题 3

现在有 14 个苹果。要均分给 4 名同学，分不掉的苹果放回冰箱。请问：

    每位同学能分得几个苹果？

    一共分出去多少苹果？

    把几个苹果放回冰箱？

    现在需要编写一个程序，输出三个数字作为答案，每个数字一行。

问题 4

现在有 500 毫升的肥宅快乐水，要均分给 3 名同学，每位同学可以分到多少毫升？请输出一个数字作为输出。保留
 6
位有效数字，且不使用科学计数法。 问题 5

甲列火车长 260 米，每秒行 12 米；乙列火车长 220 米，每秒行 20 米，两车相向而行，从两车车头相遇时开始计时，多长时间后两车车尾相离？已知答案是整数。


问题 6

一个长方形长宽分别是 6cm、9cm，求它的对角线长度（cm）。直接使用 cout 输出。
问题 7

Uim 银行账户里面有100元。经过了下面的操作：

    往里面存了 10 元；

    购物花掉了 20 元；

    把里面的钱全部取出。

    请在每次操作后输出账户余额，并使用换行符隔开。

问题 8

当半径为 r=5，请输出圆的周长、面积和球体积。取 π=3.141593。请直接使用 cout 输出答案，每行一个数字。
 问题 9

一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；第二天他也刚好吃了剩余桃子的一半，贪嘴多吃了一个；第三天他又刚好吃了剩下的桃子的一半，并贪嘴多吃了一个。第四天起来一看，发现桃子只剩下一个了。请问小猴买了几个桃子？
问题 10

洛谷的评测任务是单位时间内均匀增加的。8 台评测机 30 分钟可以刚好把评测队列中的程序评测完毕，10 台评测机 6 分钟可以刚好把评测队列中的程序

 测完毕，请问几台评测机可以在 10 分钟时刚好把评测队列中的程序评测完毕？


 问题 11

小A跑步速度 5m/s，八尾勇跑步速度 8m/s，八尾勇在小A后面 100m，他们同时起跑，请问需要多长时间八尾勇可以追上小A？输出一个数字表示答案，
 用 c
ut 直接输出。 问题 12

大家都知道有 26 个英文字母，其中A是第一个字母。现在请编程求出：

    M 是字母表中的第几个字母？
    第 18 个字母是什么？

输出一个数字和一个字母，使用换行隔开。
问题 13

小 A 有两块球形橡皮泥，一个半径是 4，一个半径是 10。他想把这两块橡皮泥揉在一起，然后塑造成一个正方体，请问这个正方体的棱长是多少

如果结果不是整数，则舍去小数点之后的数字。取 π=3.141593\pi = 3.141593π=3.141593。
 问题 14

根据咕咕网校的预测，当课程定价为 110 元时，会有 10 人报名。如果课程价格每降低 1 元，就会多 1 名报名者（反之亦然）。如果希望总共能收到 3500 元学费的话，那么应该定价多少呢？已知本题有两个答案符合要求，则取较


的那一个。如果这个答案不是整数，则需四舍五入精确到整数。

输入格式

输入一个数字，表示第几个问题。
输出格式

根据每个问题，输出一个答案。
输入输出样例
输入 #1

2

输出 #1

6 4

说明/提示

请解决以下小学数学题。你可以提交答案，也可以写一个程序。

对于本题来说，如果你不知道怎么输入，也可以这么抄：

#include<iostream>
// 填上你觉得需要的其他头文件
using namespace std;
int main() {
    int T;
    cin >> T;
    if (T == 1) {
        // 粘贴问题 1 的主函数代码，除了 return 0
        cout << "I love Luogu!";
    } else if (T == 2) {
        // 粘贴问题 2 的主函数代码，除了 return 0
        cout << 2 + 4 << " " << 10 - 2 - 4;
    } else if (T == 3) {
        // 请自行完成问题 3 的代码
    } else if (T == 4) {
        // 请自行完成问题 4 的代码
    } else if (T == 5) {
        // 请自行完成问题 5 的代码
    } else if (T == 6) {
        // 请自行完成问题 6 的代码
    } else if (T == 7) {
        // 请自行完成问题 7 的代码
    } else if (T == 8) {
        // 请自行完成问题 8 的代码
    } else if (T == 9) {
        // 请自行完成问题 9 的代码
    } else if (T == 10) {
        // 请自行完成问题 10 的代码
    } else if (T == 11) {
        // 请自行完成问题 11 的代码
    } else if (T == 12) {
        // 请自行完成问题 12 的代码
    } else if (T == 13) {
        // 请自行完成问题 13 的代码
    } else if (T == 14) {
        // 请自行完成问题 14 的代码
    }
    return 0;
}

code:
int n;
int main(){
    cin>>n;
    if(n==1){
        cout<<"I love Luogu!"<<endl;
    }
    if(n==2){
        cout<<6<<" "<<4<<endl;
    }
    if(n==3){
        cout<<3<<endl<<12<<endl<<2<<endl;
    }
    if(n==4){
        cout<<166.666667<<endl;
    }
    if(n==5){
        cout<<15<<endl;
    }
    if(n==6){
        cout<<10.816653826391967879357663802411<<endl;
    }
    if(n==7){
        cout<<110<<endl<<90<<endl<<0<<endl;
    }
    if(n==8){
        cout<<31.41593<<endl<<78.539825<<endl<<523.59883333333333333333333333333<<endl;
    }
    if(n==9){
        cout<<22<<endl;
    }
    if(n==10){
        cout<<9<<endl;
    }
    if(n==11){
        cout<<33.3333333333<<endl;
    }
    if(n==12){
        cout<<13<<endl<<'R'<<endl;
    }
    if(n==13){
        cout<<16<<endl;
    }
    if(n==14){
        for(int i=1;i<=110;i++){
            int s=120-i;
            int ans=s*i;
            if(ans==3500) {cout<<i<<endl;break;}
        }
    }
    return 0;
}

*/

/*=
P2524 Uim的情人节礼物・其之r

题目描述

前传：详见洛谷P2525

Uim成功地按照顺序将礼物送到了N个妹子的手里并维持她们的和谐。

Uim现在想知道，他最终选择的顺序是所有给N个妹子送礼顺序中、字典序第几小的。
输入格式

第一行一个整数N，表示有N个数。

第二行一个整数X，表示给出的排列。
输出格式

一个整数，表示是第几小的字典序。
输入输出样例
输入 #1

3
231

输出 #1

4

说明/提示

1<=N<=9

输入的排列没有空格

code:
int main(){
    char s[108];
    int n,fac[]={1,1,2,6,24,120,720,5040,40320,362880};
    cin>>n>>s;
    int ans=0;
    for(int i=0;i<n;i++){
        int smaller=0;
        for(int j= i+1 ;j<n;j++)
            if(s[i] > s[j])smaller++;
        ans += smaller*fac[n-i-1];
    }
    cout<<ans+1;
    return 0;
}

*/

/*
P2525 Uim的情人节礼物・其之

题目描述

情人节到了，Uim打算给他的后宫们准备情人节礼物。UIm一共有N（1<=N<=9）个后宫妹子（现充去死 挫骨扬灰!）。



为了维护他的后宫的稳定。他通过编程，得出了一个送礼物的最佳顺序。这个我们管不着。

然而他认为，如果什么事情做得太圆满不是什么好事。于是他希望得到 原定顺序 的 前一个字典序的序列。
 输入格式

第一行一个整数N

第二行N个整数，表示原定排列
输出格式

前一个排列
输入输出样例
输入 #1

3
1 3 2

输出 #1

1 2 3

说明/提示

若当前排列已经是第一个，则输出'ERROR'（引号不输出）

[del]骗分？嗯哼哼。。。[/del]

code:
int main(){
    int n;cin>>n;
    int a[n];
    for(int i=0;i<n;i++) cin>>a[i];
    if(prev_permutation(a,a+n))
        for(int i=0;i<n;i++)
            cout<<a[i]<<" ";
    else cout<<"ERROR";
    return 0;
}

*/

/*
P2550 [AHOI2001]彩票摇奖

题目描述

为了丰富人民群众的生活、支持某些社会公益事业，北塔市设置了一项彩票。该彩票的规则是：

    每张彩票上印有 777 个各不相同的号码，且这些号码的取值范围为 1?331\sim331?33。
 每次在兑奖前都会公布一个由七个各不相同的号码构成的中奖号码。
    共设置 777 个奖项，特等奖和一等奖至六等奖。

兑奖规则如下：

    特等奖：要求彩票上 777 个号码都出现在中奖号码中。
    一等奖：要求彩票上有 666 个号码出现在中奖号码中。
    二等奖：要求彩票上有 555 个号码出现在中奖号码中。
    三等奖：要求彩票上有 444 个号码出现在中奖号码中。
    四等奖：要求彩票上有 333 个号码出现在中奖号码中。
    五等奖：要求彩票上有 222 个号码出现在中奖号码中。
    六等奖：要求彩票上有 111 个号码出现在中奖号码中。

注：兑奖时并不考虑彩票上的号码和中奖号码中的各个号码出现的位置。例如，中奖号码为 23 31 1 14 19 17 1823\ 31\ 1\ 14\ 19\ 17\ 1823 31 1 14 19 17 18，则彩票 12 8 9 23 1

 16 712\ 8\ 9\ 23\ 1\ 16\ 712 8 9 23 1 16 7 由于其中有两个号码（232323 和 111）出现在中奖号码中，所以该彩票中了
 等奖。


现已知中奖号码和小明买的若干张彩票的号码，请你写一个程序帮助小明判断他买的彩票的中奖情况。
输入格式

输入的第一行只有一个自然数 nnn，表示小明买的彩票张数；

第二行存放了 777 个介于 111 和 333333 之间的自然数，表示中奖号码；

在随后的 nnn 行中每行都有 777 个介于 111 和 333333 之间的自然数，分别表示小明所买的 nnn 张彩票。
 输出格式

依次输出小明所买的彩票的中奖情况（中奖的张数），首先输出特等奖的中奖张数，然后依次输出一等奖至六等奖的中奖张数。
输入输出样例
输入 #1

2
23 31 1 14 19 17 18
12 8 9 23 1 16 7
11 7 10 21 2 9 31

输出 #1

0 0 0 0 0 1 1

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 1≤n<10001 \leq n\lt10001≤n<1000。

code:
int n,a,b,c[34],d[8];
int main(){
    cin>>n;
    for(int i=1;i<=7;i++){
        cin>>b;
        c[b]=1;
    }
    for(int i=1;i<=n;i++){
        int sx=0;
        for(int j=1;j<=7;j++){
            cin>>a;
            if(c[a]==1)sx++;
        }
        d[7-sx+1]++;
    }
    for(int i=1;i<=7;i++){
        cout<<d[i]<<" ";
    }
    return 0;
}

*/

/*
P2637 第一次，第二次，成交！

题目描述

因为奶牛们的节食运动给 FJ 余下了一大批干草无法处理，所以他准备要开一
拍卖会去出售他的干草。

他有 nnn 批干草（每批大约 100100100 捆）。他的客户有 mmm 个，都是和他相邻的农夫。第 iii 名农夫会告诉 FJ 他会为 FJ 

每批干草付 pip_ipi? 的钱。每个农夫都想买（也只想买）FJ 的一批草料。



为了确保农夫们不会互相嫉妒，所以 FJ 决定要以一个固定的价格出售他的草料。每一个出价比 FJ 的要价

高的农夫将会买到草料，余下的将会被拒绝购买。


请你帮助 FJ 找出能让他赚到最多的钱的最低的单批草料的售价。
输入格式

第一行：两个被空格隔开的整数，nnn 和 mmm。

第二行到第 m+1m+1m+1 行：第 i+1i+1i+1 行只包含一个整数：pip_ip
?。 输出格式

共一行，包含由空格隔开的两个整数：FJ 能出的每批草料的最低价格，以及他能赚到的最多的钱。
 输入输出样例 输入 #1

5 4
2
8
10
7

输出 #1

7 21

说明/提示

FJ 有 555 批草料，444 个农夫想要购买。他们出价分别为：每批草料为 222，888，101010 和 777。



FJ 应该把价格设定为 777，这样会有 333 个农夫会付钱买草料，FJ 自己会挣到 212121 的钱。



对于 100%100\%100% 的数据，1≤n≤10001\leq n\leq 10001≤n≤1000，1≤m≤10001\leq m\leq 10001≤m≤1000，1≤pi≤1,000,0
 01\leq p_i\leq 1,000,0001≤pi?≤1,000,000。

code:
int n,m,larger1=0,larger2=0;
int main(){
    cin>>n>>m;
    int t[m],e=n;
    for(int i=0;i<m;i++)cin>>t[i];
    sort(t,t+m);
    if(m<n)e=m;
    for(int i=0;i<e;i++){
        if(t[m-i-1]*(i+1)>larger1){
            larger1=t[m-i-1]*(i+1);
            larger2=t[m-i-1];
        }
    }
    cout<<larger2<<" "<<larger1;
    return 0;
}

*/

/*
P2666 [USACO07OCT]Bessie's Secret Pasture S

题目背景

背景就是描述，描述就是背景。
题目描述

Farmmer
John最近收割了几乎无限多块牧草，将它们堆放在空地上。这些牧草都是正方形的，而且都有非负整数长度的边长（当然有0）。一天它的奶牛Bessie发现了这些美味的牧草，于是希望把它们种在自己的秘密牧场上。他总将草皮分割成1*1的小块，以放入他牧场上的N个格子中。

Bessie感兴趣的是，她若选取四块会有多少种不同方法。如果N=4，那么她就有5种不同分发：(1,1,1,1),(2,0,0,0),(0,2,0,0),(0,0,2,0),(0,0,0,2)，括号内数表示边长。注意这里不讲究顺序，如(1,2,3,4)与(4,3,2,1)是两种不同方法。
输入格式

仅一行，一个整数N。
输出格式

同样为一行，包含一个整数，为方案总数。
输入输出样例
输入 #1

4

输出 #1

5

说明/提示

对于100%的数据，1<=N<=10000。

code:
int sqr[101],num[10001];
int main() {
    int n,f,ans=0;
    cin>>n;
    f=sqrt(n);
    for(int i=0; i<=f; i++)sqr[i]=i*i;
    for(int i=0; i<=f; i++){
        for(int j=0; j<=f; j++){
            if(sqr[i]+sqr[j]>n) break;
                num[sqr[i]+sqr[j]]++;
        }
    }
    for(int i=0; i<=f; i++) {
        for(int j=0; j<=f; j++) {
            if(sqr[i]+sqr[j]>n)	break;
            ans+=num[n-sqr[i]-sqr[j]];
        }
    }
    cout<<ans;
    return 0;
}

*/

/*
P2669 [NOIP2015 普及组] 金币

题目描述

国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续N天每天收到N枚金币后，骑士会在之后的连续N+1N+1N+1天里，每天收到N+1N+1N+1枚金币。

请计算在前KKK天里，骑士一共获得了多少金币。
输入格式

一个正整数KKK，表示发放金币的天数。
输出格式

一个正整数，即骑士收到的金币数。
输入输出样例
输入 #1

6

输出 #1

14

输入 #2

1000

输出 #2

29820

说明/提示

【输入输出样例 1 说明】

骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 1+2+2+3+3+3=141+2+2+3+3+3=141+2+2+3+3+3=14 枚金币。



对于 100%100\%100%的数据，1≤K≤10,000 1 ≤ K ≤ 10,0001≤K≤10,000。

code:
int main() {
    int k,t=1,j=0,p=0;cin>>k;
    for(int i=1;i<=k;i++){
        p+=t;
        j++;
        if(j==t){
            t++;
            j=0;
        }
    }
    cout<<p;
    return 0;
}

*/

/*
P2670 [NOIP2015 普及组] 扫雷游戏

题目描述

扫雷游戏是一款十分经典的单机小游戏。在nnn行mmm列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字――提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。

现在给出nnn行mmm列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。

注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。
输入格式

第一行是用一个空格隔开的两个整数nnn和mmm，分别表示雷区的行数和列数。

接下来nnn行，每行mmm个字符，描述了雷区中的地雷分布情况。字符’*’表示相应格子是地雷格，字符’?’表示相应格子是非地雷格。相邻字符之间无分隔符。
输出格式

输出文件包含nnn行，每行mmm个字符，描述整个雷区。用’*’表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。
输入输出样例
输入 #1

3 3
*??
???
?*?

输出 #1

*10
221
1*1

输入 #2

2 3
?*?
*??

输出 #2

2*1
*21

说明/提示

对于 100%100\%100%的数据， 1≤n≤100,1≤m≤1001≤n≤100, 1≤m≤1001≤n≤100,1≤m≤100。

code:
char a[101][101];
int b[101][101]={0};
int n,m,i,j;
int dx[8]={1,0,-1,0,-1,1,1,-1};
int dy[8]={0,1,0,-1,-1,-1,1,1};
void dfs(int x,int y){
    int nx,ny,k;
    for (k=0;k<8;k++){
        nx=x+dx[k];
        ny=y+dy[k];
        if (nx>=1&&nx<=n&&ny>=1&&ny<=m)b[nx][ny]++;
    }
}
int main(){
    cin>>n>>m;
    for (i=1;i<=n;i++)
        for (j=1;j<=m;j++){
            cin>>a[i][j];
            if (a[i][j]=='*')dfs(i,j);
        }
    for (i=1;i<=n;i++) {
        for (j=1;j<=m;j++)
            if (a[i][j]=='*')cout<<a[i][j];
            else cout<<b[i][j];
        cout<<endl;
    }
    return 0;
}

*/

/*
P2676 [USACO07DEC]Bookshelf B

题目描述

Farmer
John最近为奶牛们的图书馆添置了一个巨大的书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。

所有N(1 <= N <= 20,000)头奶牛都有一个确定的身高H_i(1 <= H_i <= 10,000)。设所有奶牛身高的和为S。书架的高度为B
 并且保证 1 <= B <= S < 2,000,0
0,007。


为了够到比最高的那头奶牛还要高的书架顶，奶牛们不得不像演杂技一般，一头站在另一头的背上，叠成一座“奶牛塔”。当然，这个塔的高度，就是塔中所有奶牛的身高之和。为了往书架顶上放东西，所有奶牛的身高和必须不小于书架的高度。

显然，塔中的奶牛数目越多，整座塔就越不稳定，于是奶牛们希望在能够到书架顶的前提下，让塔中奶牛的数目尽量少。 现在，奶牛们找到了你，希望你帮她们计算这个最小的数目。
 输入格式

    第1行: 2个用空格隔开的整数：N 和 B * 第2..N+1行: 第i+1行是1个整数：H_i

输出格式

    第1行: 输出1个整数，即最少要多少头奶牛叠成塔，才能够到书架顶部

输入输出样例
输入 #1

6 40
6
18
11
13
19
11

输出 #1

3

说明/提示

输入说明:

一共有6头奶牛，书架的高度为40，奶牛们的身高在6..19之间。

输出说明:

一种只用3头奶牛就达到高度40的方法：18+11+13。当然还有其他方法，在此不一一列出了。

code:
int main(){
    int n,b,s=0;
    cin>>n>>b;
    int h[n]={0};
    for(int i=0;i<n;i++)
    cin>>h[i];
    sort(h,h+n);
    for(int i=n-1;;i--){
        s=s+h[i];
        if(s>b){
            cout<<n-i;
            break;
        }
    }
    return 0;
}

*/

/*
P2689 东南西北

题目描述

给出起点和终点的坐标及接下来T个时刻的风向(东南西北)，每次可以选择顺风偏移1个单位或者停在原地。求到达终点的最少时间。

如果无法偏移至终点，输出“-1”。
输入格式

第一行两个正整数x1,y1，表示小明所在位置。

第二行两个正整数x2,y2，表示小明想去的位置。

第三行一个整数T，表示T个时刻。

第四至第N+3行，每行一个字符，表示风向，即东南西北的英文单词的首字母。
输出格式

最少走多少步。
输入输出样例
输入 #1

1 1
2 2
5
E
N
W
W
N

输出 #1

2

输入 #2

1 1
2 2
1
W

输出 #2

-1

输入 #3

1 1
2 2
3
W
W
W

输出 #3

-1

说明/提示

样例1：向东走一步，向北走一步。

样例2、3：无法到达。

1<=T<=50

东：East

南：South

西：West

北：North

code:
int main(){
    int x1,y1,x2,y2;
    cin>>x1>>y1>>x2>>y2;
    bool t=0;
    char eastorwest,southornorth;
    int eastorwestnumber,southornorthnumber;
    if (x1>x2){
        eastorwest='W';
        eastorwestnumber=abs(x1-x2);
    }else {
        eastorwest='E';
        eastorwestnumber=abs(x1-x2);
    }
    if (y1>y2){
        southornorth='S';
        southornorthnumber=abs(y1-y2);
    }else {
        southornorth='N';
        southornorthnumber=abs(y1-y2);
    }
    int k=0,n=0,m=0;char p;
    cin>>k;
    for(int i=0;i<k;i++){
        cin>>p;
        if(eastorwest == p)if(n<eastorwestnumber)n++;
        if(southornorth == p)if(m<southornorthnumber)m++;
    }
    if((n==eastorwestnumber) && (m==southornorthnumber))t=1;
    if(t==0)cout<<"-1";
    else cout<<abs(x1-x2)+abs(y1-y2);
    return 0;
}

*/

/*
P2705 小球

题目描述

有 R 个红色盒子和 B 个蓝色盒子，还有 R 个红色小球和 B 个蓝色小球。每个盒子只能装一个小球，每个小球都要放在一个盒子里。



如果把一个红色小球放在一个红色盒子里，那么得分是 C。如果把一个蓝色小球放在一个蓝色盒子里，那么得分是 D。如果把一个红色小球放在一个蓝色盒子里

 那么得分是 E。如果把一个蓝色
球放在一个红色盒子里，那么得分也是 E。



现在给出 R，B，C，D
E。应该如何放置这些小球进盒子，才能使得总得分最大？输出最大的总得分。
输入格式

一行，5 个整数，分别是 R，B，C，D，E。
输出格式

一个整数，最大总得分。
输入输出样例
输入 #1

2 3 100 400 200

输出 #1

1400

输入 #2

2 3 100 400 300

输出 #2

1600

说明/提示

【数据规模】

1 ≤ R ≤ 100，1 ≤ B ≤ 100， -1000 ≤ C，D，E ≤ 1000。

code:
int main(){
    int r,b,c,d,e,ans;
    cin>>r>>b>>c>>d>>e;
    if(c+d>2*e) ans=r*c+b*d;
    else{
        if(r>b)ans=b*2*e+(r-b)*c;
        else ans=r*2*e+(b-r)*d;
    }
    cout<<ans;
    return 0;
}

*/

/*
P2708 硬币翻转

题目描述

有很多个硬币摆在一行，有正面朝上的，也有背面朝上的。正面朝上的用1表示，背面朝上的用0表示。

现在要求从这行的第一个硬币开始，将从第一个硬币开始的前若干个硬币同时翻面，求如果要将所有硬币翻到正面朝上，最少要进行这样的操作多少次？
输入格式

一个字符串，由0和1组成，表示硬币状态
输出格式

一个整数，表示要翻转的最少次数
输入输出样例
输入 #1

10

输出 #1

2

说明/提示

【样例1说明】：

第1次翻转：把第一个硬币翻到反面，字符串为00

第2次翻转：把第一、二个硬币一起翻到正面，字符串为11，翻转完成，输出2

【数据范围】：

对于20%的数据，硬币个数 ≤10\leq10≤10

对于50%的数据，硬币个数 ≤104\leq10^4≤104

对于100%的数据，硬币个数 ≤106\leq10^6≤106

update(2020.10.28):更新了数据和数据范围

code:
int main(){
    string c;
    cin>>c;
    int k=0;
    for (int i=c.length();i;i--)
        if (c[i]=='0'&&c[i-1]=='1') 
            k+=2;
    if (c[0]=='0') k++;
    cout<<k;
    return 0;
}

*/

/*
P2788 数学1（math1）- 加减算式

题目背景

XmHansBug在数学考场上，挠了无数次的头，可脑子里还是一片空白。
题目描述

好不容易啊，HansBug终于熬到了做到数学最后一题的时刻了，眼前是一堆杂乱的加减算式。显然成功就在眼前了。可是他脑细胞和RP已经消耗殆尽，所以这个重要的任务就交给你们啦。
输入格式

一行，包含一个字符串形式的加减法多项式（每一项数字范围为0-32767）。
输出格式

一个整数，为计算所得的结果（保证计算结果不会超过长整型范围）。
输入输出样例
输入 #1

1+2-3

输出 #1

0

说明/提示

字符串长度不超过60000

code:
int main(){
    int ans=0,t=00;
    while(cin>>t) ans+=t;
    cout<<ans;
    return 0;
}

*/

/*
P2907 [USACO08OPEN]Roads Around The Farm S

题目描述

Farmer John's cows have taken an interest in exploring the territory around the
farm. Initially, all N (1 <= N <= 1,000,000,000) cows commence traveling down a
road in one big group. Upon encountering a fork in the road, the group sometimes
chooses to break into two smaller (nonempty) groups with each group continuing
down one of the roads. When one of those groups arrives at another fork, it
might split again, and so on.

The cows have crafted a peculiar way of splitting: if they can split into two
groups such that the sizes of the groups differ by exactly K (1 <= K <= 1000),
then they will split in that way; otherwise, they stop exploring and just start
grazing peacefully.

Assuming that there will always be new forks in the road, compute the final
number of groups of peacefully grazing cows.

约翰的N(1≤N≤1,000,000,000)只奶牛要出发去探索牧场四周的土地．她们将沿着一条路走，一直走到三岔路口（可以认为所有的路口都是这样的）．这时候，这一群奶牛可能会分成两群，分别沿着接下来的两条路继续走．如果她们再次走到三岔路口，那么仍有可能继续分裂成两群继续走． 奶牛的分裂方式十分古怪：如果这一群奶牛可以精确地分成两部分，这两部分的牛数恰好相差K(1≤K≤1000)，那么在三岔路口牛群就会分裂．否则，牛群不会分裂，她们都将在这里待下去，平静地吃草． 请计算，最终将会有多少群奶牛在平静地吃草．



 输入格式

* Line 1: Two space-separated integers: N and K
输出格式

* Line 1: A single integer representing the number of groups of grazing cows
输入输出样例
输入 #1

6 2

输出 #1

3

说明/提示

There are 6 cows and the difference in group sizes is 2.

There are 3 final groups (with 2, 1, and 3 cows in them).

6 /
2 4 /
1 3

code:
int k,ans=0;
void fen(int x){
    if(x<=k||(x-k)%2!=0){
        ans++;
        return;
    }
    fen((x-k)/2); fen((x+k)/2);
}
int main(){
    int n;
    cin>>n>>k;
    fen(n);
    cout<<ans;
    return 0;
}

*/

/*
P2911 [USACO08OCT]Bovine Bones G

题目描述

Bessie loves board games and role-playing games so she persuaded Farmer John to
drive her to the hobby shop where she purchased three dice for rolling. These
fair dice have S1, S2, and S3 sides

respectively (2 <= S1 <= 20; 2 <= S2 <= 20; 2 <= S3 <= 40).

Bessie rolls and rolls and rolls trying to figure out which three-dice sum
appears most often.

Given the number of sides on each of the three dice, determine which three-dice
sum appears most frequently. If more than one sum can appear most frequently,
report the smallest such sum.

POINTS: 70
输入格式

* Line 1: Three space-separated integers: S1, S2, and S3
输出格式

* Line 1: The smallest integer sum that appears most frequently when the dice
are rolled in every possible combination. 题意翻译

贝茜喜欢玩棋盘游戏和角色扮演游戏，所以她说服了约翰开车带她去小商店.在那里她买了三个骰子。这三个不同的骰子的面数分别为 s1,s2,s3s_1,s_2,s_3s1?,s2?,s3?。



对于一个有 SSS 个面的骰子每个面上的数字是 1,2,3,…,S1,2,3,\ldots,S1,2,3,…,S。每个
（上的数字）出现的概率均等。贝茜希望找出在所有“三个面上的数字的和”中，哪个和的值出现的概率最大。

现在给出每个骰子的面数，需要求出哪个所有“三个面上的数字的和”出现得最频繁。如果有很多个和出现的概率相同，那么只需要输出最小的那个。

数据范围： 2≤s1≤202\le s_1\leq 202≤s1?≤20，2≤s2≤202 \leq s_2\leq 202≤s2?≤20，2≤s3≤402 \leq 
 _3\leq 402≤s3?≤40。 输入输出样例
 输入 #1

3 2 3

输出 #1

5

说明/提示

Here are all the possible outcomes.

1 1 1 -> 3
1 2 1 -> 4
2 1 1 -> 4
2 2 1 -> 5
3 1 1 -> 5
3 2 1 -> 6
1 1 2 -> 4
1 2 2 -> 5
2 1 2 -> 5
2 2 2 -> 6
3 1 2 -> 6
3 2 2 -> 7
1 1 3 -> 5
1 2 3 -> 6
2 1 3 -> 6
2 2 3 -> 7
3 1 3 -> 7
3 2 3 -> 8

Both 5 and 6 appear most frequently (five times each), so 5 is the answer.

code:
int main(){
    int n,m,l;
    cin>>n>>m>>l;
    int a[n+m+l]={0};
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            for(int k=1;k<=l;k++)
                a[i+j+k-1]++;
    int t=0,k;
    for(int i=0;i<(n+m+l);i++){
        if(a[i]>t){
        t=a[i];
        k=i;
        }
    }
    cout<<k+1;
}

*/

/*
P2955 [USACO09OCT]Even? Odd? G

题目描述

Bessie's cruel second grade teacher has assigned a list of N (1 <= N <= 100)
positive integers I (1 <= I <= 10^60) for which Bessie must determine their
parity (explained in second grade as 'Even... or odd?'). Bessie is overwhelmed
by the size of the list and by the size of the numbers. After all, she only
learned to count recently.

Write a program to read in the N integers and print 'even' on a single line for
even numbers and likewise 'odd' for odd numbers.

POINTS: 25

Bessie那惨无人道的二年级老师搞了一个有 N 个正整数 I 的表叫Bessie去判断“奇偶性”（这个词语意思向二年级的学生解释，就是“这个

是单数，还是双数啊？”）。Bessie被那个表的长度深深地震惊到了，竟然跟栋栋的泛做表格一样多道题！！！毕竟她才刚刚学会数数啊。

写一个程序读入N个整数，如果是双数，那么在单立的一行内输出"even"，如果是单数则类似地输出"odd".
输入格式

* Line 1: A single integer: N

* Lines 2..N+1: Line j+1 contains I_j, the j-th integer to determine even/odd
输出格式

* Lines 1..N: Line j contains the word 'even' or 'odd', depending on the parity
of I_j 输入输出样例 输入 #1

2
1024
5931

输出 #1

even
odd

说明/提示

Two integers: 1024 and 5931

1024 is eminently divisible by 2; 5931 is not

code:
int main(){
    int n;cin>>n;
    for(int i=0;i<n;i++){
        char k[65];cin>>k;
        if((k[strlen(k)-1]-'0')%2==0)cout<<"even"<<endl;
        else cout<<"odd"<<endl;
    }
}

*/

/*
P2956 [USACO09OCT]The Robot Plow G

题目描述

Farmer John has purchased a new robotic plow in order to relieve him from the
drudgery of plowing field after field after field. It achieves this goal but at
a slight disadvantage: the robotic plow can only plow in a perfect rectangle
with sides of integer length.

Because FJ's field has trees and other obstacles, FJ sets up the plow to plow
many different rectangles, which might end up overlapping. He's curious as to
just how many squares in his field are actually plowed after he programs the
plow with various plow instructions, each of which describes a rectangle by
giving its lower left and upper right x,y coordinates.

As usual, the field is partitioned into squares whose sides are parallel to the
x and y axes. The field is X squares wide and Y squares high (1 <= X <= 240; 1
<= Y <= 240). Each of the I (1 <= I <= 200) plow instructions comprises four
integers: Xll, Yll, Xur, and Yur (1 <= Xll <= Xur; Xll <= Xur <= X; 1 <= Yll <=
Yur; Yll <= Yur <= Y) which are the lower left and upper right coordinates of
the rectangle to be plowed. The plow will plow all the field's squares in the
range (Xll..Xur, Yll..Yur) which might be one more row and column than would
initially be assumed (depending on how you go about your assumptions, of
course).

Consider a field that is 6 squares wide and 4 squares high. As FJ issues a pair
of plowing instructions (shown), the field gets plowed as shown by '*' and '#'
(normally plowed field all looks the same, but '#' shows which were most
recently plowed):

......             **....             #####.
......  (1,1)(2,4) **....  (1,3)(5,4) #####.
......             **....             **....
......             **....             **....

A total of 14 squares are plowed.

POINTS: 25

Farmer
John为了让自己从无穷无尽的犁田工作中解放出来，于是买了个新机器人帮助他犁田。这个机器人可以完成犁田的任务，可惜有一个小小的缺点：这个犁田机器人一次只能犁一个边的长度是整数的长方形的田地。

因为FJ的田地有树和其它障碍物，所以FJ设定机器人去犁很多不同的长方形。这些长方形允许重叠。他给机器人下了P个指令，每个指令包含一个要犁长方形的地。这片田地由长方形的左下角和右上角坐标决定。他很好奇最后到底有多少个方格的地被犁过了。

一般来说，田地被分割为很多小方格。这些方格的边和x轴或y轴平行。田地的宽度为X个方格，高度为Y个方格 (1 <= X <= 240; 1 <= Y <= 240). FJ执行了I (1 <= I <= 200)个指令，每个指令包含4个整数：Xll, Yll, Xur, Yur (1 

 = Xll <= Xur; Xll <= Xur
<=X; 1 <= Yll <= Yur; Yll <= Y r <= Y),
分别是要犁的长方形的左下角坐标和右上角坐标。机器人会犁所有的横坐标在Xll..Xur并且纵坐标在Yll..Yur范围内的所有方格的地。可能这个长方形会比你想象的多一行一列
就是说从第Xll列到第Xur列一共有Xur - Xll + 1列而不是Xur 
 Xll列）。


考虑一个6方格宽4方格高的田地。FJ进行了2个操作（如下），田地就被犁成"*"和"#"了。虽然一般被犁过的地看起来都是一样的。但是标成"#"可以更清晰地看出最近一次被犁的长方形。

一共14个方格的地被犁过了。
输入格式

* Line 1: Three space-separated integers: X, Y, and I

* Lines 2..I+1: Line i+1 contains plowing instruction i which is described by
four integers: Xll, Yll, Xur, and Yur 输出格式

* Line 1: A single integer that is the total number of squares plowed
输入输出样例
输入 #1

6 4 2
1 1 2 4
1 3 5 4

输出 #1

14

说明/提示

As in the task's example.

code:
int main(){
    int x,y,n,s=0;cin>>x>>y>>n;
    bool b[x+1][y+1]={0};
    for(int i=1;i<=n;i++){
        int x1,y1,x2,y2;
        cin>>x1>>y1>>x2>>y2;
        for(int j=x1;j<=x2;j++)
            for(int k=y1;k<=y2;k++)
                if(!b[j][k]){
                    s++;
                    b[j][k]=1;
                }
    }
    cout<<s;
}

*/

/*
P3150 pb的游戏（1）

题目背景

（原创）

有一天 pb和zs玩游戏 你需要帮zs求出每局的胜败情况
题目描述

游戏规则是这样的： 每次一个人可以对给出的数进行分割，
其割成两个非零自然数，之后由另一个人选择留下两个数中的其中一个；之后由另一个人进行分割这个剩下的数，重复步骤……

当一个人无法对数进行分割的时候游戏结束，另一个人获胜

现在要你求出N次游戏的胜败

每局由pb先进行分割，如果pb赢输出"pb wins" 如果zs赢输出"zs wins"

注：双方都是绝顶聪明的
输入格式

第一行一个数N，表示数据组数

之后N行，每行一个数M，表示每局初始的数
输出格式

共N行，每行一串字符 表示游戏结果
输入输出样例
输入 #1

5
1
3
7
20
5

输出 #1

zs wins
zs wins
zs wins
pb wins
zs wins

说明/提示

1<N<50 1<=m<=1000000000

code:
int main(){
    int n, x;
    cin >> n;
    while (n--){
        cin >> x;
        if (x %2 == 1) cout << "zs wins" << endl;
        else cout << "pb wins" << endl;
    }
}

*/

/*
P3156 【深基15.例1】询问学号

题目描述

有 n(n≤2×106)n(n \le 2 \times 10^6)n(n≤2×106) 名同学陆陆续续
入教室。我们知道每名同学的学号（在 1 到 10910^9109 之间），按进教室的顺序给出。上课了，老师想知道第 iii 个进入教室的
学的学号是什么（最先进入教室的同学 i=1i=
 i=1），询问次数不超过 10510^5105 次。


 输入格式

第一行 2 个整数 n 和 m，表示学生个数和询问次数。

第二行 n 个整数，表示按顺序进入教室的学号。

第三行 m 个整数，表示询问第几个进入教室的同学。
输出格式

m 个整数表示答案，用换行隔开。
输入输出样例
输入 #1

10 3
1 9 2 60 8 17 11 4 5 14
1 5 9

输出 #1

1
8
5

code:
int a[2000001];
int main(){
    int n,m,sum;
    scanf("%d %d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=m;i++){
        scanf("%d",&sum);
        printf("%d\n",a[sum]);
    }
}

*/

/*
P3717 [AHOI2017初中组]cover

题目背景

以下为不影响题意的简化版题目。
题目描述

一个 n×nn\times nn×n 的网格图（标号由 111 开始）上有 mmm 个探测器，每个探测器有个探测半径 rrr ，问这 n×nn\t
 mes nn×n 
点中有多少个点能被探测到。 输入格式

第一行 333 个整数 n,m,rn,m,rn,m,r ;

接下来 mmm 行，每行两个整数 x,yx,yx,y表示第 iii 个探测器的坐标。
输出格式

能被探测到的点的个数。
输入输出样例
输入 #1

5 2 1
3 3
4 2

输出 #1

8

说明/提示

1≤n,m≤1001\le n,m\le 1001≤n,m≤100

code:
int main(){
    int n,m,r,ans=0;
    cin>>n>>m>>r;
    bool a[n+1][n+1]={0};
    int x[m+1],y[m+1];
    for(int i1=1;i1<=m;i1++){
        cin>>x[i1]>>y[i1];
        for(int i=1;i<=n;i++)
            for(int j=1;j<=n;j++)
                if(sqrt((x[i1]-i)*(x[i1]-i)+(y[i1]-j)*(y[i1]-j))<=r)
                    if(!a[i][j]){
                        ans++;
                        a[i][j]=true;
                    }
    }
    cout<<ans;
    return 0;
}

*/

/*
P3741 honoka的键盘

题目背景

honoka 有一个只有两个键的键盘。
题目描述

一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有 VK 这个字符串的时候，honoka 就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串


 VK 出现的次数。给出原来的字符串，请计算她最多能使这个字符串内
现多少次 VK（只有当 V 和 K 正好相邻时，我们认为出现了 VK。）

 输入格式

第一行给出一个数字 nnn，代表字符串的长度。

第二行给出一个字符串 sss。
输出格式

第一行输出一个整数代表所求答案。
输入输出样例
输入 #1

2
VK

输出 #1

1

输入 #2

2
VV

输出 #2

1

输入 #3

1
V

输出 #3

0

输入 #4

20
VKKKKKKKKKVVVVVVVVVK

输出 #4

3

输入 #5

4
KVKV

输出 #5

1

说明/提示

对于 100%100\%100% 的数据，1≤n≤1001\le n\le 1001≤n≤100。

code:
char a[102];
int main(){
    gets(a);
    gets(a);
    int ans=0;
    for(int i=0;i<strlen(a);i++){
        if(a[i]=='V' && a[i+1]=='K'){
            ans++;
            a[i]='X';
            a[i+1]='X';
        }
    }
    for(int i=0;i<strlen(a);i++){
        if(a[i]!='X' && a[i]==a[i+1]){
            ans++;break;
        }
    }
    cout<<ans;
    return 0;
}

*/

/*
P3742 umi的函数

题目背景

umi 找到了一个神秘的函数 f。
题目描述

这个函数接受两个字符串 s1,s2。这些字符串只能由小写字母组成，
且具有相同的长度。这个函数的输出是另一个长度与 s1,s2 相同的字符串 g。g 的第 i 个字符等于 s1 的第i 个字符和 s2 的第 i 个字符的最小值，简单来说，g[i]=min(s1[i],s2[i])。





例如：f("ab","ba")= "aa", f("nzwzl","zizez")="niwel".

她现在有两个相同长度的只有小写字母的字符串 x,y。找出任何一个满足 f(x,z)=y 的

字符串 z。如果找不到这样的字符串的话，请输出-1。
输入格式

第一行给出以下两个字符串的长度 n。

第二行给出一个字符串 x。

第三行给出一个字符串 y。
输出格式

第一行输出一个字符串，代表你找到的符合条件的字符串。找不到的话，请输出-1。
输入输出样例
输入 #1

2
ab
aa

输出 #1

ba

输入 #2

5
nzwzl
niwel

输出 #2

xiyez

输入 #3

2
ab
ba

输出 #3

-1

说明/提示

对于 100%的数据，1<=n<=100。

code:
int main(){
    int n;cin>>n;
    string a,b;
    cin>>a>>b;
    for (int i=0;i<n;i++)
        if (a[i] < b[i]){
            cout<<-1<<endl;
            return 0;
        }
    cout<<b<<endl;
    return 0;
}

*/

/*
P3954 [NOIP2017 普及组] 成绩

题目描述

牛牛最近学习了C++入门课程，这门课程的总成绩计算方法是：

总成绩=作业成绩×20%+ \times 20\%+×20%+小测成绩×30%+×30\%+×30%+期末考试成绩×50% \times 50\%×50%



牛牛想知道，这门课程自己最终能得到多少分。
输入格式

三个非负整数A,B,CA,B,CA,B,C，分别表示牛牛的作业成绩、小测成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是100100100分。
输出格式

一个整数，即牛牛这门课程的总成绩，满分也是100100100分。
输入输出样例
输入 #1

100 100 80

输出 #1

90

输入 #2

60 90 80

输出 #2

79

说明/提示
输入输出样例1说明

牛牛的作业成绩是100100100分，小测成绩是100100100分，期末考试成绩是808080分，总成绩是100×20%+100×30%+80×50%=20+30+40=90100 \times 20\%+100 \times 30\%+80 \times 50\%=20+30+40=90100×20%+

00×30%+80×50%=20+30+40=90。
 输入输出样例2说明

牛牛的作业成绩是606060分，小测成绩是909090分，期末考试成绩是808080分，总成绩是60×20%+90×30%+80×50%=12+27+40=7960 \times 20\%+90 \times 30\%+80 \times 50\%=12+27+40=7960×20%+90

30%+80×50%=12+27+40=79。
 数据说明

对于30%30\%30%的数据，A=B=0A=B=0A=B=0。

对于另外30%30\%30%的数据，A=B=100A=B=100A=B=100。

对于100%100\%100%的数据，0≤A,B,C≤1000≤A,B,C≤1000≤A,B,C≤100且A,B,CA,B,CA,B,C都是101010的整数倍。

code:
int main(){
    int a,b,c;cin>>a>>b>>c;
    cout<<a*0.2+b*0.3+c*0.5;
    return 0;
}

*/

/*
P4325 [COCI2006-2007#1] Modulo

题目描述

Given two integers A and B, A modulo B is the remainder when dividing A by B.
For example, the numbers 7, 14, 27 and 38 become 1, 2, 0 and 2, modulo 3. Write
a program that accepts 10 numbers as input and outputs the number of distinct
numbers in the input, if the numbers are considered modulo 42. 输入格式

The input will contain 10 non-negative integers, each smaller than 1000, one per
line. 输出格式

Output the number of distinct values when considered modulo 42 on a single line.
题意翻译

描述

给出10个整数，问这些整数%42后有多少个不同的余数。 输入

输入包含10个小于1000的非负整数，每行一个。 输出

输出它们%42后，有多少个不同的余数。 说明

第一个样例的十个结果是1，2，3，4，5，6，7，8，9，10，有10个不同的结果；第二个样例结果都是0，只有一个不同的结果；第三个样例余数是39，40，41，0，1，2，40，41，0，1，有0，1，2，39，40，41这六个不同的结果。

感谢@ACdreamer 提供的翻译

注明：%42为除以42取余
输入输出样例
输入 #1

1
2
3
4
5
6
7
8
9
10

输出 #1

10

输入 #2

42
84
252
420
840
126
42
84
420
126

输出 #2

1

输入 #3

39
40
41
42
43
44
82
83
84
85

输出 #3

6

说明/提示

In the first example, the numbers modulo 42 are 1, 2, 3, 4, 5, 6, 7, 8, 9
and 10. In the second example all numbers modulo 42 are 0. In the third example,
the numbers modulo 42 are 39, 40, 41, 0, 1, 2, 40, 41, 0 and 1. There are 6
distinct numbers.

code:
int main(){
    int n=0;
    bool a[43]={0};
    for(int i=0;i<10;i++){
        long long x;cin>>x;
        if(!a[x%42]){
            a[x%42]=1;
            n++;
        }
    }
    cout<<n;
    return 0;
}

*/

/*
P4326 [COCI2006-2007#1] Herman

题目描述

The 19th century German mathematician Hermann Minkowski investigated a
non-Euclidian geometry, called the taxicab geometry. In taxicab geometry the
distance between two points T1(x1, y1) and T2(x2, y2) is defined as: D(T1,T2) =
|x1 - x2| + |y1 - y2| All other definitions are the same as in Euclidian
geometry, including that of a circle: A circle is the set of all points in a
plane at a fixed distance (the radius) from a fixed point (the centre of the
circle). We are interested in the difference of the areas of two circles with
radius R, one of which is in normal (Euclidian) geometry, and the other in
taxicab geometry. The burden of solving this difficult problem has fallen onto
you. 输入格式

The first and only line of input will contain the radius R, an integer smaller
than or equal to 10000. 输出格式

On the first line you should output the area of a circle with radius R in normal
(Euclidian) geometry. On the second line you should output the area of a circle
with radius R in taxicab geometry. Note: Outputs within ±0.0001 of the official 
olution will be accepted. 题意翻译

19世纪的德国数学家赫尔曼・闵可夫斯基(Hermann Minkowski)研究了一种名为出租车几何学的非欧几何。 在出

车几何里T1(x1,y1)T_1(x_1,y_1)T1?(x1?,y1?) T2(x2,y2)T_2(
_2,y_2)T2?(x2?,
2?)两点之间的距离被定义为dis(T1,T2)=Ox1?x2O+Oy1?y2Odis(T_1,T_2)=|x_1-x_
|+|y_1-y_2|dis(T1?,T2?)=Ox1??x2?O+Oy1??y2?O(曼哈顿距离)。 其他定义均与欧几里得几何相同。


例如圆的定义：在同一平面内，到定点(圆心)的距离等于定长(半径)的点的集合。

我们对欧几里得几何与出租车几何两种定义下半径为RRR的圆的面积很感兴趣。解决这个问题的重担就落在你身上了。
输入输出格式
输入格式

仅有一行为圆的半径RRR。 (R≤10000)(R \leq 10000)(R≤10000)
输出格式

第一行输出欧几里得几何下半径为RRR的圆的面积，第二行输出出租车几何下半径为RRR的圆的面积。

注意：你的输出与标准答案绝对误差不超过0.00010.00010.0001将会被认为正确
输入输出样例
输入 #1

1

输出 #1

3.141593
2.000000

输入 #2

21

输出 #2

1385.442360
882.000000

输入 #3

42

输出 #3

5541.769441
3528.000000

code:
int main(){
    double n,pi=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275900994657640789512694683983525957098258226205224894077267194782684826014769909026401363944374553050682034962524517493996514314298091906592509372216964615157098583874105978859597729754989301617539284681382686838689427741559918559252459539594310499725246808459872736446958486538367362226260991246080512438843904512441365497627807977156914359977001296160894416948685558484063534220722258284886481584560285060168427394522674676788952521385225499546667278239864565961163548862305774564980355936345681743241125150760694794510965960940252288797108931456691368672287489405601015033086179286809208747609178249385890097149096759852613655497818931297848216829989487226588048575640142704775551323796414515237462343645428584447952658678210511413547357395231134271661021359695362314429524849371871101457654035902799344037420073105785390621983874478084784896833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080951465502252316038819301420937621378559566389377870830390697920773467221825625996615014215030680384477345492026054146659252014974428507325186660021324340881907104863317346496514539057962685610055081066587969981635747363840525714591028970641401109712062804390397595156771577004203378699360072305587631763594218731251471205329281918261861258673215791984148488291644706095752706957220917567116722910981690915280173506712748583222871835209353965725121083579151369882091444210067510334671103141267111369908658516398315019701651511685171437657618351556508849099898599823873455283316355076479185358932261854896321329330898570642046752590709154814165498594616371802709819943099244889575712828905923233260972997120844335732654893823911932597463667305836041428138830320382490375898524374417029132765618093773444030707469211201913020330380197621101100449293215160842444859637669838952286847831235526582131449576857262433441893039686426243410773226978028073189154411010446823252716201052652272111660396665573092547110557853763466820653109896526918620564769312570586356620185581007293606598764861179104533488503461136576867532494416680396265797877185560845529654126654085306143444318586769751456614068007002378776591344017127494704205622305389945613140711270004078547332699390814546646458807972708266830634328587856983052358089330657574067954571637752542021149557615814002501262285941302164715509792592309907965473761255176567513575178296664547791745011299614890304639947132962107340437518957359614589019389713111790429782856475032031986915140287080859904801094121472213179476477726224142548545403321571853061422881375850430633217518297986622371721591607716692547487389866549494501146540628433663937900397692656721463853067360965712091807638327166416274888800786925602902284721040317211860820419000422966171196377921337575114959501566049631862947265473642523081770367515906735023507283540567040386743513622224771589150495309844489333096340878076932599397805419341447377441842631298608099888687413260472156951623965864573021631598193195167353812974167729478672422924654366800980676928238280689964004824354037014163149658979409243237896907069779422362508221688957383798623001593776471651228935786015881617557829735233446042815126272037343146531977774160319906655418763979293344195215413418994854447345673831624993419131814809277771038638773431772075456545322077709212019051660962804909263601975988281613323166636528619326686336062735676303544776280350450777235547105859548702790814356240145171806246436267945612753181340783303362542327839449753824372058353114771199260638133467768796959703098339130771098704085913374641442822772634659470474587847787201927715280731767907707157213444730605700733492436931138350493163128404251219256517980694113528013147013047816437885185290928545201165839341965621349143415956258658655705526904965209858033850722426482939728584783163057777560688876446248246857926039535277348030480290058760758251047470916439613626760449256274204208320856611906254543372131535958450687724602901618766795240616342522577195429162991930645537799140373404328752628889639958794757291746426357455254079091451357111369410911939325191076020825202618798531887705842972591677813149699009019211697173727847684726860849003377024242916513005005168323364350389517029893922334517220138128069650117844087451960121228599371623130171144484640903890644954440061986907548516026327505298349187407866808818338510228334508504860825039302133219715518430635455007668282949304137765527939751754613953984683393638304746119966538581538420568533862186725233402830871123282789212507712629463229563989898935821167456270102183564622013496715188190973038119800497340723961036854066431939509790190699639552453005450580685501956730229219139339185680344903982059551002263535361920419947455385938102343955449597783779023742161727111723643435439478221818528624085140066604433258885698670543154706965747458550332323342107301545940516553790686627333799585115625784322988273723198987571415957811196358330059408730681216028764962867446047746491599505497374256269010490377819868359381465741268049256487985561453723478673303904688383436346553794986419270563872931748723320837601123029911367938627089438799362016295154133714248928307220126901475466847653576164773794675200490757155527819653621323926406160136358155907422020203187277605277219005561484255518792530343513984425322341576233610642506390497500865627109535919465897514131034822769306247435363256916078154781811528436679570611086153315044521274739245449454236828860613408414863776700961207151249140430272538607648236341433462351897576645216413767969031495019108575984423919862916421939949072362346468441173940326591840443780513338945257423995082965912285085558215725031071257012668302402929525220118726767562204154205161841634847565169998116141010029960783869092916030288400269104140792886215078424516709087000699282120660418371806535567252532567532861291042487761825829765157959847035622262934860034158722980534989650226291748788202734209222245339856264766914905562842503912757710284027998066365825488926488025456610172967026640765590429099456815065265305371829412703369313785178609040708667114965583434347693385781711386455873678123014587687126603489139095620099393610310291616152881384379099042317473363948045759314931405297634757481193567091101377517210080315590248530906692037671922033229094334676851422144773793937517034436619910403375111735471918550464490263655128162288244625759163330391072253837421821408835086573917715096828874782656995995744906617583441375223970968340800535598491754173818839994469748676265516582765848358845314277568790029095170283529716344562129640435231176006651012412006597558512761785838292041974844236080071930457618932349229279650198751872127267507981255470958904556357921221033346697499235630254947802490114195212382815309114079073860251522742995818072471625916685451333123948049470791191532673430282441860414263639548000448002670496248201792896476697583183271314251702969234889627668440323260927524960357996469256504936818360900323809293459588970695365349406034021665443755890045632882250545255640564482465151875471196218443965825337543885690941130315095261793780029741207665147939425902989695946995565761218656196733786236256125216320862869222103274889218654364802296780705765615144632046927906821207388377814233562823608963208068222468012248261177185896381409183903673672220888321513755600372798394004152970028783076670944474560134556417254370906979396122571429894671543578468788614445812314593571984922528471605049221242470141214780573455105008019086996033027634787081081754501193071412233908663938339529425786905076431006383519834389341596131854347546495569781038293097164651438407007073604112373599843452251610507027056235266012764848308407611830130527932054274628654036036745328651057065874882256981579367897669742205750596834408697350201410206723585020072452256326513410559240190274216248439140359989535394590944070469120914093870012645600162374288021092764579310657922955249887275846101264836999892256959688159205600101655256375678566722796619885782794848855834397518744545512965634434803966420557982936804352202770984294232533022576341807039476994159791594530069752148293366555661567873640053666564165473217043903521329543529169414599041608753201868379370234888689479151071637852902345292440773659495630510074210871426134974595615138498713757047101787957310422969066670214498637464595280824369445789772330048764765241339075920434019634039114732023380715095222010682563427471646024335440051521266932493419673977041595683753555166730273900749729736354964533288869844061196496162773449518273695588220757355176651589855190986665393549481068873206859907540792342402300925900701731960362254756478940647548346647760411463233905651343306844953979070903023460461470961696886885014083470405460742958699138296682468185710318879065287036650832431974404771855678934823089431068287027228097362480939962706074726455399253994428081137369433887294063079261595995462624629707062594845569034711972996409089418059534393251236235508134949004364278527138315912568989295196427287573946914272534366941532361004537304881985517065941217352462589548730167600298865925786628561249665523533829428785425340483083307016537228563559152534784459818313411290019992598135220511733658564078264849427644113763938669248031183644536985891754426473998822846218449008777697763127957226726555625962825427653183001340709223343657791601280931794017185985999338492354956400570995585611349802524990669842330173503580440811685526531170995708994273287092584878944364600504108922669178352587078595129834417295351953788553457374260859029081765155780390594640873506123226112009373108048548526357228257682034160504846627750450031262008007998049254853469414697751649327095049346393824322271885159740547021482897111777923761225788734771881968254629812686858170507402725502633290449762778944236216741191862694396506715157795867564823993917604260176338704549901761436412046921823707648878341968968611815581587360629386038101712158552726683008238340465647588040513808016336388742163714064354955618689641122821407533026551004241048967835285882902436709048871181909094945331442182876618103100735477054981596807720094746961343609286148494178501718077930681085469000944589952794243981392135055864221964834915126390128038320010977386806628779239718014613432445726400973742570073592100315415089367930081699805365202760072774967458400283624053460372634165542590276018348403068113818551059797056640075094260878857357960373245141467867036880988060971642584975951380693094494015154222219432913021739125383559150310033303251117491569691745027149433151558854039221640972291011290355218157628232831823425483261119128009282525619020526301639114772473314857391077758744253876117465786711694147764214411112635835538713610110232679877564102468240322648346417663698066378576813492045302240819727856471983963087815432211669122464159117767322532643356861461865452226812688726844596844241610785401676814208088502800541436131462308210259417375623899420757136275167457318918945628352570441335437585753426986994725470316566139919996826282472706413362221789239031760854289437339356188916512504244040089527198378738648058472689546243882343751788520143956005710481949884239060613695734231559079670346149143447886360410318235073650277859089757827273130504889398900992391350337325085598265586708924261242947367019390772713070686917092646254842324074855036608013604668951184009366860954632500214585293095000090715105823626729326453738210493872499669933942468551648326113414611068026744663733437534076429402668297386522093570162638464852851490362932019919968828517183953669134522244470804592396602817156551565666111359823112250628905854914509715755390024393153519090210711945730024388017661503527086260253788179751947806101371500448991721002220133501310601639154158957803711779277522597874289191791552241718958536168059474123419339842021874564925644346239253195313510331147639491199507285843065836193536932969928983791494193940608572486396883690326556436421664425760791471086998431573374964883529276932822076294728238153740996154559879825989109371712621828302584811238901196822142945766758071865380650648702613389282299497257453033283896381843944770779402284359883410035838542389735424395647555684095224844554139239410001620769363684677641301781965937997155746854194633489374843912974239143365936041003523437770658886778113949861647874714079326385873862473288964564359877466763847946650407411182565837887845485814896296127399841344272608606187245545236064315371011274680977870446409475828034876975894832824123929296058294861919667091895808983320121031843034012849511620353428014412761728583024355983003204202451207287253558119584014918096925339507577840006746552603144616705082768277222353419110263416315714740612385042584598841990761128725805911393568960143166828317632356732541707342081733223046298799280490851409479036887868789493054695570307261900950207643349335910602454508645362893545686295853131533718386826561786227363716975774183023986006591481616404944965011732131389574706208847480236537103115089842799275;
    cin>>n;
    printf("%.6lf\n%.6lf\n",n*n*pi,n*n*2.0);
    return 0;
}

*/

/*
P4327 [COCI2006-2007#1] Okviri

题目描述

“Peter Pan frames” are a way of decorating text in which every character is fra
ed by a diamond shaped frame, with frames of neigbhouring characters int
rleaving. A Peter Pan frame for one letter looks like this ('X' is the let
er we are framing):

..#..
.#.#.
#.X.#
.#.#.
..#..

However, such a framing would be somewhat dull so we'll frame every third letter
using a “Wendyframe”. A Wendy frame looks like this:

..*..
.*.*.
*.X.*
.*.*.
..*..

When a Wendy frame interleaves with a Peter Pan frame, the Wendy frame (being
much nicer) is put on top. For an example of the interleaving check the sample
cases. 输入格式

The first and only line of input will contain at most 15 capital letters of the
English alphabet. 输出格式

Output the word written using Peter Pan and Wendy frames on 5 lines.
题意翻译

“彼得・潘框架”是一种装饰文字，每一个字母都是由一个菱形框架。一个彼得・潘框架看起来像这样 （x是字母，#是框架）：




..#..
.#.#.
#.X.#
.#.#.
..#..

然而，只是一个框架会有些沉闷，所以我们每遇到三个字母会把第三个字母用温迪框架把它框起来。温迪框架看起来像这样：

..*..
.*.*.
*.X.*
.*.*.
..*..

当温迪和彼得・潘的框架重叠时，温迪框架覆盖在上面。 （见样例3和4）

输入格式： 一行包含至多15个英文字母的大写字母。

输出格式： 输出使用彼得・潘和温迪框架写成的5行文字。
输入输出样例
输入 #1

A

输出 #1

..#..
.#.#.
#.A.#
.#.#.
..#..

输入 #2

DOG

输出 #2

..#...#...*..
.#.#.#.#.*.*.
#.D.#.O.*.G.*
.#.#.#.#.*.*.
..#...#...*..

输入 #3

ABCD

输出 #3

..#...#...*...#..
.#.#.#.#.*.*.#.#.
#.A.#.B.*.C.*.D.#
.#.#.#.#.*.*.#.#.
..#...#...*...#..

code:
char a[6][62];
string s;
void frame(char c,int y,int x){
    a[3][y]=c;
    a[1][y]=a[2][y+1]=a[3][y+2]=a[4][y+1]=a[5][y]=a[4][y-1]=a[3][y-2]=a[2][y-1]=(x?'#':'*');
}
int main(){
    memset(a,'.',sizeof(a));
    cin>>s;
    for(int i=0;i<s.size();i++){
        if(i%3==2)continue;
        frame(s[i],4*i+3,1);
    }
    for(int i=2;i<s.size();i+=3)frame(s[i],4*i+3,0);
    for(int i=1;i<6;i++){
    for(int j=1;j<4*s.size()+2;j++)cout<<a[i][j];
        cout<<endl;
    }
    return 0;
}

*/

/*
P4413 [COCI2006-2007#2] R2

题目描述

The number S is called the mean of two numbers R1 and R2 if S is equal to
(R1+R2)/2. Mirko's birthday present for Slavko was two integers R1 and R2.
Slavko promptly calculated their mean which also happened to be an integer but
then lost R2! Help Slavko restore R2. 输入格式

The first and only line of input contains two integers R1 and S, both between
-1000 and 1000. 输出格式

Output R2 on a single line.
题意翻译

设S=(R1+R2)/2，给定R1与S (?1000<=R
,S<=1000)(-1000<=R1,S<=1000)(?1000<=R1,S<=1000)，求R2。

感谢@Xeonacid 提供的翻译
输入输出样例
输入 #1

11 15

输出 #1

19

输入 #2

4 3

输出 #2

2

code:
int main(){
    int r,s;
    in>>r>>s;
    cout<<2*s-r;
    return 0;
}

*/

/*
P4414 [COCI2006-2007#2] ABC

题目描述

You will be given three integers A, B and C. The numbers will not be given in
that exact order, but we do know that A is less than B and B less than C. In
order to make for a more pleasant viewing, we want to rearrange them in the
given order. 输入格式

The first line contains three positive integers A, B and C, not necessarily in
that order. All three numbers will be less than or equal to 100. The second line
contains three uppercase letters 'A', 'B' and 'C' (with no spaces between them)
representing the desired order. 输出格式

Output the A, B and C in the desired order on a single line, separated by single
spaces. 题意翻译

【题目描述】

三个整数分别为 A,B,CA,B,CA,B,C . 这三个数字不会按照这样的顺
给你，但它们始终满足条件： A＜B＜CA＜B＜CA＜B＜C . 为了看起来更加简洁明了，我们希望你可以按照给定的顺序重新排列它们。



【输入格式】

第一行包含三个正整数 A,B,CA,B,CA,B,C ，不一定是按这个顺序。这三个数字都小于
等于 100100100 。第二行包含三个大写字母 AAA 、 BBB 和 CCC （它们之间没有空格）表示所需的顺序.



【输出格式】

在一行中输出 AAA ，BBB 和 CCC ，用一个 （空格）隔开.

感谢@smartzzh 提供的翻译
输入输出样例
输入 #1

1 5 3
ABC

输出 #1

1 3 5

输入 #2

6 4 2
CAB

输出 #2

6 2 4

code:
int main(){
    int a[3];
    for(int i=0;i<3;i++)cin>>a[i];
    sort(a,a+3);
    string c;cin>>c;
    for(int i=0;i<3;i++)cout<<a[(c[i]-'A')]<<" ";
    return 0;
}

*/

/*
P4439 [COCI2017-2018#3] Aron

题目描述

The holiday season is near! Aron wants to get gifts for his friends in Zagreb,
so in order to get them on time, he visited a famous toy store in London. After
picking out the gifts, he went to the register and discovered that there were
already N people in line. Luckily, he noticed that there were groups of people
standing in line, in addition to individual customers. A group of people
consists of a customer and their friends waiting for them to complete the
purchase. The moment when the customer is done, they and their friends leave the
line.

The people considered a group are standing one behind the other and are wearing
shirts of matching colour. Two adjacent groups, adjacent individuals or adjacent
individual and a group, will never be wearing shirts of the same colour.

Write a program that will, given the data on the people standing in line, output
which person in line Aron is. 输入格式

The first line of input contains the positive integer N (1 ≤ N ≤ 25) from the tas
 . Each of the following N lines contains a single character, an uppercase
let er of the English alphabet that represents the shirt colour of the ith
^{th}ith person in line. 输出格式

You must output the required number from the task.
题意翻译

Aron给他的朋友们买礼物后在礼物店排队，它的前面有n个人，但是它发现有些人实在等待他的朋友而并非在排队买单，并且我们可以认为站在一个人后面的朋友都穿着匹配颜色的衬衫，而两个相邻的群体、相邻的个人或相邻的个人和一个集体将永远不会穿着相同颜色的衬衫。

编写一个程序，给定排队的人所穿的衣服的颜色，输出Aron在第多少位？
输入输出样例
输入 #1

3
C
Z
P

输出 #1

4

输入 #2

6
C
C
P
C
Z
Z

输出 #2

5

输入 #3

6
B
B
B
B
B
B

输出 #3

2

说明/提示

Clarification? ?of? ?the? ?second? ?test? ?case:

First in line is the group consisting of two people in red shirts. Second in
line is an individual in the blue shirt, third in line is an individual in the
red shirt, and fourth in line is a group in green shirts. This makes Aron fifth
in line.

code:
int main(){
    int n,ans=0;char m,p;
    cin>>n>>m;
    ans++;
    for(int i=0;i<n-1;i++){
        cin>>p;
        if(p!=m){
            m=p;
            ans++;
        }
    }
    cout<<ans+1;
    return 0;
}

*/

/*
P4445 [AHOI2018初中组]报名签到

题目描述

nnn 位同学（编号从 111 到 nnn）同时来到体育馆报名签到
领取准考证和参赛资料。为了有序报名，这 nnn 位同学需要按编号次序（编号为 111 的同学站在最前面）从前往后排成一条直线。然而每一位同学都不喜欢拥挤，对于第 iii 位同学，如果有另外一位同学距离他/她

 距离小于 aia_iai
，那么就会发生冲突。小可可想知道如果要不发生任何冲突的情况下，这 
nn 位同学排队的队列最短长度是多少。


 输入格式

第一行一个整数 nnn ，表示报名签到的同学人数。

第二行有 nnn 个整数，第 iii 个整数 aia_iai? 表示第 iii 个同学必须与其他同学保持的距离。
 输出格式

输出一行，包括一个整数，表示这 nnn 位同学排队队列的最小长度。

注意： nnn 位同学要按 111 到 nnn 的次序从前往后排队。
输入输出样例
输入 #1

3
3 1 2

输出 #1

5

说明/提示

对于 20%20\%20% 的数据满足：1≤n≤201\le n\le 201≤n≤20。

对于 70%70\%70% 的数据满足：1≤n≤1041\le n\le 10^41≤n≤104。

对于 100%100\%100% 的数据满足：1≤n≤1051\le n\le 10^51≤n≤105，1≤ai≤1051\le a_i\le 10^51≤ai?≤105。


code:
int main(){
    long long n,ans=0;cin>>n;
    long long a[n];
    cin>>a[0];
    for(int i=1;i<n;i++){
        cin>>a[i];
        if(a[i]>a[i-1])ans+=a[i];
        else ans+=a[i-1];
    }
    cout<<ans;
    return 0;
}

*/

/*
P4613 [COCI2017-2018#5] Olivander

题目描述

Harry Potter has damaged his magic wand in a fight with Lord Voldemort. He has
decided to get a new wand in Olivander's wand shop. On the floor of the shop, he
saw ?N wands and ?N wand boxes. The lengths of the wands are, respectively, X1X
 1X1? ,X2X_2X2? ...?XnX_nXn? , and the box sizes are Y1Y_1Y1? ,?Y2Y_2Y2
 .. YnY_nYn? . A wand of length ?X can be placed in a box of siz
 ?Y if ?X ≤ ?Y .  arry wants to know if he can place all the wands in
boxes so that each box contai s exactly one wand. Help him solve this difficult
problem. 输入格式

The first line of input contains the positive integer ?N (1 ≤ ?N ≤ 100), the number 
 rom the task. The second line contains ?N positive integers ?
iX_iXi?
(1 ≤ ?XiX_iXi? ≤ 10910^9109? ), the numbers from the task. The third line contains

?N positive integers ?XiX_iXi? (1 ≤ XiX_iXi? ≤ 10910^9109?? ), the numbers from th
 task. 输出格式

If Harry can place all the wands in boxes, output “DA” (Croatian for yes), oth
rwise output “NE” (Croatian for no). 题意翻译 题意简述

有 nnn 个棍子和 nnn 个盒子，要求每个盒
里放的棍子的总长度不能超过盒子的高度。求是否有方案使得各个棍子都能放到任意一个盒子里。是输出 DA，否则输出 NE。（一个盒子里只能放一根棍子）
 输入

输入共三行。

第一行，一个整数 nnn。

第二行， nnn 个整数 X1,X2,X3,…,Xn
_1,X_2,X_3,\dots,X_nX1?,X2?,X3?,…,Xn?。其中第 iii个数 XiX_iXi?表示第 iii根棍子的长度。



第三行， nnn个整数 Y1,Y2,Y3,…,Yn
_1,Y_2,Y_3,\dots,Y_nY1?,Y2?,Y3?,…,Yn?。其中第 iii 个数 YiY_iYi? 表示第 iii 个盒子的高度。
 输出

输出仅一行。即如果有能够将各个棍子都能放进任一盒子的方案输出 DA，否则输出 NE（输出不包括引号）。
 样例解释

样例 111：哈利波特能够将所有棍子放进盒子里面。例如 X1?Y3,X2?Y2,X3?Y1X_1\Rightarrow Y_3,X_2\Right
 rrow Y_2,X_3\Rightarrow
Y_1X1??Y3?,X2??Y2?,X3??Y1?。


样例 222：哈利波特不能够将所有棍子放进盒子里。 因为 Y2=2Y_2=2Y2?=2，不能塞下任何一根棍子。
 数据范围

对于 60%60\%60% 的数据，保证 n?9n\leqslant9n?9。

对于 100%100\%100% 的数据，保证 n?100n\leqslant100n?100，并且 ?i\forall i?i，都满足 Xi,Yi?109X_i,Y_i\le
 slant10^9Xi?,Yi??109。 输入输出样例 输入 #1


3
7 9 5
6 13 10

输出 #1

DA

输入 #2

4
5 3 3 5
10 2 10 10

输出 #2

NE

输入 #3

4
5 2 3 2
3 8 3 3

输出 #3

DA

说明/提示

In test cases worth 60% of total points, it will hold ?N ≤ 9.

Clarification of the first test case:

Harry can place the wands in boxes. For example, he can place the wand of length
5 in a box of size 6, wand of length 7 in a box of size 13, and wand of length 9
in a box of size 10.

Clarification of the second test case:

Harry can’t place the wands in boxes because the box of size 2 can’t fit any of the
 wands.

code:
int main(){
    int n;cin>>n;
    bool t=0;
    int a[n]={0},b[n]={0};
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<n;i++)cin>>b[i];
    sort(a,a+n);
    sort(b,b+n);
    for(int i=0;i<n;i++){
        if(a[i]>b[i])t=1;
    }
    if(t==1)cout<<"NE";
    else cout<<"DA";
    return 0;
}

*/

/*
P4702 取石子

题目描述

Alice 和 Bob 在玩游戏。

他们有 nnn 堆石子，第 iii 堆石子有 aia_iai? 个，保证初始时 ai≤ai+1(1≤i<n)a_i \leq a_{i + 1}(1 \leq i < n)ai?≤ai+1?(1≤i<n

。现在他们轮流对这些石子进行操作，每次操作人可以选
满足 ai>ai?1a_i > a_{i - 1}ai?>ai?1?（a0a_0a0? 视为 000）的一堆石子，并从中取走一个。谁
后不能取了谁输。Alice 先手，他们都使用最优策略，请判断最后谁会取得胜利。



 输入格式

第一行一个整数 n(1≤n≤100)n(1 \leq n \leq 100)n(1≤n≤100)，表示石子堆数。

接下来一行 nnn 个数，第 iii 个数为 ai(1≤ai≤109)a_i(1 \leq a_i \leq 10^9)ai?(1≤ai?≤109)，意义如上所述。
 输出格式

"Alice" 或 "Bob"，表示谁会赢。
输入输出样例
输入 #1

1
1

输出 #1

Alice

输入 #2

1
2

输出 #2

Bob

code:
int main(){
    int k,num=0;cin>>k;
    int n[k];
    for(int i=0;i<k;i++){
        cin>>n[i];
        num=num+n[i]%2;
    }
    if(num%2==1)cout<<"Alice"<<endl;
    else cout<<"Bob";
}

*/

/*
P4956 [COCI2017-2018#6] Davor

题目描述

After successfully conquering the South Pole, Davor is preparing for new
challenges. Next up is the Arctic expedition to Siberia, Greenland and Norway.
He begins his travels on 31 December 2018, and needs to collect ?N kunas (
roatian currency) by then. In order to do this, he has decided to put away ?
 (?X ≤ 100) kunas every Monday to his travel fund, ?X + K kunas every Tuesd
y,  X + 2* ?K every Wednesday, and so on until Sunday, when he will put a
ay ?X + 6* ?K kunas. This way, he will collect money for 52 weeks, s
arting with 1 J nuary 2018 (Monday) until 30 December 2018 (Sunday).

If we know the amount of money ?N?, output the values ?X and ?K so that it is p
 ssible to collect the ?exact money amount in the given timespan. The s
lution  ill always exist, and if there are multiple, output the one with the
greatest X ? and smallest ?K ?. 输入格式

The first line of input contains the integer ?N? (1456 ≤ ?N? ≤ 145600), the number 
 rom the task. 输出格式

The first line of output must contain the value of ?X (?0 < ?X ?≤ 100 ?)?, and 
 he second the value of K (K ?> 0 ?)?. 题意翻译

在征服南极之后，Davor 开始了一项新的挑战。下一步是在
伯利亚、格林兰、挪威的北极圈远征。他将在 201820182018 年 121212 月 313131 日开始出发，在这之前需要一共筹集 nnn 元钱。他打算在每个星期一筹集 xxx 元，星
二筹集 x+kx+kx+
 元，……，星期日筹集 x+6kx+6kx+6k 元，并在 525252 个星期内筹集完。其中 x,kx,kx,k 为正整数，并
满足 1≤x≤1001 \le x \le  001≤x≤100。



现在请你帮忙计算 x,kx,kx,k 为多少时，能刚好筹集 nnn 元。

如果有多个答案，输出 xxx 尽可能大，kkk 尽可能小的。注意 kkk 必须大于 000。
输入输出样例
输入 #1

1456

输出 #1

1
1

输入 #2

6188

输出 #2

14
1

输入 #3

40404

输出 #3

99
4

code:
int main(){
    int n;
    cin>>n;
    for (int k = 1;; ++k)
        for (int x = 100; x > 0; --x)
            if ((7 * x + 21 * k) * 52 == n){
                cout<<x<<endl<<k;
                return 0;
            }
}

*/

/*
P5015 [NOIP2018 普及组] 标题统计

题目描述

凯凯刚写了一篇美妙的作文，请问这篇作文的标题中有多少个字符？ 注意：标题中可能包含大、小写英文字母、数字字符、空格和换行符。统计标题字 符数时，空格和换行符不计算在内。



 输入格式

输入文件只有一行，一个字符串 sss。
输出格式

输出文件只有一行，包含一个整数，即作文标题的字符数（不含空格和换行符）。
输入输出样例
输入 #1

234

输出 #1

3

输入 #2

Ca 45

输出 #2

4

说明/提示

【输入输出样例 1 说明】
标题中共有 3 个字符，这 3 个字符都是数字字符。

【输入输出样例 2 说明】 标题中共有5 55 个字符，包括 111 个大写英文字母， 111 个小写英文字母和 222 个数字字符， 还有 111 个空格。由于空格不计入结果中，故标题的有效字符数为 444 

 。


【数据规模与约定】
规定 OsO|s|OsO 表示字符串 sss 的长度（即字符串中的字符和空格数）。
对于 40%40\%40% 的数据，1≤OsO≤51 ≤ |s| ≤ 51≤OsO≤5，保证输入为数字字符及行末换行
。 对于 80%80\%80% 的数据，1≤OsO≤51 ≤ |s| ≤ 51≤OsO≤5，输入只可能包
大、小写英文字母、数字字符及行末换行符。 对于 100
100\%100% 的数据，1≤OsO≤51 ≤ |s| ≤ 51≤OsO≤5，输入可能包含大、小写英文字母
数字字符、空格和行末换行符。

code:
int main(){
    char s[10];
    gets(s);
    int ans=0;
    for(int i=0;i<strlen(s);i++){
        if(s[i]>='A'&&s[i]<='Z')ans++;
        if(s[i]>='a'&&s[i]<='z')ans++;
        if(s[i]>='0'&&s[i]<='9')ans++;
    }
    cout<<ans;
    return 0;
}

*/

/*
P5082 成绩

题目背景

小奔的score

题解：https://blog.csdn.net/kkkksc03/article/details/84928268

说一句：本题已放开空间范围（不过真的貌似不用开数组就可以A呀
题目描述

小奔的期末考试结束了。

他的成绩不久之后就会发下来。

给出一个考试成绩表格，例如：
科目/分值种类 	语文 	数学 	英语
满分 	100100100 	120120120 	150150150
实际得分 	999999 	737373 	100100100

当然。学校的老师认为如果录入如此多的成绩不好算分，于是他想要你的综合成绩评定

综合成绩评定指：(每一科的满分之和*3-每一科的实际得分之和*2)÷每科所扣除分数的和。

小奔想请你给出他的综合成绩，你能做到吗？
输入格式

第一行给出一个整数nnn，表示科目的总数。 第二行nnn个整数aia_iai?,表示第iii门课程的满分。 第三行

nn个整数bib_ibi?,表示第iii门课程小奔的实际得分。

输出格式

一行一个数，表示他的综合成绩。结果保留666位小数
输入输出样例
输入 #1

3
10 10 10
5 5 5

输出 #1

4.000000

说明/提示

对于202020%的数据，数据为样例

对于100100100%的数据，n<=1e7n<=1e7n<=1e7

code:
int main(){
    int n,a;cin>>n;
    double aa=0,bb=0;
    for(int i=0;i<n;i++){scanf("%d",&a);aa=aa+a;}
    bb=aa;
    for(int i=0;i<n;i++){scanf("%d",&a);bb=bb-a;}
    cout<<fixed<<setprecision(6)<<aa/bb+2;
    return 0;
}

*/

/*
P5534 【XR-3】等差数列

题目描述

小 X 给了你一个等差数列的前两项以及项数，请你求出这个等差数列各项之和。

等差数列：对于一个 nnn 项数列 aaa，如果满足对于任意 i∈[1,n)i \in [1,n)i∈[1,n)，有 ai+1?ai=da_{i+1} - a_i = dai
 1??ai?=d，其中 ddd 为定值，则称这个数列为
个等差数列。 输入格式

一行 333 个整数 a1,a2,na_1, a_2, na1?,a2?,n，表示等差数列的第 1,21,21,2 项以及项数。



数据范围：

    Oa1O,Oa2O≤106|a_1|,|a_2| \le 10^6Oa1?O,Oa2?O≤106。
    3≤n≤1063 \le n \le 10^63≤n≤106。

输出格式

一行一个整数，表示答案。
输入输出样例
输入 #1

1 2 3

输出 #1

6

输入 #2

-5 -10 5

输出 #2

-75

说明/提示

【样例 111 说明】

这个等差数列为 1 2 3，其各项之和为 666。

code:
int main(){
    long long  a,b,n;
    cin>>a>>b>>n;
    cout<<(a+(n-1)*(b-a)+a)*n/2;
    return 0;
}

*/

/*
P5594 【XR-4】模拟赛

题目描述

X 校正在进行 CSP 前的校内集训。

一共有 nnn 名 OIer 参与这次集训，教练为他们精心准备了 mmm 套模拟赛题。

然而，每名 OIer 都有各自的时间安排，巧合的是，他们在接下来的 kkk 天中都恰好有 mmm 天有空打模拟赛。



为了方便管理，教练规定一个人必须按顺序打完 mmm 套模拟赛题。

比如，小 X 在接下来的第 2,3,52,3,52,3,5 天有空打模拟赛，那么他就必须在第 222 天打第 111 套模拟赛题，第 333 天打第 222 套模拟赛题，第 555 天打第 333 套模拟

题。


教练需要为每一个人的每一次模拟赛做准备，为了减小工作量，如果在某一天有多个人打同一套模拟赛题，那么教练只需要在这一天准备一场使用这一套题的模拟赛即可。

你作为机房大佬，教练想请你帮他计算一下，他每天需要准备多少场模拟赛。
输入格式

第一行三个整数 n,m,kn,m,kn,m,k。

接下来 nnn 行，每行 mmm 个整数，第 iii 行第 jjj 列的整数 ai,ja_{i,j}ai,j? 表示第 iii 个人在接下来的 kkk 天中第 jjj 个有空的日子为第 
 i,ja_{i,j}ai,j? 天
 输出格式

一行 kkk 个整数，第 iii 个整数表示接下来的第 iii 天教练需要准备的模拟赛场数。
输入输出样例
输入 #1

1 3 5
2 3 5

输出 #1

0 1 1 0 1

输入 #2

6 3 7
2 3 4
2 5 7
3 5 7
1 3 5
5 6 7
1 2 3

输出 #2

1 2 3 1 3 1 1

输入 #3

10 10 20
2 3 4 8 9 11 12 16 17 18
2 3 6 10 12 13 14 15 19 20
1 3 7 10 11 13 14 15 17 19
1 2 4 6 7 9 15 17 19 20
2 3 5 6 9 11 14 16 19 20
1 2 3 8 9 10 11 12 15 19
1 4 6 7 9 12 13 17 18 19
1 7 8 9 10 11 13 15 18 20
1 5 6 7 8 9 13 16 18 19
4 5 7 10 11 13 14 17 18 20

输出 #3

1 2 2 3 2 2 4 3 3 3 3 4 2 1 3 1 2 2 2 1

说明/提示

本题采用捆绑测试。

    Subtask 1（13 points）：n=m=k=1n = m = k = 1n=m=k=1。
    Subtask 2（24 points）：n=1n = 1n=1。
    Subtask 3（24 points）：m=1m = 1m=1。
    Subtask 4（39 points）：无特殊限制。

对于 100%100\%100% 的数据，1≤n,m,k≤1031 \le n,m,k \le 10^31≤n,m,k≤103，m≤km \le km≤k，1≤ai,1<ai,2<?<ai,m
 k1 \le a_{i,1} < a_{i,2} < \cdots < a_{i,m} \le
k1≤ai,1?<ai,2?<?<ai,m?≤k。

code:
int main(){
    int ans,n,m,k;//人 次 天
    cin>>n>>m>>k;
    bool a[k+1][m+1];
    memset(a,0,sizeof(a));
    for(int i=0;i<n;i++){
        for(int j=1;j<=m;j++){
            int x;
            cin>>x;
            a[x][j]=1;
        }
    }
    for(int i=1;i<=k;i++){
        ans=0;
        for(int j=1;j<=m;j++)
            if(a[i][j]) ans++;
        cout<<ans<<" ";
    }
    return 0;
}

*/

/*
P5601 小D与笔试

题目背景

小 D 是一位即将参加 ION 的 IO 选手，然而笔试题库中数量繁多的奇怪
目让他大伤脑筋，快来帮帮他！ 题目描述

笔试题库可以抽象为 nnn 道题目，每道题目由题面和答案组成，
是一个字符串，保证所有题目题面互不相同。

为了检验小 D 背笔试的效果，教练进行了一次模拟考试，考试包含 qqq 道题目，每道题目都有 444 个选项，小 D 需要从 444 个选项中选出与答案相符的选项。



现在你需要帮助小 D 完成这场考试。
输入格式

第一行两个正整数 n,qn, qn,q。

接下来 nnn 行，每行 222 个用空格分隔的字符串，表示这道题目的题面和答案。

接下来 qqq 行，每行 555 个用空格分隔的字符串，第一
字符串表示模拟考试中这道题目的题面，其余 444 个字符串按顺序分别为这道题目的选项 A 到选项 D，保证选项各不相同。
 输出格式

对于模拟考试中的每道题目，输出一个字符表示这道题目答案对应的选项，保证所有题目均有解。
输入输出样例
输入 #1

3 4
decoak yes
duliuchutiren nonono
csps noiptg
decoak yes no qwq qaq
csps noiptg noippj noi cspj
decoak qwq qaq yesyes yes
duliuchutiren yes no nono nonono

输出 #1

A
A
D
D

说明/提示

【数据范围】

令 sss 为输入中字符串长度的最大值。

对于 30%30 \%30% 的数据，n,q,s≤10n, q, s \le 10n,q,s≤10。
对于另 20%20 \%20% 的数据，s=1s = 1s=1。
对于 100%100 \%100% 的数据，n,q,s≤100n, q, s \le 100n,q,s≤100，
有字符串都由小写拉丁字母组成。

code:
int n,q;
string qs[201],as[201];
int main(){
    cin>>n>>q;
    for(int i=1;i<=n;i++)cin>>qs[i]>>as[i];
    for(int i=1;i<=q;i++){
        string qtion,a,b,c,d;
        cin>>qtion>>a>>b>>c>>d;
        for(int i=1;i<=n;i++)
            if(qtion==qs[i]){
                if(a==as[i]){cout<<"A"<<endl;continue;}
                if(b==as[i]){cout<<"B"<<endl;continue;}
                if(c==as[i]){cout<<"C"<<endl;continue;}
                if(d==as[i]){cout<<"D"<<endl;continue;}
            }
    }
    return 0;
}

*/

/*
P5613 [MtOI2019]黑蚊子多

题目背景

性★感☆大★草 在☆线★开☆门
定☆数★一☆零 实★则☆虚★高
加★速☆转★圈 开☆幕★雷☆击
疯☆狂★交☆互 劲★爆☆咚★咚
黑★蚊☆子★多 邀☆您★来☆爽
题目描述

Hikari 的面前有 n(1≤n≤1000)n(1\leq n\leq 1000)n(1≤n≤1000) 级台阶，每 1s1s1s 她可以向上跳 m(1≤m≤n)m(1\leq m\
 eq n)m(1≤m≤n) 级台阶。（不在中间的台阶上停留）

台阶上有 k(k≤10)k(k\leq 10)k(k≤10) 个特殊的平台 aia_iai?，Hikari 在该平台 停留 时会使得 mmm 增加 111。



请问 Hikari 到达台阶顶部花费的时间。
输入格式

共 222 行。

第 111 行输入 333 个非负整数 n,m,kn,m,kn,m,k。

第 222 行输入 kkk 个正整数，第 iii 个正整数表示 aia_iai?，保证输入的 aia_iai? 单调递增。
 输出格式

共 111 行，输出 111 个正整数表示花费的时间。
输入输出样例
输入 #1

10 5 0

输出 #1

2

输入 #2

31 4 2
8 13

输出 #2

6

说明/提示
子任务

对于 60%60\%60% 的数据，k=0k=0k=0。

对于 100%100\%100% 的数据，1≤m≤n≤10001\leq m\leq n\leq 10001≤m≤n≤1000，k≤10k\leq 10k≤10。
 题目来源

MtOI2019 Extra Round T1

出题人：disangan233

code:
int main(){
    int n,m,k,t=0,p,time=0;
    cin>>n>>m>>k;
    int i,a[k];
    for(int i=0;i<k;i++)cin>>a[i];
    i=0;
    while(t<n){
        t=t+m;
        if(t>a[i])i++;
        if(t==a[i] && i<k){
            i++;m++;
        }
        time++;
    }
    cout<<time;
    return 0;
}

*/

/*
P5638 【CSGRound2】光骓者的荣耀

题目背景

小 K 又在做白日梦了。他进入到他的幻想中，发现他打下了一片江山。
题目描述

小 K 打
的江山一共有nnn个城市，城市iii和城市i+1i+1i+1有一条双向高速公路连接，走这条路要耗费时间aia_iai?。

小 K 为
关心人民生活，决定定期进行走访。他每一次会从111号城市到nnn号城市并在经过的城市进行访问。其中终点必须为城市nnn。

不仅如此，他还有一个传送器，传送半径为kkk，也就是可以传送到i?ki-ki?k和i+ki+ki+k。如果目标城市编号小于111则为111，大于nnn则为nnn。

但是他的传送器电量不足，只能传送一次，况且由于一些原因，他想尽量快的完成访问，于是就想问交通部部长您最快的时间是多少。

注意：他可以不访问所有的城市，使用传送器不耗费时间
输入格式

两行，第一行n,kn,kn,k。

第二行n?1n-1n?1个整数，第iii个表示aia_iai?。
输出格式

一个整数，表示答案。
输入输出样例
输入 #1

4 0
1 2 3

输出 #1

6

输入 #2

4 1
1 2 3

输出 #2

3

说明/提示
样例解释 1：

样例 1,2 的图示均为以下图片：

MZbuTK.png

不使用传送器直接走，答案为666，可以证明这个是最小值。
样例解释 2：

在333处使用，传送到444，答案为333，可以证明这个是最小值。
数据范围：

对于所有数据，ai>0a_i > 0ai?>0

Kvrl34.jpg

code:
int main(){
    long long n,k,sum=0,t=0,sum2=0;
    cin>>n>>k;
    long long longer[n];
    for(int i=0;i<n-1;i++){
        cin>>longer[i];
        sum+=longer[i];
    }
    for(int i=0;i<k;i++)
        t=t+longer[i];sum2=t;
    for(int i=k;i<n-1;i++){
        sum2=sum2-longer[i-k]+longer[i];
        if(sum2>t)t=sum2;
    }
    cout<<sum-t;
    return 0;
}*/

/*
P5660 [CSP-J2019] 数字游戏

题目描述

小 K 同学向小 P 同学发送了一个长度为 8 的 01 字符串来玩数字游戏，小 P 同学想要知道字符串中究竟有多少个 1。



注意：01 字符串为每一个字符是 0 或者 1 的字符串，如“101”（不含双引号）为一个长度为 3 的 
 1 字符串。 输入格式

输入文件只有一行，一个长度为 8 的 01 字符串 s。
输出格式

输出文件只有一行，包含一个整数，即 01 字符串中字符 1 的个数。
输入输出样例
输入 #1

00010100

输出 #1

2

输入 #2

11111111

输出 #2

8

说明/提示

【输入输出样例 1 说明】

该 01 字符串中有 2 个字符 1。

【输入输出样例 2 说明】

该 01 字符串中有 8 个字符 1。

【数据规模与约定】

对于 20% 的数据，保证输入的字符全部为 0。

对于 100% 的数据，输入只可能包含字符 0 和字符 1，字符串长度固定为 8。

code:
int main(){
    int i,t=0;
    cin>>i;
    for(int j=0;j<8;j++){
        if(i%10==1)t++;
        i=i/10;
    }
    cout<<t;
    return 0;
}

*/

/*
P5681 [CSP-J2019 江西] 面积

题目描述

Alice 有一个边长为 aaa 的正方形，Bob 有一个长宽分别为 b,cb,cb,c 的矩形，请你告诉他们俩谁的图形面积更大。
 输入格式

仅一行三个正整数 a,b,ca,b,ca,b,c
输出格式

输出仅一行一个字符串，若正方形面积大则输出 Alice，否则输出 Bob。
输入输出样例
输入 #1

5 4 6

输出 #1

Alice

输入 #2

7 5 10

输出 #2

Bob

说明/提示

【数据范围】
对于 30%30\%30% 的数据，1≤a,b,c≤1001 \le a,b,c \le 1001≤a,b,c≤100，b=cb=cb=c；
对于 80%80\%80% 的数据，1≤a,b,c≤1041\le a,b,c \le 10^41≤a,b,c≤104；
对于 100%100\%100% 的数据，1≤a,b,c≤1091\le a,b,c \le 10^91≤a,b,c≤109。

【样例 111 解释】
正方形面积为 252525，矩形面积为 242424。

【样例 222 解释】
正方形面积为 494949，矩形面积为 505050。

code:
int main(){
    double a,b,c;cin>>a>>b>>c;
    if(a*a>b*c)cout<<"Alice";else cout<<"Bob";
    return 0;
}

*/

/*
P5690 [CSP-S2019 江西] 日期

题目背景

CSP-SJX2019 T1
题目描述

Alice在纸上写下了一个日期，形式为 MM-DD\text{MM-DD}MM-DD，其中 MM\text{MM}MM 与 DD\text{DD}DD 都是两位数字，分别表示月和天，然而这个日期
 不一定存在。 Alice找来了Bob
他更改若干位上的数字，使得这个日期存在。请你帮Bob算算他最少需要更改几位数字。


本题中我们认为 222 月固定为 282828 天。
输入格式

仅一行一个五个字符的字符串，表示 MM-DD\text{MM-DD}MM-DD 。
输出格式

仅一行一个整数，表示答案。
输入输出样例
输入 #1

03-32

输出 #1

1

输入 #2

02-39

输出 #2

1

输入 #3

67-89

输出 #3

2

说明/提示

【输入输出样例1说明】

更改方式不止一种，其中一种方式是改为： 03-22\text{03-22}03-22。

【输入输出样例2说明】

一种更改方式为：02-09\text{02-09}02-09。

【输入输出样例3说明】

一种更改方式为：07-09\text{07-09}07-09。

【数据规模与约定】 对于 100%100\%100% 的数据：MM\text{MM}MM 与 DD\text{DD}DD 一定为 444 个数字。



code:
int main(){
    int a,b,t=0;
    cin>>a>>b;b=-b;
    if(a>12||a==0)t++;
    if(a>12||a==0)
        if(b>31)t++;
    if(a==1||a==3||a==5||a==7||a==8||a==10||a==12){
        if(b>31)t++;
    }
    else if(a==2){
        if(b>28)t++;
    }
    else if(a==4||a==6||a==9||a==11){
        if(b>30)t++;
    }
    if(b==0)t++;
    cout<<t;
    return 0;
}

*/

/*
P5703 【深基2.例5】苹果采购

题目描述

现在需要采购一些苹果，每名同学都可以分到固定数量的苹果，并且已经知道了同学的数量，请问需要采购多少个苹果？
输入格式

输入两个不超过 10910^9109 正整数，分别表示每人分到的数量和同学的人数。
输出格式

一个整数，表示答案。保证输入和答案都在int范围内的非负整数。
输入输出样例
输入 #1

5 3

输出 #1

15

code:
int main(){
    int a,b;
    cin>>a>>b;cout<<a*b;
    return 0;
}

*/

/*
P5704 【深基2.例6】字母转换

题目描述

输入一个小写字母，输出其对应的大写字母。例如输入 q[回车] 时，会输出 Q。
输入格式

无
输出格式

无
输入输出样例
输入 #1

q

输出 #1

Q

code:
int main(){
    char a;
    cin>>a;cout<<char(int(a)-32);
    return 0;
}

*/

/*
P5705 【深基2.例7】数字反转

题目描述

输入一个不小于 100100100 且小于 100010001000，同时包括小数
后一位的一个浮点数，例如 123.4123.4123.4 ，要求把这个数字翻转过来，变成 4.3214.
214.321 并输出。 输入格式

一行一个浮点数
输出格式

一行一个浮点数
输入输出样例
输入 #1

123.4

输出 #1

4.321

code:
int main(){
    string c;
    cin>>c;
    for(int i=0;i<c.length();i++)
    cout<<c[c.length()-i-1];
    return 0;
}

*/

/*
P5706 【深基2.例8】再分肥宅水

题目描述

现在有 t 毫升肥宅快乐水，要均分给 n 名同学。每名同学需要 2 个杯子。现在想知道每名同学可以获得多少毫升饮料（严格精确到小数点后 3 位），以及一共需要多少个杯

 。输入一个实数 t 和一个整数 n，使用空格隔开。输出两个数字表示答案，使用换
隔开。



0≤t≤100000\leq t\leq 100000≤t≤10000且不超过3位小数，1≤n≤10001\leq n\leq 10001≤n≤1000
 输入格式

无
输出格式

无
输入输出样例
输入 #1

500.0 3

输出 #1

166.667
6

code:
int main(){
    float c,n;
    cin>>c>>n;
    printf("%.3f",c/n);
    cout<<endl<<n*2;
    return 0;
}

*/

/*
P5708 【深基2.习2】三角形面积

题目描述

一个三角形的三边长分别是 aaa、bbb、ccc，那么它的面积为 p(p?a)(p?b)(p?c)\sqrt{p(p-a)(p-b)(p-c)}p(p?

)(p?b)(p?c)

?，其中 p=12(a+
+c)p=\frac{1}{2}(a+b+c)p=21?(a+b+c)。输入这三个数字，计算三角形的面积，四舍五入精确到 1 位小数。



保证能构成三角形，0≤a,b,c≤10000\leq a,b,c\leq 10000≤a,b,c≤1000，每个边长
入时不超过2位小数。 输入格式

无
输出格式

无
输入输出样例
输入 #1

3 4 5

输出 #1

6.0

code:
int main(){
    double a,b,c,p,ans;
    cin>>a>>b>>c;
        p=(a+b+c)/2;
        ans=sqrt(p*(p-a)*(p-b)*(p-c));
        printf("%.1lf",ans);
    return 0;
}

*/

/*
P5709 【深基2.习6】Apples Prologue

题目描述

八尾勇喜欢吃苹果。她现在有 m(m≤100)m(m\le 100)m(m≤100) 个苹果，吃完一个苹果需要花费 t(0≤t≤100)t(0 
 le t \le100)t(0≤t≤100) 分钟，
完一个后立刻开始吃下一个。现在时间过去了 s(s≤10000)s(s\le 10000)s(s≤10000) 分钟，请问她
 有几个完整的苹果？ 输入格式

输入三个非负整数表示 m 、t 和 s。
输出格式

输出一个整数表示答案。

如果你出现了 RE，不如检查一下被零除？
输入输出样例
输入 #1

50 10 200

输出 #1

30

code:
int main(){
    int a,b,c;
    cin>>a>>b>>c;
    if(c==0)cout<<a;
    else if(b==0)cout<<"0";
    else if(a-c/b>0){
        if(c%b==0)cout<<a-c/b;
        else cout<<a-c/b-1;
    }
    else cout<<"0";
    return 0;
}

*/

/*
P5710 【深基3.例2】数的性质

题目描述

一些数字可能拥有以下的性质：

    性质 1：是偶数；
    性质 2：大于 4 且不大于 12。

小A 喜欢这两个性质同时成立的数字；Uim 喜欢这至少符合其中一种性质的数字；八尾勇喜欢刚好有符合其中一个

质的数字；正妹喜欢不符合这两个性质的数字。
输入格式

输入一个数字 x(0≤x≤1000)x(0\le x \le 1000)x(0≤x≤1000)
输出格式

输出这 4 个人是否喜欢这个数字，如果喜欢则输出1，否则输出0，用空格分隔。
输入输出样例
输入 #1

12

输出 #1

1 1 0 0

code:
int main(){
    int a=0,b=0,c=0,d=0,n=0;cin>>n;
    if(n%2==0&&n>4&&n<=12) a=1;
        if(n%2==0||n>4&&n<=12||n%2==0&&n>4&&n<=12) b=1;
        if(n%2==0&&n<=4&&n>12||n>4&&n<=12&&n%2==1) c=1;
        if(n%2==1&&n<=4||n%2==1&&n>12) d=1;
    cout<<a<<" "<<b<<" "<<c<<" "<<d;
    return 0;
}

*/

/*
P5711 【深基3.例3】闰年判断

题目描述

输入一个年份（大于 1582 的整数 ），判断这一年是否是闰年，如果是输出 1，否则输出 0。
 输入格式

无
输出格式

无
输入输出样例
输入 #1

1926

输出 #1

0

输入 #2

1900

输出 #2

0

输入 #3

2000

输出 #3

1

输入 #4

1996

输出 #4

1

code:
int main(){
    int n=0;
    cin>>n;
    cout<<((n%4==0&&n%100!=0)||(n%400==0))?1:0;
    return 0;
}

*/

/*
P5712 【深基3.例4】Apples

题目描述

八尾勇喜欢吃苹果。她今天吃掉了 x(0≤x≤100)x(0\le x \le 100)x(0≤x≤100) 个苹果。英语课上学到了 apple 这个词语，想用它来造句。如果她吃了 1
 个苹果，就输出 Today, I ate 
 apple.；如果她没有吃，那么就把 1 换成 0；如果她吃了不止一个苹果，别忘了 apple 这个单词后面要加上代表复数的 s。
能帮她完成这个句子吗？



 输入格式

无
输出格式

无
输入输出样例
输入 #1

1

输出 #1

Today, I ate 1 apple.

输入 #2

3

输出 #2

Today, I ate 3 apples.

code:
int main(){
    int n=0;
    cin>>n;
    if(n<=1)cout<<"Today, I ate "<<n<<" apple.";
    else cout<<"Today, I ate "<<n<<" apples.";
    return 0;
}

*/

/*
P5713 【深基3.例5】洛谷团队系统 

题目描述

在洛谷上使用团队系统非常方便的添加自己的题目。如果在自己的电脑上配置题目和测试数据，每题需要花费时间 5 分钟；而在洛谷团队中上传私有题目，每题只需要花费 3 分钟，但是上传题目之前还需要一次性花费 11 分钟创建与配置团队。现在要配置 n(n≤100)n(n\le100)n(n≤100) 道题目，


 果本地配置花费的总时间短，请输出 Local，否则输出 Luogu。



 输入格式

无
输出格式

无
输入输出样例
输入 #1

2

输出 #1

Local

输入 #2

50

输出 #2

Luogu

code:
int main(){
    int n=0;
    cin>>n;
    if(n*5<=11+n*3)cout<<"Local";
    else cout<<"Luogu";
    return 0;
}

*/

/*
P5714 【深基3.例7】肥胖问题

题目描述

BMI 指数是国际上常用的衡量人体胖瘦程度的一个标准，其算法是 m/h2(40≤m≤120,1.4≤h≤2.0)m/h^2(40\le m \le 120, 1.4 \l
 h
\le 2.0)m/h2(40≤m≤120,1.4≤h≤2.0)，其中 mmm 是指体重（千克），hhh 是指身高（米）。
 同体型范围与判定结果如下：


    小于 18.5：体重过轻，输出 Underweight；
    大于等于 18.5 且小于 24：正常体重，输出 Normal；
    大于等于 24：肥胖，不仅要输出 BMI 值（使用 cout 的默认精度），然后换行，还要输出 Overweight；



现在给出体重和身高数据，需要根据 BMI 指数判断体型状态并输出对应的判断。

对于非 C++ 语言，在输出时，请四舍五入保留六位有效数字输出，如果小数部分存在后缀 000，不要输出后缀 000。



请注意，保留六位有效数字不是保留六位小数。例如 114.5149114.5149114.5149 应该输出为 114.515114.515114.515，9198.109198.10919
 .10 应该输出为 9198.1919
.19198.1。 输入格式

无
输出格式

无
输入输出样例
输入 #1

70 1.72

输出 #1

Normal

说明/提示

m 和 h 均不超过 3 位小数

code:
int main(){
    double m,h;cin>>m>>h;
    m=m/h/h;
    if(m<18.5)cout<<"Underweight";
    else if(m<24)cout<<"Normal";
    else cout<<m<<endl<<"Overweight";
    return 0;
}

*/

/*
P5715 【深基3.例8】三位数排序

题目描述

给出三个整数 a,b,c(0≤a,b,c≤100)a,b,c(0\le a,b,c \le 100)a,b,c(0≤a,b
c≤100)，要求把这三位整数从小到大排序。 输入格式

无
输出格式

无
输入输出样例
输入 #1

1 14 5

输出 #1

1 5 14

输入 #2

2 2 2

输出 #2

2 2 2

code:
int main(){
    int s[3]={0};
    cin>>s[0]>>s[1]>>s[2];
    sort(s,s+3);
    cout<<s[0]<<' '<<s[1]<<' '<<s[2];
    return 0;
}

*/

/*
P5716 【深基3.例9】月份天数

题目描述

输入年份和月份，输出这一年的这一月有多少天。需要考虑闰年。
输入格式

无
输出格式

无
输入输出样例
输入 #1

1926 8

输出 #1

31

输入 #2

2000 2

输出 #2

29

code:
int main(){
    int n,y;cin>>n>>y;
    if(y==1||y==3||y==5||y==7||y==8||y==10||y==12)cout<<"31";
    else if(y==4||y==6||y==9||y==11)cout<<"30";
    else if(((n%4==0)&&(n%100!=0)) || (n%400==0))cout<<"29";
    else cout<<"28";
    return 0;
}

*/

/*
P5718 【深基4.例2】找最小值

题目描述

给出 n(n≤100)n(n\le100)n(n≤100) 和 nnn 个整数 ai(0≤ai≤1000)a_i(0\le a_i \le 1000)ai?(0≤ai?≤1000
 ，求这 nnn 个整数中最小值是什么。 输入格式

无
输出格式

无
输入输出样例
输入 #1

8
1 9 2 6 0 8 1 7

输出 #1

0

code:
int main(){
    int n;cin>>n;
    int a[n];
    for(int i=0;i<n;i++)cin>>a[i];
    int t=a[0];
    for(int i=0;i<n;i++){
    if(a[i]<t)t=a[i];
    }
    cout<<t;
    return 0;
}

*/

/*
P5719 【深基4.例3】分类平均

题目描述

给定 n(n≤10000)n(n\le10000)n(n≤10000) 和 k(k≤100)k(k\le 100)k(k≤100)，将从 1 到 nnn 之间的所有正整数可以分为两类：A 
 数可以被 kkk 整除（也就是说是 kkk 的倍数），而 B 类数不能。请输出这两类数的平
数，精确到小数点后 1 位，用空格隔开。




数据保证两类数的个数都不会是 0。
输入格式

无
输出格式

无
输入输出样例
输入 #1

100 16

输出 #1

56.0 50.1

code:
int main(){
    int n=0,m=0,j,k;
    double sum1=0,sum2=0;
    cin>>j>>k;
    for(int i=1;i<=j;i++){
        if(i%k==0){
            n++;
            sum1+=i;
        }
        else{
            m++;
            sum2+=i;
        }
    }
    printf("%.1f %.1f",sum1/n,sum2/m);
    return 0;
}

*/

/*
P5720 【深基4.例4】一尺之棰

题目描述

《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为 a(a≤109)a(a\le 10^9)a(a≤109) 的木棍，从第二天开始，每天都要将这根木棍锯掉一半（每次除 2，向下取整）。第


天的时候木棍会变为 1？

 输入格式

无
输出格式

无
输入输出样例
输入 #1

100

输出 #1

7

code:
int main(){
    int n,day=0;cin>>n;
    while(n>1){
        day++;
        n/=2;
    }
    cout<<day+1;
    return 0;
}

*/

/*
P5721 【深基4.例6】数字直角三角形

题目描述

给出n(1≤n≤13)n(1\le n\le13)n(1≤n≤13)，请输出一个直角边长度是 nnn 的数字直角三角形。所有数字都是 2 位组成的，如果没有 2 位则加上前
 0。 输入格式

无
输出格式

无
输入输出样例
输入 #1

5

输出 #1

0102030405
06070809
101112
1314
15

code:
int main(){
    int n,t=0;cin>>n;
    int m=n;
    int p=0;
    for(int i=1;i<=(n+1)*n/2;i++){
    p++;t++;
    if(t<10)cout<<"0"<<t;
    else cout<<t;
    if(p%m==0)
    {
    m--;
    p=0;cout<<endl;
    }
    }
    return 0;
}

*/

/*
P5722 【深基4.例11】数列求和

题目描述

计算 1+2+3+?+(n?1)+n1+2+3+\cdots+(n-1)+n1+2+3+?+(n?1)+n 的值，其中正整数 nnn 不大于 100。由于你没有高斯聪明，所以你不被允许使用
 差数列求和公式直接求出答案。
输入格式

无
输出格式

无
输入输出样例
输入 #1

100

输出 #1

5050

code:
int main(){
    int a=0,n;
    cin>>n;
    for(int i=1;i<=n;i++){
    a+=i;
    }
    cout<<a;
    return 0;
}

*/

/*
P5724 【深基4.习5】求极差

题目描述

给出 n(n≤100)n(n\le100)n(n≤100) 和 nnn 个整数 ai(0≤ai≤1000)a_i(0\le a_i \le 1000)ai?(0≤ai?≤1000
 ，求这 nnn 个整数中的
差是什么。极差的意思是一组数中的最大值减去最小值的差。 输入格式

无
输出格式

无
输入输出样例
输入 #1

6
1 1 4 5 1 4

输出 #1

4

code:
int main(){
    int a;cin>>a;
    int s[a];
    for(int i=0;i<a;i++)cin>>s[i];
    sort(s,s+a);
    cout<<s[a-1]-s[0];
    return 0;
}

*/

/*
P5725 【深基4.习8】求三角形

题目描述

模仿例题，打印出不同方向的正方形，然后打印三角形矩阵。中间有个空行。
输入格式

输入矩阵的规模，不超过 9。
输出格式

输出矩形和正方形
输入输出样例
输入 #1

4

输出 #1

01020304
05060708
09101112
13141516

      01
    0203
  040506
07080910

code:
int main(){
int n;
cin>>n;
for(int i = 1; i <= n * n; i ++) {
if(i < 10)cout<<"0"<<i;
else cout<<i;
if(i % n == 0)cout<<endl;
}
cout<<endl;
int cnt = 1;
for(int i = 1; i <= n; i ++) {
for(int j = 1; j <= n - i; j ++)cout<<"  ";
while(cnt <= i * (i + 1) / 2) {
if(cnt < 10)cout<<"0"<<cnt;
else cout<<cnt;
cnt ++;
}
cout<<endl;
}
return 0;
}

*/

/*
P5727 【深基5.例3】冰雹猜想

题目描述

给出一个正整数 n(n≤100)n(n\le 100)n(n≤100)，然后
这个数字一直进行下面的操作：如果这个数字是奇数，那么将其乘 3 再加 1，否则除以 2。经过若干次循环后，最终都会回到 1。经过验证很大的数字（7×10117\times10^{11}7×1011）都可以按照这样的方式比变成 
，

 以被称为“冰雹猜想”。例如当 nnn 是 20，变化的过程是 [20, 10, 5, 16, 8, 4, 2, 1]。





根据给定的数字，验证这个猜想，并从最后的 1 开始，倒序输出整个变化序列。
输入格式

无
输出格式

无
输入输出样例
输入 #1

20

输出 #1

1 2 4 8 16 5 10 20

code:
void write(int n){
    if(n==1){
        cout<<n;
        return;
    }
    if(n&1)write(n*3+1);
    else write(n/2);
    cout<<" "<<n;
}
int main(){
    int n;
    cin>>n;
    write(n);
    return 0;
}

*/

/*
P5728 【深基5.例5】旗鼓相当的对手

题目描述

现有 N(N≤1000)N(N\le 1000)N(N≤1000) 名同学参加了期
考试，并且获得了每名同学的信息：语文、数学、英语成绩（均为不超过 150 的自然数）。如果某对学生 <i,j> 的每一科成绩的分差都不大于 5，且总分分差不大于 10，那么这对学生就是“旗鼓相当的对手
。现在想知道这些同学中，有几对“旗鼓相

的对手”？同样一个人可能会和其他好几名同学结对。


输入格式

第一行一个正整数 NNN。

接下来 NNN 行，每行三个整数，其中第 iii 行表示第 iii 名同学的语文、数学、英语成绩。最先读入的同学编号为 1。
 输出格式

输出一个个整数，表示“旗鼓相当的对手”的对数。
输入输出样例
输入 #1

3
90 90 90
85 95 90
80 100 91

输出 #1

2

code:
int main(){
int c[1005],m[1005],e[1005],t[1005];
int ans=0;
int n;
cin>>n;
for(int i=1;i<=n;++i){
cin>>c[i]>>m[i]>>e[i];
t[i]=c[i]+m[i]+e[i];
}
for(int i=1;i<=n;i++){
for(int j=i+1;j<=n;j++){
if((abs(c[i]-c[j])<=5)&&(abs(m[i]-m[j])<=5)&&(abs(e[i]-e[j])<=5)&&(abs(t[i]-t[j])<=10))ans++;
}
}
cout<<ans;
return 0;
}

*/

/*
P5729 【深基5.例7】工艺品制作

题目描述

现有一个长宽高分别为 w,x,h(1≤w,x,h≤20)w,x,h(1\le w,x,h\le 20)w,x,h(1≤w,x,h≤20) 组成的实心玻璃立方体，可以认为是由 1×1×11\ti
 es1\times11×1×1 的
个小方块组成的，每个小方块都有一个坐标 (i,j,k) ( i,j,k ) (i,j,k)。现在需要进行 q(q≤100)q(
 \le 100)q(q≤100) 次切割。每次切割给出 (x1,y1,z1),(x2,y2,z2)
x_1,y_1,z_1),(x_2,y_2,z_2)(x1?, 1?,z1?),(x2?,y2?,z2?) 这 6 个
数，保证 x1≤x2x_1\le x_2x1?≤x2?，y1≤y2y_1\le y_2y1?≤y2?，z1≤z2z_1\le 
_2z1?≤z2?；每次切割时，使用激光工具切出一个立方体空洞，空洞的壁平行于立方体的面，空洞的对角点就是给出的切割参数的两个点。




换句话说，所有满足 x1≤i≤x2x_1\le i\le x_2x1?≤i≤x2?，y1≤j≤y2y_1\le j \le y_2 y1?≤j≤y2?，z1≤k≤z2z_1\le k\le z_
z1? k≤z2? 的小方块 (i,j,k)(i,j,k)(i,j,k) 的点都会被激光蒸发
例如有一个 4×4×4 的大方块，其体积为 64；给出参数 (1,
,1),(2,2,2) 时，中间的 8 块小方块就会被蒸发，剩下 56 个小方块。现在想知道经过所有切割操作后，剩下的工艺品还剩下多少格小
块的体积？


输入格式

第一行三个正整数 w,x,hw,x,hw,x,h。

第二行一个正整数 qqq。

接下来 qqq 行，每行六个整数 (x1,y1,z1),(x2,y2,z2)
x_1,y_1,z_1),(x_2,y_2,z_2)(x1?,y1?,z1?),(x2?,y2?,z2?)
输出格式

输出一个整数表示答案。
输入输出样例
输入 #1

4 4 4
1
1 1 1 2 2 2

输出 #1

56

code:
int main(){
    int w,x,h,ans,q;
    int a[21][21][21]={0};
    cin>>w>>x>>h>>q;
    while(q--){
        int x1,y1,z1,x2,y2,z2;
        cin>>x1>>y1>>z1>>x2>>y2>>z2;
        for(int i=min(x1,x2); i<=max(x1,x2); i++)
            for(int j=min(y1,y2); j<=max(y1,y2); j++)
                for(int k=min(z1,z2); k<=max(z1,z2); k++)
                    a[i][j][k]=1;
    }
    for(int i=1; i<=w; i++)
        for(int j=1; j<=x; j++)
            for(int k=1; k<=h; k++)
                if(a[i][j][k]==0)
                    ans++;
    cout<<ans<<endl;
    return 0;
}

*/

/*
P5731 【深基5.习6】蛇形方阵

题目描述

给出一个不大于 9 的正整数 nnn，输出 n×nn\times nn×n 的蛇形方阵。

从左上角填上 1 开始，顺时针方向依次填
数字，如同样例所示。注意每个数字有都会占用 3 个字符，前面使用空格补齐。
 输入格式

无
输出格式

无
输入输出样例
输入 #1

4

输出 #1

  1  2  3  4
 12 13 14  5
 11 16 15  6
 10  9  8  7

code:
int main()
{
    int a[15][15]={0};
    int n,k=1,x=1,y=0;;
    cin>>n;
    while (k<=n*n){
        while(y<n&&!a[x][y+1])a[x][++y]=k++;
        while(x<n&&!a[x+1][y])a[++x][y]=k++;
        while(y>1&&!a[x][y-1])a[x][--y]=k++;
        while(x>1&&!a[x-1][y])a[--x][y]=k++;
    }
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++)
            printf("%3d",a[i][j]);
        cout<<endl;
    }
    return 0;
}

*/

/*
P5732 【深基5.习7】杨辉三角

题目描述

给出 n(n≤20)n(n\le20)n(n≤20)，输出杨辉三角的前 nnn 行。

如果你不知道什么是杨辉三角，可以观察样例找找规律。
输入格式

无
输出格式

无
输入输出样例
输入 #1

6

输出 #1

1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1

code:
int main(){
    int a,b[20]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},c[20]={1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};cin>>a;
    int i=2;
    if(a==1)cout<<"1";
    else if(a==2)cout<<"1"<<endl<<"1 1";
    else {
    cout<<"1"<<endl<<"1 1"<<endl;
    while(a>i){
    cout<<"1 ";
    i++;
    for(int j=1;j<i-1;j++){
    b[j]=c[j-1]+c[j];cout<<b[j]<<" ";
    }
    for(int j=0;j<20;j++)c[j]=b[j];
    cout<<"1"<<endl;
    }
    }
    return 0;
}

*/

/*
P5733 【深基6.例1】自动修正

题目描述

大家都知道一些办公软件有自动将字母转换为大写的功能。输入一个长度不超过 100 且不包括空格的字符串。要求将该字符串中的所有小写字母变成大写字母并输出。


输入格式

无
输出格式

无
输入输出样例
输入 #1

Luogu4!

输出 #1

LUOGU4!

code:
int main(){
    string c;cin>>c;
    for(int i=0;i<c.length();i++){
    if(c[i]>='a' && c[i]<='z')cout<<char(char(c[i])-32);
    else cout<<c[i];
    }
    return 0;
}

*/

/*
P5734 【深基6.例6】文字处理软件

题目描述

你需要开发一款文字处理软件。最开始时输入一个字符串（不超过 100 个字符）作为初始文档。可以认为文档开头是第 0 个字符。需要支持以下操作：



    1 str：后接插入，在文档后面插入字符串 str，并输出文档的字符串。

    2 a b：截取文档部分，只保留文档中从第 a 个字符起 b 个字符，并输出文档的字符串。



    3 a str：插入片段，在文档中第 a 个字符前面插入字符串 str，并输出文档的字符串。



    4 str：查找子串，查找字符串 str 在文档中最先的位置并输出；如果找不到输出 -1。



为了简化问题，规定初始的文档和每次操作中的 str 都不含有空格或换行。最多会有 q(q≤100)q(q\le100)q(q≤100) 次操作。
 输入格式

无
输出格式

无
输入输出样例
输入 #1

4
ILove
1 Luogu
2 5 5
3 3 guGugu
4 gu

输出 #1

ILoveLuogu
Luogu
LuoguGugugu
3

code:
string qwq,c1,b1;
int a,b,c,d=-1,n,e;
int main(){
    cin>>n;
    cin>>qwq;
    for(int i=0;i<n;i++){
        cin>>a;
        if(a==1){
            cin>>b1;
            qwq+=b1;
            cout<<qwq<<endl;
        }
        else if(a==2){
            cin>>b>>c;
            qwq=qwq.substr(b,c);
            cout<<qwq<<endl;
        }
        else if(a==3){
            cin>>b>>b1;
            qwq.insert(b,b1);
            cout<<qwq<<endl;
        }
        else if(a==4){
            cin>>b1;
            if(qwq.find(b1)<qwq.size())cout<<qwq.find(b1)<<endl;
            else cout<<-1<<endl;
        }
    }
    return 0;
}

*/

/*
P5735 【深基7.例1】距离函数

题目描述

给出平面坐标上不在一条直线上三个点坐标 (x1,y1),(x2,y2),(x3,y3)(x_1,y_1),(x_2
y_2),(x_3,y_3)(x1?,y1?),(x2?,y2?),(x3?,y3?)，坐标值是实数，且的绝对值不超过 100.00，求围成的三角形周长。保留两位小数。



对于平面上的两个点 (x1,y1),(x2,y2)(x
1,y_1),(x_2,y_2)(x1?,y1?),(x2?,y2?)，则这两个点之间的距离 dis=(x2?x1)2+(y2?y1)2dis=\sqr
{(x_2-x_1)^2+(y_2
y_1)^2}dis=(x2??x1?)2+(y2??y1?)2

?
输入格式

无
输出格式

无
输入输出样例
输入 #1

0 0 0 3 4 0

输出 #1

12.00

code:
int main(){
    double a,b,c,d,e,f,t=0;
    cin>>a>>b>>c>>d>>e>>f;
    t=sqrt((a-c)*(a-c)+(b-d)*(b-d))+sqrt((a-e)*(a-e)+(b-f)*(b-f))+sqrt((c-e)*(c-e)+(d-f)*(d-f));
    printf("%.2f",t);
    return 0;
}

*/

/*
P5737 【深基7.例3】闰年展示

题目描述

输入 x,y(1582≤x<y≤3000)x,y(1582\le x < y \le 3000)x,y(1582≤x<y≤3000) ，输出 [x,y][x,y][x,y] 区
 中闰年个数，并在下一行输出所有闰年年份数字，使用空格隔开。
输入格式

无
输出格式

无
输入输出样例
输入 #1

1989 2001

输出 #1

3
1992 1996 2000

code:
int main(){
    int a,b,c=0;
    cin>>a>>b;
    for(int i=a;i<=b;i++)
    if((i%4==0&&i%100!=0)||i%400==0)c++;
    cout<<c<<endl;
    for(int i=a;i<=b;i++)
    if((i%4==0&&i%100!=0)||i%400==0)cout<<i<<" ";
    return 0;
}

*/

/*
P5739 【深基7.例7】计算阶乘

题目描述

求 n!(n≤12)n!(n\le12)n!(n≤12)，也就是 1×2×3...×n1×2×3...×n1×2×3...×n。

挑战：尝试不使用循环语句（for、while）完成这个任务。
输入格式

无
输出格式

无
输入输出样例
输入 #1

3

输出 #1

6

code:
int cj(int n){
    if(n==1)return 1;
    else return n*cj(n-1);
}
int main(){
    int a;cin>>a;
    cout<<cj(a);
    return 0;
}

*/

/*
P5743 【深基7.习8】猴子吃桃

题目描述

一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；接下来的每一天它都会吃剩余的桃子的一半外加一个。第 n(n≤20)n(n\le20)n(n≤20) 天早上起来一看，只剩下 1 个桃子了。请问小猴买了几个桃子？



 输入格式

无
输出格式

无
输入输出样例
输入 #1

4

输出 #1

22

code:
int main(){
    int a,sum=1;cin>>a;
    for(int i=0;i<a-1;i++)
    sum=(sum+1)*2;
    cout<<sum;
    return 0;
}

*/

/*
P5744 【深基7.习9】培训

题目描述

某培训机构的学员有如下信息：

    姓名（字符串）
    年龄（周岁，整数）
    去年 NOIP 成绩（整数，且保证是 5 的倍数 ）

经过为期一年的培训，所有同学的成绩都有所提高，提升了 20%（当然 NOIP 满分是 600 分，不能超过这个得分）。



输入学员信息，请设计一个结构体储存这些学生信息，并设计一个函数模拟培训过程，其参数是这样的结构体类型，返回同样的结构体类型，并输出学员信息。
输入格式

无
输出格式

无
输入输出样例
输入 #1

3
kkksc03 24 0
chen_zhe 14 400
nzhtl1477 18 590

输出 #1

kkksc03 25 0
chen_zhe 15 480
nzhtl1477 19 600

code:
int main(){
    int a;cin>>a;
    for(int i=0;i<a;i++){
        string c;
        int age,grade;
        cin>>c>>age>>grade;
        cout<<c<<" "<<age+1<<" ";
        if(grade>=500)cout<<600<<endl;
        else cout<<grade*1.2<<endl;
    }
    return 0;
}

*/

/*
P5831 [USACO19DEC]Cow Gymnastics B

题目描述

为了提高健康水平，奶牛们开始进行体操训练了！Farmer John 选定了他最喜爱的奶牛 Bessie 来执教其他 NNN 头奶牛，同时评估她们学习不同的体操技术的进度。



KKK 次训练课的每一次，Bessie 都会根据 NNN 头奶牛的表现给她们进行排名。之后，她对这些排名的一

性产生了好奇。称一对不同的奶牛是一致的，如果其中一头奶牛在每次训练课中都表现得都比另一头要好。

请帮助 Bessie 计算一致的奶牛的对数。
输入格式

输入的第一行包含两个正整数 KKK 和 NNN。以下 KKK 行每行包含整数 1…N1 \ldots N1…N 的某种排列，表示奶牛们的排名（奶牛们用编号 1…N1 \ldots N1…N 进行区分）。如果在某一行

 AAA 出现在 BBB 之前，表示奶牛 AAA 表现得比奶牛 BBB 要好。


 输出格式

输出一行，包含一致的奶牛的对数。
输入输出样例
输入 #1

3 4
4 1 2 3
4 1 3 2
4 2 1 3

输出 #1

4

说明/提示

一致的奶牛对为 (1,4)(1,4)(1,4)、(2,4)(2,4)(2,4)、(3,4)(3,4)(3,4) 和 (1,3)(1,3)(1,3)。



1≤K≤101 \leq K \leq 101≤K≤10，1≤N≤201 \leq N \leq 201≤N≤20。

供题：Nick Wu

code:
int main(){
    int n,k,sum=0;cin>>k>>n;
    int a[11][21]={0},c[11][21]={0};
    for(int i=1;i<=k;i++){
        for(int j=1;j<=n;j++){
            cin>>a[i][j];
            c[i][a[i][j]]=j;
        }
    }
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            int cnt=0;
            for(int x=1;x<=k;x++)if(c[x][i]>c[x][j])cnt++;
            if(cnt==k)sum++;
        }
    }
    cout<<sum;
    return 0;
}

*/

/*
P5832 [USACO19DEC]Where Am I? B

题目描述

Farmer John 出门沿着马路散步，但是他现在发现可能迷路了！

沿路有一排共 NNN 个农场。不幸的是农场并没有编号，这使得 Farmer John 难以分辨他在这条路上所处的位置。然而，每个农场都沿路设有一个彩色的邮箱，所以 Farmer Joh

 希望能够通过查看最近的几个邮箱的颜色来唯一确定他所在的位置。


每个邮箱的颜色用 A..Z 之间的一个字母来指定，所以沿着道路的 NNN 个邮箱的序列可以用一个长为 NNN 的由字母 A..Z 组成的字符串来表示。某些邮箱可能会有相同的颜色

 Farmer John 想要知道最小的 KKK 的值，使得他查看任意连续 
KK 个邮箱序列，他都可以唯一确定这一序列在道 上的位置。



例如，假设沿路的邮箱序列为 ABCDABC 。Farmer John 不能令 K=3K=3K=3，因为如果他看到了 ABC，沿路有两个这一连续颜

序列可能所在的位置。最小可行的 KKK 的值为 K=4K=4K=4，因为
果他查看任意连续 4 个邮箱，这一颜色序列可以唯一确定他在道路上的位置。

 输入格式

输入的第一行包含 NNN，第二行包含一个由 NNN 个字符组成的字符串，每个字符均在 A..Z 之内。
 输出格式

输出一行，包含一个整数，为可以解决 Farmer John 的问题的最小 KKK 值。
输入输出样例
输入 #1

7
ABCDABC

输出 #1

4

说明/提示

1≤N≤1001 \leq N \leq 1001≤N≤100。

code:
int n,s,m;
char a[250];
void c(int i,int j){
    if(a[i]==a[j]){
        s++;
        c(i+1,j+1);
    }
}
int main(){
    cin>>n;
    for(int z=1;z<=n;z++)cin>>a[z];
    for(int w=1;w<=n;w++){
        for(int b=w+1;b<=n;b++){
            s=0;
            c(w,b);
            if(s>m) m=s;
        }
    }
    cout<<m+1;
    return 0;
}

*/

/*
P5886 Hello, 2020!

题目背景

时针与分针重合在「零」的那一霎那，嘀嗒声便宣告了新一年的到来。

在过去的一年里，世事无常。屏幕面前的你可能不久前才听闻「OI」，也可能暂时地结束了竞赛生涯；可能在赛场上叱咤风云名列榜首，也可能独自承受着比赛失利的落寞。

无论如何，过去仍旧是过去，将来依然是将来。

以此题为开端，迎接你的 2020 吧！
题目描述

本场比赛有 nnn 名出题人，mmm 名选手。

出题人从 111 至 nnn 依次标号，选手从 111 至 mmm 依次标号。

比赛结束后选手的最终排名为 111 至 mmm 中其一，且互不相同。

报名结束后，第 iii 位出题人看了看报名列表，对其他出题人说：「我觉得只有这 kik_iki? 位选手有可能最终排名第一，他们分别是 ai,1,ai,2,…,ai,kia_{i,1},a_{i,2},\dots,


_{i,k_i}ai,1?,ai,2?,…,ai,ki??。其他人不可能最终排名第一。」


你面前屏幕上的这道题的出题人通过时空隧道，预先得知了谁是最终排名第一的选手。

出题人把这 nnn 位出题人的预测都告诉了你，还告诉你恰好只有 ppp 个出题人的预测是正确的。



请你求出哪些选手可能最终获得第一名，并以从小到大的顺序依次输出这些选手的编号。
输入格式

从标准输入中读取数据。

第一行，三个正整数 n,m,pn,m,pn,m,p，表示出题人数，选手数，与正确预测数。

接下来 nnn 行，每行第一个非负整数 kik_iki? 表示第 iii 位出题人预测可能最终排名第一的选手位数；接下来 kik_iki? 个正

 数 a
,1,ai,2,…,ai,kia_{i,1},a_{i,2},\dots,a_{i,k_i}ai,1?,ai,2?,…,ai,ki??，表示这位出题人预测可能最终排名第一的选手编
。
输出格式

输出数据至标准输出中。

第一行，输出一个非负整数，表示可能最终获得第一名的选手个数。

第二行，以从小到大的顺序依次输出这些选手的编号。
输入输出样例
输入 #1

4 3 2
2 2 3
1 1
3 1 2 3
2 1 3

输出 #1

1
2

说明/提示

子任务 1（6%6\%6%）：n≤20n\leq 20n≤20，m≤20m\leq 20m≤20。

子任务 2（30%30\%30%）：n≤100n\leq 100n≤100，m≤100m\leq 100m≤100，∑ki≤104\sum k_i \leq 10^4∑ki?≤104。



子任务 3（24%24\%24%）：n≤1000n\leq 1000n≤1000，m≤1000m\leq 1000m≤1000。

子任务 4（40%40\%40%）：无特殊限制。

对于全部数据，1≤n≤1051\leq n\leq 10^51≤n≤105，1≤m≤1061\leq m\leq 10^61≤m≤106，0≤∑ki≤1060\leq 

sum k_i \leq 10^60≤∑ki?≤106，0≤p≤n0\leq p\leq n0≤p≤n。

code:
int main(){
    int n,m,p,k,t;
    cin>>n>>m>>p;
    int number[m]={0};
    for(int i=0;i<n;i++){
        cin>>k;
        for(int j=0;j<k;j++)
        {cin>>t;number[t-1]++;}
    }
    k=0;t=0;
    for(int i=0;i<m;i++)if(number[i]==p)t++;
    cout<<t<<endl;
    for(int i=0;i<m;i++)if(number[i]==p)cout<<i+1<<" ";
}

*/

/*
P6056 [加油武汉]SIR 模型

题目背景

SIR 模型将总人口分为以下三类：

    易感者(susceptibles)，其数量记为 s(t)s(t)s(t) ，表示 ttt 时刻未染病但有可能被该类疾病传染的人数；
 染病者(infectives)，其数量记为 i(t)i(t)i(t)，表示 t
 t 时刻已被感染成为病人而且具有传染力的人数；
    恢复者(recovered)，其数量记为 r(t)r(t)r(t)，表示 ttt 时刻已从染病者中移出的人数。



设总人口为N(t)N(t)N(t)，则有N(t)=s(t)+i(t)+r(t)N(t)=s(t)+i(t)+r(t)N(t)=s(t)+i(t)+r(t)。

SIR模型的建立基于以下三个假设：

    不考虑人口的出生、死亡、流动等种群动力因素。人口始终保持一个常数，即 N(t)≡KN(t) \equiv K N(t)≡K。


    一个病人一旦与易感者接触就必然具有一定的传染力。假设 ttt 时刻单位时间内，一个病人能传染的易感者数目与此环境内易感者总数 s(t)s(t)s(t) 成正比，比例

 数为 β\betaβ，从而在t时刻单位时间内被所有病人传染的人数为 βs(t)i(t)\beta s(t)i(t)βs(t)i(t)。


 ttt
时刻，单位时间内从染病者中移出的人数与病人数量成正比，比例系数为γ\gammaγ，单位时间内移出者的数量为 γi(t)\gamma i(t)γi(t)。



题目描述

我们将这个模型简化一下，初始有感染者 III 人和易感者 SSS 人，对于每一天当前有 IiI_iIi? 个感染者，SiS_iSi? 个易感者，RiR_iRi? 个恢复者，则每天会有 ?βSiIi?\lceil \be

 a S_iI_i \rceil?βSi?Ii?? 人被感染（由易感
变成感染者），有 ?γIi?\lceil \gamma I_i \rceil?γIi?? 人被治愈（由感染者变成恢复者
 。



其中 β\betaβ 为感染系数 γ\gammaγ 为恢复系数 ??\lceil \rceil?? 为上取整符号。

求 nnn 天后，有多少易感者 SSS，感染者 III，和恢复者 RRR 。

注: 感
者和恢复者都是每天结算的，结算的结果只和当天开始的时候的值有关，即感染者当天恢复不影响他当天感染别人。

若计算被感染人数超过易感者人数则全员被感染。
输入格式

第一行三个正整数，分别表示第 000 天易感者人数 S0S_0S0? 和感染者人数I0I_0I0?，以及天数 nnn（刚开始恢复者数 R0=0R_0=0

 0?=0）。


第二行两个浮点数，分别表示感染系数 β\betaβ 和恢复系数 γ\gammaγ。
输出格式

一行三个整数，分别表示 nnn 天后的易感者人数 SSS 、感染者人数 III 和恢复者RRR。
输入输出样例
输入 #1

980 20 2
0.0005 0.00001

输出 #1

955 43 2

输入 #2

1400000000 1 10
0.000000003 0.001

输出 #2

1386791252 13205592 3157

输入 #3

1919 810 1
0.00001 0.1

输出 #3

1903 745 81

说明/提示

对于 30%30\%30% 的数据，n=1n=1n=1。
对于另外 30%30\%30% 的数据，S0,R0≤104S_0, R_0\le 10^4S0?,R0?≤104。
 对于 100%100\%100% 的数据
1≤S0+R0≤2×109,0<β,γ<1,1≤n≤1001 \le S_0+R_0\le 2\times 10^9, 0 < \beta, \gamma < 1, 1 \le n
\l 1001≤S0?+R0?≤2×109,0<β,γ<1,1≤n≤100。

code:
int main(){
    int s,i,n,ii,r=0;
    cin>>s>>i>>n;
    double beta,gamma;
    cin>>beta>>gamma;
    for(int j=0;j<n;j++){
        int si=ceil(beta*s*i);
        int ii=ceil(gamma*i);
        r+=ii;
        if(si>=s)i+=s-ii,s=0;
        else i+=si-ii,s-=si;
    }
    cout<<s<<" "<<i<<" "<<r;
    return 0;
}

*/

/*
P6153 询问

题目背景

zbw 被邀请至幼儿园给小朋友们出题。
题目描述

现在 zbw 有 nnn 个物品，编号从 1?n1 \sim n1?n，他会告诉你 mmm 个条件，每个条件包含两个数 x,yx,yx,y，表示第 xxx 个物品
 第 yyy 个物品是相同的。

因为 zbw 特别赶
间，所以他保证每次给出的条件都是有用的，也就是说，每次给出的条件无法由之前的条件推导得来。

你需要回答有多少种不同的物品。
输入格式

第一行两个整数 nnn,mmm。

之后 mmm 行，每行两个数 x,yx,yx,y，表示第 xxx 个物品和第 yyy 个物品是相同的。
输出格式

一个整数，不同物品的数量。
输入输出样例
输入 #1

11 8
1 2
4 3
5 4
1 3
5 6
7 10
5 10
8 9

输出 #1

3

说明/提示

对于 20%20\%20% 的数据，n,m≤10n,m \le 10n,m≤10。

对于 40%40\%40% 的数据，n,m≤103n,m \le 10^3n,m≤103。

对于 60%60\%60% 的数据，n,m≤105n,m \le 10^5n,m≤105。

对于 80%80\%80% 的数据，m≤106m \le 10^6m≤106。

对于 100%100\%100% 的数据，1≤n≤10181 \le n \le 10^{18}1≤n≤1018，1≤m≤1071 \le m \le 10^71≤m≤107。

code:
int main(){
    long long n,m;
    cin>>n>>m;
    cout<<n-m;
    return 0;
}

*/

/*
P6159 [Cnoi2020]光图

题目背景

    简洁中蕴含着伟大。

Cirno 不经意地把一个内部完全反射的圆分成了 121212 等分，等分点分别记作 A0A_0A0?, A1A_1A1?, A2A_2A2?, ?\cdots? , A11A_{11}A11?。

随后，她不经意地将一束光从一点发出，朝向另一点，重复，反射，迭代，便得到了一幅美妙的光图。

这一切都发生在不经意之间。

她不经意地发现了这一幕，并且不经意地记下了这个不经意的结论，又在某一刻不经意地回忆起。

幻想乡的每一天一切都是这么不以为意，多好的一天啊！
题目描述

Rumia 有一个单位圆，被分成 nnn 等分，等分点分别记作 A0A_0A0?, A1A_1A1?, A2A_2A2?, ?\cdots? , An?1A_{n-1}An?1?。

现在她从 A0A_0A0? 向 ApA_pAp? 发射一束光，经过 kkk 次反射，到达了 AtA_tAt?。

Rumia 想知道 ttt 的值，由于 Cirno 并不想帮她，所以 Rumia 转而求助于你。
输入格式

一行，三个整数，n,p,kn,p,kn,p,k。
输出格式

一行，一个整数 ttt。
输入输出样例
输入 #1

12 5 2

输出 #1

10

输入 #2

1000 342 3472844

输出 #2

648

说明/提示
Sample1 解释

后置物理知识

    连续曲线反射规律 : 入射光线与出射光线关于入射点在曲线上切线夹角相等。

数据范围约定

「本题采用捆绑测试」

    Subtask1( 80%80\%80% ) : n,k≤106n, k \le 10^6n,k≤106
    Subtask2( 20%20\%20% ) : n,k≤109n, k \le 10^9n,k≤109

对于 100%100\%100% 的数据 : 0<p<n≤1090 < p < n \le 10^90<p<n≤109, 0<k≤1090 < k \le 10^90<k≤109。
后记

    Cirno 得到的光图就是传说中的十二芒星图。

code:
int main(){
	unsigned long long n,p,k;
	cin>>n>>p>>k;
	cout<<(p*k)%n;
	return 0;
}

*/

/*
P6194 [EER1]苏联人

题目背景

题目名称是吸引你点进来的。

这是一道正常的题，和苏联没有任何关系。
题目描述

你在打 EE Round 1，发现第一题非常无聊。于是你不打了，去下国际象棋了。

结果你发现，由于神秘力量的影响，你的棋子只剩下若干黑色的战车，若干黑色的主教和一只白色的国王了。

由于你很无聊，所以你把一些黑色棋子放在了 8×88\times 88×8 的棋盘上。

由于你很无聊，所以你想知道，国王放在哪些格子是安全的。换句话说，有哪些格子不会被战车和主教攻击到。当然，国王不能放在已经有棋子的地方。

为了防止你无聊透顶而不知道国际象棋的规则，这里给出以下提示（如果你知道规则那么可以跳过）：

国际象棋中，战车可以横向、竖向移动，且格数不受限制。但不能越过其他棋子。

如图，黄色的格子为战车能走到（攻击到）的格子。

国际象棋中，主教可以斜向移动，且格数不受限制。但不能越过其他棋子。

如图，黄色的格子为主教能走到（攻击到）的格子。

简单来说，如果当前位置到目标位置的直线上存在其他棋子，则可以称为“越过了其他棋子”。

如果目标位置是对方的棋子，那么移动到目标位置后，对方的棋子会被吃掉。

更进一步地，你要找的所有位置，必须满足没有黑色棋子能一步走到。

如果你还是没有读懂，可以结合样例进行理解。
输入格式

共 888 行，每行 888 个字符，表示棋盘的状态。

其中 . 表示空位，R 表示战车，B 表示主教。
输出格式

共 888 行，每行 888 个字符。若一个格子是可以放国王的，则输出 1，否则输出 0。
输入输出样例
输入 #1

........
........
........
..B..R..
........
........
........
........

输出 #1

11111011
01110011
10101011
11000000
10101011
01110011
11111011
11111001

说明/提示

对于 100%100\%100% 的数据，保证只会出现 .，R，B 三种字符。

本题共有 444 个子任务，每个子任务的限制如下：

子任务 111（101010 分）：保证只会出现 .。

子任务 222（202020 分）：保证只会出现一个 R 或一个 B（不同时出现）。

子任务 333（303030 分）：保证只有一个 .。

子任务 444（404040 分）：没有特殊限制。

code:
int main(){
    char ch[8][8]={0};bool ans[8][8]={0};
    for(int i=0;i<8;i++)
        cin>>ch[i];
    for(int i=0;i<8;i++)
    for(int j=0;j<8;j++)
        if(ch[i][j]=='R'){
            ans[i][j]=1;
            for(int k=i-1;k>=0 && ch[k][j]=='.';k--) ans[k][j]=1;
            for(int k=i+1;k<8 && ch[k][j]=='.';k++) ans[k][j]=1;
            for(int k=j-1;k>=0 && ch[i][k]=='.';k--) ans[i][k]=1;
            for(int k=j+1;k<8 && ch[i][k]=='.';k++) ans[i][k]=1;
        }
        else if(ch[i][j]=='B'){
            ans[i][j]=1;
            for(int k=i-1,l=j-1;k>=0 && l>=0 && ch[k][l]=='.';k--,l--) ans[k][l]=1;
            for(int k=i+1,l=j+1;k<8 && l<8 && ch[k][l]=='.';k++,l++) ans[k][l]=1;
            for(int k=i-1,l=j+1;k>=0 && l<8 && ch[k][l]=='.';k--,l++) ans[k][l]=1;
            for(int k=i+1,l=j-1;k<8 && l>=0 && ch[k][l]=='.';k++,l--) ans[k][l]=1;
        }
    for(int i=0;i<8;i++){
        for(int j=0;j<8;j++) cout<<!ans[i][j];
        cout<<endl;
    }
    return 0;
}

*/

/*
P6206 [USACO06OCT] Another Cow Number Game G

题目描述

奶牛们在玩一种数字游戏，Bessie 想让你帮她预测一下结果。游戏开始时，Bessie 将得到一个正整数 NNN。此时她的分数为 000。



奶牛们按照以下规则对 NNN 进行变换：

    如果 NNN 是奇数，那么将它乘以 333 后再加 111。
    如果 NNN 是偶数，那么将它除以 222。

数字每变换一次，Bessie 就得到 111 分。当 N=1N=1N=1 时，游戏结束。此时的分数就是她的最终得分。
 输入格式

一行，一个整数 NNN。
输出格式

一行，一个整数，为 Bessie 的最终得分。
输入输出样例
输入 #1

5

输出 #1

5

说明/提示

【数据范围】

对于 100%100\%100% 的数据，1≤N≤1061\le N\le 10^61≤N≤106。

【样例说明】

当 NNN 的初始值为 555 时，游戏的过程如下：
NNN 	变换后的数字 	变换过程 	总分
555 	161616 	3×5+13\times 5+13×5+1 	111
161616 	888 	16÷216\div 216÷2 	222
888 	444 	8÷28\div 28÷2 	333
444 	222 	4÷24\div 24÷2 	444
222 	111 	2÷22\div 22÷2 	555

Bessie 的最终得分为 555。

code:
int main(){
    long long  n,m=0;
    cin>>n;
    while(n!=1){
        if((n%2)==1)n=n*3+1;
        else n=n/2;
        m++;
    }
    cout<<m;
    return 0;
} 

*/

/*
P6263 [COCI2014/2015#3]STROJOPIS

题目描述

正确的打字正成为文化的重要组成部分。如果你仍然没有使用所有的十根手指来打字，你必须重新学习打字――然后你会打字更快，感觉更舒适和愉快。

有很多网站教你正确打字。下图描述了基本原理：用同一个指针按所需的键是同一颜色的。黄色键需要用小指按下，蓝色键需要用无名指，绿色键需要用中指，红色键需要用食指。自然，左手按键盘的左侧（从 5、T、G、B 开始向左的键），右手按右侧（从 6、Y、H、N 开始向右的键），拇指负责空格。





您的任务是输出每根手指（拇指除外）正确输入给定字符串的分别按下的次数。
输入格式

仅一行一个字符串 sss。字符串不包含空格，只包含上面图像中包含的字符。
输出格式

输出必须由八行组成，每行一个整数，表示从左到右观察到的每个手指的按键次数（拇指除外）。
输入输出样例
输入 #1

AON=BOO;

输出 #1

1
0
0
1
1
0
3
2

输入 #2

PRINT'NY'[NASLA]

输出 #2

2
1
0
2
4
1
1
5

输入 #3

VIDI,KO,JE,DOSA

输出 #3

1
1
3
1
1
6
2
0

说明/提示
数据规模与约定

令 OsO|s|OsO 表示输入字符串的长度，则对于 100%100\%100% 的数据，有 1≤OsO≤501\le |s|\le 501≤OsO≤50。



code:
int main(){
    int number[8]={0};
    string c;cin>>c;
    for(int i=0;i<c.length();i++){
        if(c[i]=='1'||c[i]=='Q'||c[i]=='A'||c[i]=='Z')number[0]++;
        else if (c[i] == '2' || c[i] == 'W' || c[i] == 'S' ||
                    c[i] == 'X')
            number[1]++;
        else if (c[i] == '3' || c[i] == 'E' || c[i] == 'D' ||
                    c[i] == 'C')
            number[2]++;
        else if (c[i] == '4' || c[i] == 'R' || c[i] == 'F' ||
                    c[i] == 'V' || c[i] == '5' || c[i] == 'T' ||
                    c[i] == 'G' || c[i] == 'B')
            number[3]++;
        else if (c[i] == '6' || c[i] == 'Y' || c[i] == 'H' ||
                    c[i] == 'N' || c[i] == '7' || c[i] == 'U' ||
                    c[i] == 'J' || c[i] == 'M')
            number[4]++;
        else if (c[i] == '8' || c[i] == 'I' || c[i] == 'K' ||
                    c[i] == ',')
            number[5]++;
        else if (c[i] == '9' || c[i] == 'O' || c[i] == 'L' ||
                    c[i] == '.')
            number[6]++;
        else if (c[i] == '0' || c[i] == 'P' || c[i] == ';' ||
                    c[i] == '/' || c[i] == '-' || c[i] == '[' ||
                    c[i] == '\'' || c[i] == '=' || c[i] == ']')
            number[7]++;
    }
    for(int i=0;i<8;i++)cout<<number[i]<<endl;
    return 0;
}

*/

/*
P6320 [COCI2006-2007#4] SIBICE

题目背景

年轻的 Mirko 把火柴扔的到处都是。他的母亲希望他将火柴放入盒子中。
题目描述

Mirko 现在要放置 nnn 根火柴，他有一个 w×hw\times hw×h 的矩形盒子。

他现在想请你进行判断这 nnn 根火柴每一个是否能够放入这个盒子。

我们可以把盒子看成一个平面，只需要判断火柴是否能够在这个平面内放下即可。
输入格式

输入第一行为三个整数 n,w,hn,w,hn,w,h。

接下来的 nnn 行，每行一个 [1,1000][1,1000][1,1000] 区间内的整数，表示一根火柴的长度。
 输出格式

输出共 nnn 行，对于每根火柴，输出 DA 表示能放下，否则输出 NE 表示放不下。
输入输出样例
输入 #1

5 3 4
3
4
5
6
7

输出 #1

DA
DA
DA
NE
NE

输入 #2

2 12 17
21
20

输出 #2

NE
DA

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 1≤n≤501\le n\le 501≤n≤50，1≤w,h≤1001\le w,h\le 1001≤w,h≤100。
 说明

题目译自 COCI2006-2007 CONTEST #4 T1 SIBICE

code:
int main(){
    double n,m,k;
    cin>>n>>m>>k;
    for(int i=0;i<n;i++){
        double p;
        cin>>p;
        if(sqrt(m*m+k*k)>=p) cout << "DA"<<endl;
        else cout<<"NE"<<endl;
    }
    return 0;
}

*/

/*
P6321 [COCI2006-2007#4] SKENER

题目背景

Mirko 在拿放大镜看杂志。
题目描述

他正在看一面 rrr 行 ccc 列的杂志。放大镜有两个参数 zr,zczr,zczr,zc，表示把每个字符都转换成一个 zrzrzr 行 
 czczc 列的矩阵。

给出原始杂志，请你帮他找出杂志在放大镜下的影像。
输入格式

输入第一行四个整数 r,c,zr,zcr,c,zr,zcr,c,zr,zc。

接下来的 rrr 行，每行 ccc 个字符。字符可能为数字，字母或 .。
输出格式

输出一个 r×zrr\times zrr×zr 行，c×zcc\times zcc×zc 列的矩阵，表示放大镜下的影像。
 输入输出样例 输入 #1

3 3 1 2
.x.
x.x
.x.

输出 #1

..xx..
xx..xx
..xx..

输入 #2

3 3 2 1
.x.
x.x
.x.

输出 #2

.x.
.x.
x.x
x.x
.x.
.x.

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 1≤r,c≤501\le r,c\le 501≤r,c≤50，1≤zr,zc≤51\le zr,zc\le 51≤zr,zc≤5。
 说明

题目译自 COCI2006-2007 CONTEST #4 T2 SKENER

code:
int main(){
    int r,c,zr,zc;
    cin>>r>>c>>zr>>zc;
    char a[r][c]={};
    for(int i=0;i<r;i++)for(int j=0;j<c;j++)cin>>a[i][j];
    for(int i=0;i<r;i++){
    for(int m=0;m<zr;m++){
        for(int j=0;j<c;j++)
            for(int l=0;l<zc;l++)cout<<a[i][j];
        cout<<endl;
        }
    }
    return 0;
}

*/

/*
P6330 [COCI2007-2008#1] CETVRTA

题目描述

给出坐标系中一个矩形的三个顶点的坐标，请你确定第四个顶点的坐标并输出。

保证矩形的边与坐标轴平行。
输入格式

共 333 行，每行两个 1?10001\sim 10001?1000 之间的整数（含端点），表示这个矩形
个顶点的坐标。 输出格式

输出一行两个整数，表示第四个顶点的坐标。
输入输出样例
输入 #1

5 5
5 7
7 5

输出 #1

7 7

输入 #2

30 20
10 10
10 20

输出 #2

30 10

说明/提示
说明

题目译自 COCI2007-2008 CONTEST #1 T1 CETVRTA

code:
int main(){
    int a[3][2]={0};
    for(int i=0;i<3;i++)for(int j=0;j<2;j++)cin>>a[i][j];
    for(int i=0;i<2;i++){
        if(a[0][i]==a[1][i])cout<<a[2][i]<<" ";
        else if(a[0][i]==a[2][i])cout<<a[1][i]<<" ";
        else cout<<a[0][i]<<" ";
    }
    return 0;
}

*/

/*
P6337 [COCI2007-2008#2] CRNE

题目描述

在一个矩形棋盘上，切与矩形的边平行的 nnn 次，问最多棋盘能被切成多少块？
输入格式

输入一行一个整数 nnn。
输出格式

输出一行一个整数表示棋盘最多被分成的块数。
输入输出样例
输入 #1

1

输出 #1

2

输入 #2

3

输出 #2

6

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 1≤n≤1001\le n\le 1001≤n≤100。
说明

题目译自 COCI2007-2008 CONTEST #2 T2 CRNE。

code:
int main(){
    int n,m=2,sum=0;
    cin>>n;
    for(int i=1;i<=n;i++){
        if((i%2==0) && (i!=2))m++;
        sum+=m;
    }
    cout<<sum;
    return 0;
}

*/

/*
P6352 [COCI2007-2008#3] CETIRI

题目描述

你原本有 444 个数，它们从小到大排序后构成了等差数列。

但是现在丢失了一个数，并且其余的三个数的顺序也被打乱了。

请你找出第四个数。
输入格式

输入一行三个整数。保证这些数字在 ?100?100-100\sim 100?100?100 之间。
输出格式

输出一行一个数，为第四个数。

方案可能不是唯一的，但保证一定存在，本题使用SPJ。
输入输出样例
输入 #1

4 6 8

输出 #1

10

输入 #2

10 1 4

输出 #2

7

说明/提示
说明

题目译自 COCI2007-2008 CONTEST #3 T1 CETIRI。

code:
int main(){
    int a[3];cin>>a[0]>>a[1]>>a[2];
    sort(a,a+3);
    int c1=a[1]-a[0],c2=a[2]-a[1];
    printf("%d",c1==c2?a[2]+c1:(c1>c2?a[1]-c2:a[2]-c1));
    return 0;
}

*/

/*
P6367 [COCI2006-2007#6] PRASE

题目描述

孩子们正在餐桌旁吃午餐，共有 nnn 份食物，孩子们会按照从 111 至 nnn 的顺序依次取走这 nnn 份食物。



当某个孩子取走了一份食物时，如果这个他之前已经取走的食物份数（不包括当前这一份）比其他人取走的食物份数之和还要多，那么他的妈妈就会提醒他注意自己不礼貌的行为。注意，虽然被妈妈提醒了，但是他仍然会取走这份食物。换句话说，妈妈的提醒对孩子的行为没有任何影响。

给定 nnn 份食物分别被哪个孩子取走了，请求出妈妈们一共提醒了多少次。
输入格式

第一行是一个整数，代表食物的份数 nnn。

第 222 到第 (n+1)(n + 1)(n+1) 行，每行一个字符串，第 (i+1)(i + 1)(i+1) 行的字符串 sis_isi? 表示取走第 iii 份食
 的孩子的名字。 输出格式

输出一行一个整数表示答案。
输入输出样例
输入 #1

4
mirko
stanko
stanko
stanko

输出 #1

1

输入 #2

17
a
b
b
a
a
a
c
a
b
b
c
b
b
b
b
b
b

输出 #2

4

说明/提示
样例 1 解释

当取到第 333 份食物时，stanko 已取走的食物（不包括当前这份）的份
是一份，而其他人也总共取走了一份，所以 stanko 的妈妈不会提醒他注意礼貌。


当取到第 444 份食物时，stanko 已经取走两份食物，其他人总共取走了
份食物，因此妈妈会提醒他。 数据规模与约定

对于全部的测试点，保证：

    1≤n≤1001 \leq n \leq 1001≤n≤100
    1≤OsiO≤201 \leq |s_i| \leq 201≤Osi?O≤20，sis_isi? 中只含小写英文字母。OsiO|s_i|Os
 ?O 表示字符串 sis_isi? 的长度。


说明

题目译自 COCI2006-2007 CONTEST #6 T1 PRASE。

code:
string st[101];
int main(){
    int n,ans=0,num;cin>>n;
    for(int i=0;i<n;i++){
    cin>>st[i];
    num=0;
    for(int j=0;j<i;j++)if(st[i]==st[j])num++;
    if(i-num<num)ans++;
    }
    cout<<ans;

    return 0;
}

*/

/*
P6382 『MdOI R2』Car

题目描述

在 MdOI 市
为了推行环保，在城区内将限制某些车辆的通行，简称限行。一辆车是否被限行的依据是车牌号和当天的日期。

车牌号的编码方式是这样的：

    前三位均为大写字母，表示所在的地区。

    后五位为大写字母或数字，为识别码。保证至少有一个数字。

    车牌号的尾号是从右往左的第一个数字。

MdOI 市在本题的编码方式下前三位是 MDA。例如，MdOI 市有一辆识别码为 6780P 的车，它的车牌号就是 MDA6780P，尾号是 000。



在 MdOI 市，限行规则如下：

    对于外来车（即前三位编号非 MDA），工作日（星期一至星期五）均限行。
    对于其他本地车，每天会限行某些尾号的汽车。星期一至星期五的限行尾号如下：

日期 	星期一 	星期二 	星期三 	星期四 	星期五
限行尾号 	111 和 999 	222 和 888 	333 和 777 	444 和 666 	555 和 000



小 C 告
了你她的车牌号，她想知道，她的车在星期一到星期五中的哪些日期会被限行。请你帮帮她。
输入格式

一行一个长度为 888 的字符串，表示小 C 的车牌号。
输出格式

输出 555 个数字，每个数字为 000 或 111，分别表示星期一至星期五小 C 的车是否被限行。111 表示限行，000 表示不限行。
 输入输出样例 输入 #1

MDA7U16D

输出 #1

0 0 0 1 0

输入 #2

ZJOI2020

输出 #2

1 1 1 1 1

说明/提示

【帮助与提示】

为方便选手调试代码，本题额外提供三组样例。由于样例较小，故放在一个剪贴板内。

附加样例

【样例解释】

对于样例一，这个车牌号前三位为 MDA，因此是本地车牌。而尾号是 666，因此周四被限行。



对于样例二，这个车牌号前三位为 ZJO，是外地车牌，因此周一至周五均被限行。

【数据范围】

本题采用捆绑测试，即通过一个子任务的所有测试点才能拿到对应的分数。
子任务编号 	特殊性质 	分值
Subtask 1 	前 333 位不是MDA 	303030
Subtask 2 	最后一位一定是数字 	303030
Subtask 3 	无 	404040

对于所有数据，满足前三位一定是大写英文字母，后面五位可能包含大写字母或者数字，且至少有一个数字。

code:
int len,s,i;
char ch[10];
int main(){
    scanf("%s",ch);
    if(ch[0]!='M' || ch[1]!='D' || ch[2]!='A') printf("1 1 1 1 1"),exit(0);
    len=strlen(ch);
    for(i=len-1;i>=3;i--){
        if(ch[i]>='0' && ch[i]<='9'){
            s=ch[i]-'0';
            break;
        }
    }
    if(s==1 || s==9) printf("1 0 0 0 0");
    else if(s==2 || s==8) printf("0 1 0 0 0");
    else if(s==3 || s==7) printf("0 0 1 0 0");
    else if(s==4 || s==6) printf("0 0 0 1 0");
    else cout<<"0 0 0 0 1";
    return 0;
}

*/

/*
P6386 [COCI2007-2008#4] VAUVAU

题目描述

在一个小村子里，邮递员、送奶工、垃圾清理工每天早晨都面临着同样的难题：18 号房子的门前有两条看门狗。他们所不知道的是，这两条狗的表现是有迹可循的。



当一天开始时，其中一条狗会先暴躁 aaa 分钟，然后安静 bbb 分钟，而另一条狗则会先暴躁 ccc 分钟，然后安静 ddd 分钟。这两条狗在一天中会无限地

复上述行为。


给定这三个人到达 18 号房子的时刻，请求出该时刻有几条狗是处于暴躁状态的。
输入格式

第一行有四个整数，分别表示 a,b,c,da, b, c, da,b,c,d，其意义见【题目描述】。

第二行有三个整数，分别表示邮递员到达的时刻 ppp，送奶工到达的时刻 mmm 和垃圾清理工到达的时刻 ggg。
 输出格式

输出三行每行一个字符串，依次表示邮递员、送奶工、垃圾清理工到达时有几条狗处于暴躁状态。

    如果没有狗处于暴躁状态，输出 none。
    如果恰好有一条狗处于暴躁状态，输出 one。
    如果两条狗都处于暴躁状态，输出 both。

输入输出样例
输入 #1

2 2 3 3
1 3 4

输出 #1

both
one
none

输入 #2

2 3 4 5
4 9 5

输出 #2

one
none
none

说明/提示
数据规模与约定

对于全部的测试点，保证 1≤a,b,c,d,p,m,g<1031 \leq a, b, c, d, p, m, g \lt 10^31≤a,b,c,d,p,m,g<103
 说明

题目译自 COCI2007-2008 CONTEST #4 T1 VAUVAU。

code:
int main(){
    int a1,a2,b1,b2;
    cin>>a1>>a2>>b1>>b2;
    int time[3]={0};
    cin>>time[0]>>time[1]>>time[2];
    int t=0;
    for(int i=0;i<3;i++){
        t=0;
        if((time[i]%(a1+a2))<=a1 && (time[i]%(a1+a2))!=0)t++;
        if((time[i]%(b1+b2))<=b1 && (time[i]%(b1+b2))!=0)t++;
        if(t==2)cout<<"both"<<endl;
        else if(t==1)cout<<"one"<<endl;
        else if(t==0)cout<<"none"<<endl;
    }
    return 0;
}

*/

/*
P6408 [COCI2008-2009#3] PET

题目描述

在一项受欢迎的比赛「Dinner for Five」中，有 555 名选手和 444 名裁判，这 444 个裁判会对每一道菜用 1?51 \sim 51?5 的数字进行评估，每位选手的总分即是所有

判评分的总和，参赛者按照其评分顺序从 111 到 555 进行编号。



请你编写一个程序，输出评分最高的选手的编号以及其分数。
输入格式

输入共 555 行，每一行有 444 个正整数，表示每位裁判对第 iii 位选手的评分。

输入数据将确保胜者是唯一的。
输出格式

输出仅 111 行，有 222 个正整数，中间有一个空
，分别表示评分最高的选手以及其分数。 输入输出样例 输入 #1


5 4 4 5
5 4 4 4
5 5 4 4
5 5 5 4
4 4 4 5

输出 #1

4 19

输入 #2

4 4 3 3
5 4 3 5
5 5 2 4
5 5 5 1
4 4 4 4

输出 #2

2 17

说明/提示
说明

题目译自 COCI2008-2009 CONTEST #3 T1 PET。

code:
int main(){
    int a[4][5]={0},n=0,m=0,sum;
    for(int j=0;j<5;j++)for(int i=0;i<4;i++)cin>>a[i][j];
    for(int i=0;i<5;i++){
        sum=0;
        for(int j=0;j<4;j++)sum+=a[j][i];
        if(sum>m){n=i;m=sum;}
    }
    cout<<n+1<<" "<<m;
    return 0;
}

*/

/*
P6409 [COCI2008-2009#3] KEMIJA

题目背景

Luka 天天上课走神。
题目描述

Luka 又在化学课上鬼混了！他不是在写平衡方程，而是在写一句奇怪的话。

Luka
通过在每一个元音字母（a\texttt{a}a，e\texttt{e}e，i\texttt{i}i，o\texttt{o}o，u\texttt{u}u）后面加上 p\texttt{p}p 再加上原来的元音字母的方式加密这一个单词，如 kem

ja\texttt{kemija}kemija 变成 kepemipijapa\texttt{kepemipijapa}kepemipijapa， papri
 a\texttt{paprika}paprika 变成 pap
pripikapa\texttt{papapripikapa}papapripikapa 。



老师想知道调皮的 Luka 写了些什么，请你帮助老师，写出一个解密程序。
输入格式

一行一个字符串 sss，表示加密后的句子，
据保证不会有前导空格与尾随空格，但句子中间可能出现空格。
输出格式

一行一个字符串，表示解密后的句子。
输入输出样例
输入 #1

zepelepenapa papapripikapa

输出 #1

zelena paprika

输入 #2

bapas jepe doposapadnapa opovapa kepemipijapa

输出 #2

bas je dosadna ova kemija

说明/提示
数据范围

令 OsO|s|OsO 为 sss 的长度，则 1≤OsO≤1001 \leq |s| \leq 1001≤OsO≤100，数据保证字符串的内容一定是小写字
 或空格。 说明

题目译自 COCI2008-2009 CONTEST #3 T2 KEMIJA。

code:
int main(){
    char ch;
    while(ch=getchar()){
        if(ch=='\n')break;
        putchar(ch);
        if(ch=='a' || ch=='e' || ch=='i' || ch=='o' || ch=='u')
            getchar(),getchar();
    }
    return 0;
}

*/

/*
P6420 [COCI2008-2009#2] KORNISLAV

题目描述

乌龟 Kornislav 从来没有什么有趣的事。 由于他将生活三百年，他一直在努力寻找消磨时间的方法

 这个周末，他开始玩“面积最大的矩形”这个游戏。 首先，Kornislav 需要四个正整数。他通过向一个方向移动，旋转 90°90°90° ，在新方向上行走

方式来形成一个图案。Kornislav 总共进行了三个 90°90°90° 旋转，并走过了四条线段。 当朝某个方向行走时，他的步数必须等于四个所选整数中的一个，并且每个整数只能

为一条线段的长度。根据 Kornislav 使用这四个整数的顺序，他的步行将形成各种形
，其中也包括一些未封闭的图案。 编写一个程序，计算出乌龟的行进轨
 可以形成的最大矩形面积。




 输入格式

一行四个整数 a,b,c,da,b,c,da,b,c,d，表示 Kornislav 挑选的四个整数。
输出格式

一行一个整数，表示 Kornislav 的行进轨迹所能形成的最大矩形面积。
输入输出样例
输入 #1

1 2 3 4

输出 #1

3

输入 #2

4 4 3 4

输出 #2

12

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，有 1<a,b,c,d<1001<a,b,c,d<1001<a,b,c,d<100。
说明
题目译自 COCI2008-2009 CONTEST #2 KORNISLAV，译者 @mnesia。
附件下载
contest2_tasks.pdf 101.88KB

code:
int main(){
    int a[4]={0};
    for(int i=0;i<4;i++)cin>>a[i];
    sort(a,a+4);
    cout<<a[0]*a[2];
    return 0;
}

*/

/*
P6421 [COCI2008-2009#2] RESETO

题目描述

埃拉托色尼筛法是一种著名的素数筛法，可以查找所有直至 nnn 的素数。该算法的步骤是：



    写下 222 到 nnn 之间的所有整数（包括 222 和 nnn）。
    找到尚未删除的最小数，并将其命名为 ppp； 则 ppp 是素数。
    划掉 ppp 及其所有尚未划掉的倍数。
    如果尚有数未被划掉，请转到步骤 222。

编写一个程序，给定 nnn 和 kkk，找出第 kkk 个被删除的整数。
输入格式

一行两个整数 nnn 和 kkk，其具体含义请见题目描述。
输出格式

一行一个整数，表示第 kkk 个被划掉的整数。
输入输出样例
输入 #1

7 3

输出 #1

6

输入 #2

15 12

输出 #2

7

输入 #3

10 7

输出 #3

9

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，有 2≤k<n≤10002 \leq k < n \leq 10002≤k<n≤1000。
说明
题目译自 COCI2008-2009 CONTEST #2 RESETO，译者 @mnesia。
附件下载
contest2_tasks.pdf 101.88KB

code:
int main(){
    bool s[1001]={0};
    int n,k,w=0;
    cin>>n>>k;
    for(int i=2;i<=n;i++){
        if(s[i]==false)
            for(int j=i;j<=n;j+=i)
            if(s[j]==false){
                w++;
                s[j]=true;
                if(w==k){
                    cout<<j;
                    return 0;
                }
            }
    }
    return 0;
}

*/

/*
P6426 [COCI2008-2009#1] SKOCIMIS

题目描述

三只袋鼠在沙漠里的一条数轴上玩耍，每只袋鼠都占据一个不同的整数点。在一次移动中，一只袋鼠跳进另两只袋鼠之间的空间。两只袋鼠决不能占据同一位置。

请让它们尽可能久地玩耍。
输入格式

三个整数 A,B,CA,B,CA,B,C，表示三只袋鼠最初的位置。
输出格式

输出袋鼠们最多能移动的次数。
输入输出样例
输入 #1

2 3 5

输出 #1

1

输入 #2

3 5 9

输出 #2

3

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，0<A<B<C<1000 < A < B < C < 1000<A<B<C<100。
说明
题目译自 COCI2008-2009 CONTEST #1 SKOCIMIS，译者 @mnesia。

code:
int main(){
        int a,b,c;cin>>a>>b>>c;
        cout<<max(b-a,c-b)-1;
        return 0;
}

*/

/*
P6443 [COCI2010-2011#1] TIMSKO

题目描述

有一所大学每年都会举办一场信息学竞赛，竞赛中，每支队伍由 111 名男生和 222 名女生组成。一所学院的院长为了减少对手，把其他对手安排在一个遥远的国家进行实习，被派去实习的对手将无法参加比赛。所有选手中，女

选手的数量为 mmm，男性选手的数量为 nnn，可以派去实习的对手数量为 kkk。院长必须创建能参加比赛的队伍。你的任务是输出可以创建的最大团队数。


 输入格式

输入数据共一行。

一行三个整数，m,n,km,n,km,n,k，含义如题所示。
输出格式

输出数据共一行。

一行一个整数，ansansans，表示可以组成的最大团队数。
输入输出样例
输入 #1

6 3 2

输出 #1

2

输入 #2

2 1 1

输出 #2

0

输入 #3

6 10 3

输出 #3

3

说明/提示

样例输入输出 1 解释

院长就可以派一男一女去实习，这样就变成了：m=5m=5m=5，n=2n=2n=2，分成两队（一个女生没有队伍），所以答案为 222。



数据规模与约定

对于 100%100\%100% 的数据，0≤n,m≤1000 \leq n,m \leq 1000≤n,m≤100，0≤k≤m+n0 \leq k \leq m+n0≤k≤m+n。



说明

题目译自 COCI2010-2011 CONTEST #1 T1 TIMSKO。

code:
int main(){
    int w,m,out;cin>>w>>m>>out;
    int team=0;
    while(w+m>out){
        w-=2;m--;
        if(w>=0 && m>=0 && (w+m>=out))team++;
        else break;
    }
    cout<<team;
    return 0;
}

*/

/*
P6461 [COCI2006-2007#5] TRIK

题目描述

有三个杯口朝下的杯子，其中有一个小球在最左边的杯子下。

接下来，对这三个杯子进行一系列的换位操作，操作用一个字符串来表示，其中 A B C 分别对应了上图所示的三种换位方式。



你需要找出最终小球在哪个杯子下面。
输入格式

输入一行一个字符串，表示操作的顺序，保证操作数不超过 505050 ，且每个字母都为 A B C 中的一种，无空格。
 输出格式

输出一行一个整数：

    如果球在左边的杯子下：输出 111；
    如果球在中间的杯子下：输出 222；
    如果球在右边的杯子下：输出 333。

输入输出样例
输入 #1

AB

输出 #1

3

输入 #2

CBABCACCC

输出 #2

1

说明/提示
说明

题目译自 COCI2006-2007 CONTEST #5 T1 TRIK。

code:
int main(){
    char code;
    bool cap[4]={1,0,0,0};
    while(cin>>code){
        if(code=='\n')break;
        else if(code=='A'){
            cap[3]=cap[0];
            cap[0]=cap[1];
            cap[1]=cap[3];
        }
        else if(code=='B'){
            cap[3]=cap[1];
            cap[1]=cap[2];
            cap[2]=cap[3];
        }
        else if(code=='C'){
            cap[3]=cap[0];
            cap[0]=cap[2];
            cap[2]=cap[3];
        }
    }
    for(int i=0;i<3;i++)
        if(cap[i]==1)cout<<i+1;
    return 0;
}

*/

/*
P6488 [COCI2010-2011#6] OKUPLJANJE

题目描述

一场巨大的派对结束以后，有五家报纸刊登了参加这场派对的人数，然而这些报纸上的数字可能是错误的。

现在你知道整个会场的面积是 LLL 平方米，并且平均每平方米上有 ppp 个人。现在请分别求出这五家报纸刊登的参加人数与实际参加人数之差。
 输入格式

输入的第一行有两个整数，分别表示会场面积 LLL 和平均每平方米的人数 ppp。

第二行有五个整数 a1…a5a_1 \dots a_5a1?…a5?，分别表示五家
纸刊登的人数。 输出格式

输出一行五个整数，依次表示每家报纸刊登人数与实际人数之差。
输入输出样例
输入 #1

1 10
10 10 10 10 10

输出 #1

0 0 0 0 0

输入 #2

5 20
99 101 1000 0 97

输出 #2

-1 1 900 -100 -3

说明/提示
数据规模与约定

对于全部的测试点，保证 1≤L,p≤1091 \leq L, p \leq 10^91≤L,p≤109，1≤ai≤10181 \leq a_i \leq 10^{18}1≤ai?≤1018。
 说明

题目译自 COCI2010-2011 CONTEST #6 T1 OKUPLJANJE，翻译来自 @一扶苏一，数据范围略有修改。

code:
int main(){
    long long n,m;cin>>n>>m;
    n=n*m;
    for(int i=0;i<5;i++){
        cin>>m;
        cout<<m-n<<" ";
    }
    return 0;
}

*/

/*
P6489 [COCI2010-2011#6] USPON

题目背景

Tomislav 去爬山。
题目描述

他所走的山路可以看做一个长度为 nnn 的数字序列 PiP_iPi?，PiP_iPi? 表示位置 iii 的高度为 PiP_iPi?。



从低处往高处走一段连续的高度严格递增的山路称为一次爬升。

为了锻炼身体，他想走一段落差尽量大的爬升。

一段山路的落差定义为这段山路的结束点与起始点的差。

你需要求出他走一段山路所能达到最大的落差是多少。
输入格式

输入第一行一个整数 nnn，表示山路的长度。

第二行 nnn 个整数 PiP_iPi?，表示位置 iii 的高度为 PiP_iPi?。
输出格式

输出一行一个整数，表示最大的落差。

如果整条山路不包含任何的爬升，则输出 0。
输入输出样例
输入 #1

5
1 2 1 4 6

输出 #1

5

输入 #2

8
12 20 1 3 4 4 11 1

输出 #2

8

输入 #3

6
10 8 8 6 4 3

输出 #3

0

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，保证 1≤n≤10001\le n\le 10001≤n≤1000，1≤Pi≤10001\le P_i\le 10001≤Pi?≤1000。
 说明

题目译自 COCI2010-2011 CONTEST #6 T2 USPON。

code:
int main(){
    int n,sum=0;cin>>n;
    int a[n];
    for(int i=0;i<n;i++)cin>>a[i];
    for(int i=0;i<n;i++)
    for(int j=i+1;j<n;j++){
        if(a[j-1]>=a[j])break;
        else if(sum<(a[j]-a[i]))sum=a[j]-a[i];
    }
    cout<<sum;
    return 0;
}

*/

/*
P6500 [COCI2010-2011#3] ZBROJ

题目描述

老师给了 Perica 两个数 a,ba, ba,b，Perica 将他们抄在了笔记本上，并要算出
们的和。

在抄写过程中，Perica 可能会将 a,ba, ba,b 中的数字 666 错抄成数字 555，也可能将数字 555 错抄成数字 666，当然也可能不抄错。



给定 a,ba, ba,b，请求出 Perica 算出的和最小和最大分别是多少。
输入格式

输入只有一行两个整数，分别表示 aaa 和 bbb。
输出格式

输出一行两个整数，表示最小可能的和以及最大可能的和。
输入输出样例
输入 #1

11 25

输出 #1

36 37

输入 #2

1430 4862

输出 #2

6282 6292

输入 #3

16796 58786

输出 #3

74580 85582

说明/提示
数据规模与约定

对于全部的测试点，保证 1≤a,b≤1061 \leq a, b \leq 10^61≤a,b≤106。
说明

题目译自 COCI2010-2011 CONTEST #3 T2 ZBROJ。

code:
int main(){
    int a,b,s1,s2;
    cin>>a>>b;
    for(int s=1,x=a;x;x/=10,s*=10)
        if(x%10==5)s1+=s;
        else if(x%10==6)s2+=s;
    for(int s=1,y=b;y;y/=10,s*=10)
        if(y%10==5)s1+=s;
        else if(y%10==6)s2+=s;
    cout<<a+b-s2<<" "<<a+b+s1;
    return 0;
}

*/

/*
P6529 [COCI2015-2016#1] KARTE

题目描述

这里有一堆牌，可惜它们似乎不全。

您需要找出每种花色缺失的张数。

如果有相同的扑克牌，请输出 GRESKA。
输入格式

您要读取的是一个字符串 sss，每三个字符为一张扑克牌。

对于每一张扑克牌：

    第一位为花色，用 P，K，H，T 表示，且输出也是这个顺序。
    接下来两位，为这张牌的点数，个位数会在十位补零。

输出格式

如果有相同的扑克牌，请输出 GRESKA。

否则按 P，K，H，T 的顺序，输出该花色缺的牌数。
输入输出样例
输入 #1

P01K02H03H04

输出 #1

12 12 11 13

输入 #2

H02H10P11H02

输出 #2

GRESKA

输入 #3

P10K10H10T01

输出 #3

12 12 12 12

说明/提示
【样例解释】
样例 1 解释

有一张花色为 P 的牌，一张花色为 K 的牌，两张花色为 H 的牌。
样例 2 解释

这里有两张 H02 ，所以输出 GRESKA。
【数据范围及限制】

对于 100%100\%100% 的数据，保证 1≤OsO≤1031\le \lvert s\rvert\le 10^31≤OsO≤103 且 sss 中仅含有数字与 P，K，H，T，每张牌的点数 ∈[1,13
 \in [1,13]∈[1,13] 。 【说明】

本题满分 505050 分。

本题译自 Croatian Open Competition in Informatics 2015/2016 Contest #1 T1 KARTE。


code:
int main(){
    string c;cin>>c;
    bool p[13]={0},k[13]={0},h[13]={0},t[13]={0};
    for(int i=0;i<c.length();i+=3)
        if(c[i]=='P') p[int((c[i+1]-48)*10+c[i+2]-49)]=1;
        else if(c[i]=='K') k[int((c[i+1]-48)*10+c[i+2]-49)]=1;
        else if(c[i]=='H') h[int((c[i+1]-48)*10+c[i+2]-49)]=1;
        else t[int((c[i+1]-48)*10+c[i+2]-49)]=1;
    int pt=0,kt=0,ht=0,tt=0;
    for(int i=0;i<13;i++)if(p[i]==0)pt++;
    for(int i=0;i<13;i++)if(k[i]==0)kt++;
    for(int i=0;i<13;i++)if(h[i]==0)ht++;
    for(int i=0;i<13;i++)if(t[i]==0)tt++;
    if(pt+kt+ht+tt==52-c.length()/3)cout<<pt<<" "<<kt<<" "<<ht<<" "<<tt;
    else cout<<"GRESKA";
    return 0;
}

*/

/*
P6565 [NOI Online #3 入门组] 最急救助

题目描述

救助中心每天都要收到很多求救信号。收到求救信号后，救助中心会分析求救信号，找出最紧急的求救者给予救助。

求救信号是一个由小写英文字母组成的字符串，字符串中连续三个字符依次组成sos的情况越多（即包含子串sos的数目越多），代表着求救者情况越紧急。

现在请你帮助救助中心找出最紧急的求救者。注意字符串中包含的sos可以有重叠，例如sosos算作包含 222 个sos。
 输入格式

从标准输入读入数据。

第一行一个整数 nnn，表示求救者的数目。

接下来有 2×n2\times n2×n 行，每行一个由小写英文字母组成的字符串。这 2×n2\times n2×n 行中，第 2×i?12\times i-12×i?1（1≤i≤n1\le i\le n1≤i≤
）行的字符串表示第 iii 个求救者的名字，第 2×i2\times i2×i 行的字符串表示第 iii 个求救者的求救信号。

输出格式

输出到标准输出。

输出共两行，第一行是最紧急求救者的名字。如果最紧急求救者有多个，则按照输入的顺序将他们的名字依次输出，相邻两个名字间用空格分隔。

第二行一个整数，表示最紧急求救者的求救信号中包含有多少个sos子串。
输入输出样例
输入 #1

2
adam
ineedhelpsosineedhelpsos
mark
ineedmorehelpsoshelpmesossoshelpme

输出 #1

mark
3

输入 #2

3
susan
sosososososos
jack
sossossossos
allen
soshelpsossossossossos

输出 #2

susan allen
6

说明/提示
数据规模与约定

    对于 10%10\%10% 的数据，n=1n=1n=1。
    对于所有数据，1≤n≤1001 \leq n\le 1001≤n≤100，求救者名字长度不超过 202020，求救信号长度不超过 200200200。


code:
int main(){
    int n,ans=0;cin>>n;
    string name[n],s[n],q;
    int cnt[n]={0};
    for(int i=0;i<n;i++){
        cnt[i]=0;
        cin>>name[i]>>s[i];
        for(int j=2;j<=s[i].size();j++){
            q=s[i][j-2]+s[i][j-1]+s[i][j];
            if(s[i][j-2]=='s'&&s[i][j-1]=='o'&&s[i][j]=='s')
            cnt[i]++;
        }
        ans=max(ans,cnt[i]);
    }
    for(int i=0;i<n;i++)
        if(cnt[i]==ans)
            cout<<name[i]<<" ";
    cout<<endl<<ans<<endl;
    return 0;
}

*/

/*
P6685 可持久化动态仙人掌的直径问题

题目背景

众所周知，一场考试需要一道签到题。
题目描述

给定 n,mn,mn,m，求有多少个正整数 xxx，使得 xm≤nx^m\le nxm≤n。
输入格式

一行两个正整数 n,mn,mn,m。
输出格式

一个整数表示正整数 xxx 的个数。
输入输出样例
输入 #1

5 2

输出 #1

2

说明/提示

对于 25%25\%25% 的数据满足 m=1m=1m=1；
对于 50%50\%50% 的数据满足 n≤106n\le 10^6n≤106；
对于 100%100\%100% 的数据满足 1≤n,m≤1091\leq n,m\le 10^91≤n,m≤109。

code:
int main(){
    long long n,m,x=1,t=0;
    cin>>n>>m;
    while(pow(x,m)<=n){
    t++;x++;
    }
    cout<<t;
    return 0;
}

*/

/*
P6723 [COCI2015-2016#5] ZAMKA

题目描述

给定三个整数 L,D,XL,D,XL,D,X，你需要找到两个整数 N,MN,MN,M，使得：

    NNN 为满足条件的最小整数，L≤N≤DL\le N\le DL≤N≤D 且 NNN 的各位数字之和为 XXX；
 MMM 为满足条件的最大整数，L≤M≤DL\le M\le DL≤M≤D 且 MMM 的各位数字之和为 XXX。



保证 N,MN,MN,M 一定存在。
输入格式

输入共三行。

第一行一个整数 LLL，第二行一个整数 DDD，第三行一个整数 XXX。
输出格式

输出共两行。

第一行为一个整数 NNN，第二行为一个整数 MMM。
输入输出样例
输入 #1

1
100
4

输出 #1

4
40

输入 #2

100
500
12

输出 #2

129
480

输入 #3

1
10000
1

输出 #3

1
10000

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，1≤L≤D≤1041\le L\le D\le 10^41≤L≤D≤104，1≤X≤361\le X\le 361≤X≤36。
 说明

题目译自 COCI2015-2016 CONTEST #5 T1 ZAMKA。

code:
int math(int a){
    int b=0;
    while(a){
        b+=a%10;
        a/=10;
    }
    return b;
}
int main(){
    int a,b,c,t=0;cin>>a>>b>>c;
    for(int i=a;i<=b;i++)if(math(i)==c){cout<<i<<endl;break;}
    for(int i=b;i>=a;i--)if(math(i)==c){cout<<i<<endl;break;}
    return 0;
}

*/

/*
P6745 『MdOI R3』Number

题目描述

生活中我们会碰到一些特殊数字，这些数字使用一些特殊表达方式后会方便记忆和使用。比如说，109+710^9+7109+7 就非常常见――它相比于 100000000710000000071000000007，更方便选手看清数字而不必数 000，而且没有科学计数法的精度损失。





你现在有一个形如 10k+x10^{k}+x10k+x 的数字，请还原成一般写法。
输入格式

一行两个整数 k,xk,xk,x。
输出格式

一行一个整数表示 10k+x10^k+x10k+x。
输入输出样例
输入 #1

9 7

输出 #1

1000000007

说明/提示

【样例解释】

109+7=100000000710^9+7=1000000007109+7=1000000007。

更多样例请到这里领取。

【数据范围】

本题采用捆绑测试，换言之，你只有通过一个子任务的所有测试点，才可以拿到该子任务对应分数。
子任务编号 	x<x<x< 	k≤k\lek≤ 	特殊性质 	分值
1 	101010 	999 		12
2 	101010 	500500500 		15
3 	101810^{18}1018 	181818 		8
4 	101810^{18}1018 	500500500 	k≥18k\ge18k≥18 	25
5 	101810^{18}1018 	500500500 		40

对于所有数据，0≤x<10180\le x<10^{18}0≤x<1018，0≤k≤5000\leq k\leq 5000≤k≤500。

code:
int main(){
    int k;long long x;
    char ord[15];
        cin>>k>>x;
        if(k<=18)
                printf("%lld",x+(long long)pow(10ll,k));
        else{
                sprintf(ord,"1%%0%dlld",k);
                printf(ord,x);
        }
    return 0;
}
//这题不会 做个记录

*/

/*
P6832 [Cnoi2020]子弦

题目描述

Cirno 有一个字符串 S\texttt{S}S，并希望你能求出 S\texttt{S}S 出现次数最多的非空子串的出现次数，记作 ppp。
 输入格式

一行，一个字符串 S\texttt{S}S。
输出格式

一行，一个整数 ppp。
输入输出样例
输入 #1

abababab

输出 #1

4

说明/提示
数据范围与约定

对于 100%100\%100% 的数据保证: 0<OSO≤1070< |\texttt{S}| \le 10^70<OSO≤107，Sx∈[a
z]\texttt{S}_x\in[\texttt{a},\texttt{z}]Sx?∈[a,z]。
子任务「本题采用捆绑测试」

    Subtask1（40%40\%40%）：OSO≤100|\texttt{S}| \le 100OSO≤100。
    Subtask2（40%40\%40%）：OSO≤105|\texttt{S}| \le 10^5OSO≤105。
    Subtask3（20%20\%20%）：无特殊限制。

名词解释

    子串：字符串中任意个连续的字符组成的子序列称为该串的子串。


code:
int main(){
    string s;
    int a[30]={0},ans=0;
    cin>>s;
    for(int i=0;i<s.length();i++)a[s[i]-'a']++;
    for(int i=0;i<=25;i++)ans=max(ans,a[i]);
    cout<<ans<<endl;
    return 0;
}

*/

/*
P6850 NOI

题目背景

小 L 是一个菜鸡。

啥也不会的小 L 上了 NOI 考场。
题目描述

由于小 L 不会算数，现在小 L 告诉了你他每题的分数和队线，请你告诉他是否进队。

NOI 分数的计算方式是：

    笔试基础有 505050 分，每通过一题加 111 分。
    实际得分是每题的分数加上笔试的分数。
    如果是 A 类，总分在此基础上再加 555 分。

输入格式

输入 999 个数 a,b,c,d
e,f,g,h,ia,b,c,d,e,f,g,h,ia,b,c,d,e,f,g,h,i，分别表示笔试通过题数, D1T1,D1T2,D1T3,D2T1,D
T2,D2T3 得分，是否 A 类（是 111，不是 000），集训队分数线。
 输出格式

输出一行一个字符串。

如果进了集训队，则输出 AKIOI。

如果没进，输出 AFO。
输入输出样例
输入 #1

50 50 72 56 100 40 0 1 446

输出 #1

AFO

输入 #2

50 95 100 64 100 72 30 0 446

输出 #2

AKIOI

说明/提示
「样例解释」

样例第一个是退役菜鸡小 L 的 NOI2020 成绩。

第二个是某位队爷的 NOI2020 成绩。

这不是啥都没解释吗
「数据范围与说明」

本题采用捆绑测试。仅有通过某个 Subtask 中所有测试点才能获得该 Subtask 的分数。

    Subtask 1(30 points)：h=0h = 0h=0，a=50a = 50a=50，i=700i = 700i=700；
    Subtask 2(30 points)：h=0h = 0h=0，a=50a = 50a=50；
    Subtask 3(40 points)：无特殊限制。

对于所有数据，0≤a≤500\leq a \leq 500≤a≤50，0≤b,c,d,e,f,g≤1000\leq b,c,d,e,f,g \leq 1000≤b,c,d,e,f,g≤100，0
 h≤10 \leq h \leq 10≤h≤1，205≤i≤705205\leq i \leq 705205≤i≤70
。


此处不考虑第 505050 名同分的情况，可以认为如果同分小 L 优先。

不保证测试数据为真实成绩。

code:
int main(){
    int s,x=0;
        cin>>s;
    s+=50;
    for(int i=0;i<6;i++){
        cin>>x;
        s+=x;
    }
    cin>>x;
    if(x) s+=5;
    cin>>x;
    if(s>=x) cout<<"AKIOI";
    else cout<<"AFO";
    return 0;
}

*/

/*
P6866 [COCI2019-2020#5] Emacs

题目描述

给定一个 n×mn\times mn×m 的只含有 . 和 * 的矩阵。

矩阵中 * 形成一些不重叠的长方形。它们不在边缘或顶点接触。

求长方形有多少个？
输入格式

第一行：两个正整数 nnn 和 mmm。

以下 nnn 行：表示题目描述中的矩阵。矩阵只含有 . 和 *。
输出格式

一行一个非负整数，你的答案。
输入输出样例
输入 #1

6 7
***....
***..**
.....**
.***.**
.***...
.***...

输出 #1

3

输入 #2

3 3
*.*
...
*.*

输出 #2

4

输入 #3

1 10
.*.**.***.

输出 #3

3

说明/提示
数据范围

    对于 10pts10 pts10pts 的数据，矩阵中每个长方形只含一个 *。
    对于另外 15pts15 pts15pts 的数据，保证 n=1n=1n=1。
    对于所有的数据，1≤n,m≤1001\leq n,m\leq 1001≤n,m≤100。

说明

题目译自 COCI2019-2020 CONTEST #5 T1 Emacs ，译者 90693。

code:
int main(){
    char a[102][102];
    memset(a,'.',sizeof(a));
    int n,m,ans=0;
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
            if(a[i][j]=='*'&&a[i-1][j]=='.'&&a[i][j-1]=='.')
                ans++;
        }
    cout<<ans;
    return 0;
}

*/

/*
P6882 [COCI2016-2017#3] Imena

题目描述

单词是由大写或小写字母组成的字符串。特别的，末尾也可以是标点符号（.,?,!）。名字是 有且仅有首字母为大写字母 的单词。



句子是由一些单词组成的字符串，并且最后一个字符是标点符号（.,?,!） 。

给定 NNN 个句子，Mirko 想让你统计每个句子中分别有多少个名字。
输入格式

第一行包含一个正整数 NNN，表示句子的个数。

第二行包含这 NNN 个句子。这些句子的字符总数不会超过 10310^3103。
输出格式

包含 NNN 行，每行一个正整数。第 iii 行表示第 iii 个句子的名字总数。
输入输出样例
输入 #1

1
Spavas li Mirno del Potro Juan martine?

输出 #1

4

输入 #2

2
An4 voli Milovana. Ana nabra par Banana.

输出 #2

1
2

说明/提示
样例解释
样例 2 解释

第一个句子中的名字有 Milovana，共 111 个；第二个句子中的名字有 Ana,Banana，共 222 个。注意第一个句子中，尽管 An4 的开头是一个大写字母，但它包含了一个数字，所以不是一个名字



 数据规模与约定

对于 40%40\%40% 的数据，满足 N=1N=1N=1。

对于 100%100\%100% 的数据，满足 1≤N≤51\le N \le 51≤N≤5。
说明

题目译自 COCI2016-2017 CONTEST #3 T1 Imena。

code:
int main(){
    char c;
    int ans=0,n;
    cin>>n;
    while(n){
        c=getchar();
        if(c>='A'&&c<='Z'){
            bool pd=1;
            c=getchar();
            while(c!=' '&&c!='.'&&c!='?'&&c!='!'){
                if(c<'a'||c>'z'){
                    pd=0;
                    break;
                }
                c=getchar();
            }
            if(pd)ans++;
        }
        if(c=='.'||c=='!'||c=='?'){
            n--;
            cout<<ans<<endl;
            ans=0;
        }
    }
    return 0;
}

*/

/*
P7001 [NEERC2013]Fraud Busters

题目描述

The number of cars in Default City that travel to the city center daily vastly
exceeds the number of available parking spots. The City Council had decided to
introduce parking fees to combat the problem of overspill parking on the city
streets. Parking fees are enforced using an automated vehicle registration plate
scanners that take a picture of the vehicle registration plate, recognize the
sequence of digits and letters in the code on the plate, and check the code
against a vehicle registration database to ensure that parking fees are
dutifully paid or to automatically issue a fine to the vehicle owner otherwise.

As soon as parking fees were introduced, a parking fee fraud had appeared. Some
vehicle owners had started to close one or several digits or letters on their
vehicle registration plate with pieces of paper while they park, thus making it
impossible for the current version of the automated scanner to recognize their
vehicle's registration code and to issue them a fine.

The Default City Council had instituted the Fraud Busters Initiative (FBI) to
design a solution to prevent this kind of fraud. The overall approach that FBI
had selected is to expand the number of vehicle features that scanners recognize
(including features like vehicle type and color), as well as excluding from the
list any vehicles that are detected to be elsewhere at this time. This
information should help to identify the correct vehicle by narrowing down the
search in the vehicle registration database.

You are working for FBI. Your colleagues had already written all the complex
pieces of the recognition software that analyses various vehicle features and
provides you with a list of registration codes that might potentially belong to
a scanned car. Your task it to take this list and a recognized code from the
license plate (which may be partially unrecognized) and find all the
registration codes that match. 输入格式

The first line of the input file contains 999 characters of the code as
recognized by the scanner. Code that was recognized by the the scanner is
represented as a sequence of 999 digits, uppercase English letters, and
characters ‘×‘(star).` \times ` (star).‘×‘(star). Star represents a digit or a letter th
t scanner could not recognize.

The second line of the input file contains a single integer number n(1≤n≤1000)n (1 
le n \le 1000)n(1≤n≤1000) -- the number of vehicle registration codes from the veh
cle registration database.

The following nnn lines contain the corresponding registration codes, one code
per line. Vehicle registration codes are represented as a sequence of 999 digits
and uppercase English letters. All codes on these nnn lines of the input file
are different. 输出格式

On the first line of the output file write a single integer k(0≤k≤n)k (0 \le k \le
n)k(0≤k≤n) -- the number of codes from the input file that match the code that wa
 recognized by the scanner. The code from the scanner matches the code from th
 database if the characters on all the corresponding positions in the codes a
e equal or the character from the scanner code is ‘×‘.` \times `.‘×‘.

On the following kkk lines write the matching codes, one code per line, in the
same order as they are given in the input file. 题意翻译

给定一个含未知字符的长度为9字符串，未知字符用'*'表示（不含引号）。下面给出n个长度为9字符串，如果下面输入的字符串与一开始输入的字符串除未知部分的其他部分完全相同，则该字符串符合要求。输出符合要求的字符串的数量和每个符合要求的字符串。

举例：假设一开始输入的字符串为A58**52*1,则字符串A58ZS52T1符合要求，而字符串A589992G1不符合要求
输入输出样例
输入 #1

A**1MP19*
4
A001MP199
E885EE098
A111MP199
KT7351TTB

输出 #1

2
A001MP199
A111MP199

说明/提示

Time limit: 1 s, Memory limit: 128 MB.

code:
int main(){
    string c;cin>>c;
    int n,t=0,p=c.length();
    cin>>n;
    string d[n];
    bool m[n]={0};
    for(int i=0;i<n;i++){
        cin>>d[i];
        m[i]=0;
        for(int j=0;j<p;j++){
            if(c[j]!='*' && c[j]!=d[i][j]) break;
            if(j==p-1)m[i]=1;
        }
        if(m[i]==1)t++;
    } 
    cout<<t<<endl;
    for(int i=0;i<n;i++)
        if(m[i]==1)cout<<d[i]<<endl;
}

*/

/*
P7042 「MCOI-03」正方

题目背景

MC 中没有圆。

所以小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 喜欢 Square。
题目描述

给定一个正方形，求有多少个正方形内的点满足与正方形四个顶点划分出来的四块面积的比为 a:b:c:da:b:c:da:b:c:d。四个数不分顺序。



比如如下图所示假设一个点 E 使得分成的四个三角形的面积之比为 a:b:c:da:b:c:da:b:c:d，那么这个点 E 就符合要求。因为不分顺序，所以分出来的比是 d:b

 a:cd:b:a:cd:b:a:c 也可以。但是点 E 不是唯一解，你要输出的是解的个数。


因为小 S 和小 Q 和小 U 和小 A 和小 R 和小 E 很喜欢询问，所以本题给定了 qqq 组询问。
 输入格式

第一行一个整数 qqq 代表询问个数。
接下来 qqq 行每行四个整数 a,b,c,da,b,c,da,b,c,d。
输出格式

qqq 行每行一个整数代表答案。
输入输出样例
输入 #1

3
1 3 3 1
2 4 7 8
2 3 1 4

输出 #1

4
0
8

说明/提示
数据规模与约定

对于 20%20\%20% 的数据，a=b=c=da=b=c=da=b=c=d。
对于 100%100\%100% 的数据，1≤a,b,c,d≤9×10181 \le a,b,c,d \le 9 \times 10^{18}1≤a,b,c,d
 9×1018，1≤q≤1001 \le q \le 1001≤q≤100，不保证 a:b:c:da:b:c:da:b:
:d 为最简比，不保证 a,b,c,da b,c,da,b,c,d 为升序。

code:#include<bits/stdc++.h>
using namespace std;

int main(){
    int n;
    cin>>n;
    unsigned long long a,b,c,d;
    for(int i=1;i<=n;i++){
        cin>>a>>b>>c>>d;
        if(a==b&&a==c&&a==d&&b==c&&b==d&&c==d) cout<<1;
        else if(a+b==c+d||a+c==b+d||a+d==b+c){
            if(a==b||a==c||a==d||b==c||b==d||c==d) cout<<4;
            else if(a!=b||a!=c||a!=d||b!=c||b!=d||c!=d) cout<<8;
        }
        else cout<<0;
        cout<<endl;
    }
    return 0;
}

*/

/*
P7106 双生独白

题目背景

我喜欢安静，你热爱喧闹；我忠于温暖，你酷爱凉爽。

如果任何事物都有反面，那拼接这个世界的颜色呢？

只有白与黑吗？
题目描述

为了形式化地描述颜色，我们引入 RGB 颜色值，用三元组 (r,g,b)(r,g,b)(r,g,b) 表示一种颜色，其中 r,g,br,g,br,g,b 分别为该颜色的 R 值、G 值、B 值
满足 0≤r,g,b≤2550 \le r,g,b \le 2550≤r,g,b≤255 且皆为十进制整数。


显然，这套颜色系统一共可以表示 256×256×256=16?777?216256 \times 256 \times 256 = 16\,777\,216256×256×256=16777216 种不
的颜色。对于颜色 (r,g,b)(r,g,b)(r,g,b)，定义其反色的 RGB 颜色值为 (255?r,255?g,255?b)(2
5-r,255-g,255-b)(255?r,255?g,255?b)。


然而人们发现，单纯地使用 RGB 颜色值很不方便，复制颜色时要复制三个值。

于是诞生了十六进制颜色码，即形如 #EBA932 长度为 777 的字符串。具体而言：

    字符串的第一位是 #，为颜色码标识符。
    字符串的第二、三位是十六进制数码，拼成的十六进制数等于十进制下所示颜色的 R 值。
 字符串的第四、五位是十六进制数码，拼成的十六进制数等于十进制下所示颜色的 G 值。
 字符串的第六、七位是十六进制数码，拼成的十六进制数等于十进制下所示颜色的 B 值。


十六进制数码从小到大包含 0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F，注意 A，B，C，D，E，F 均为大写。


现在你收到了一组十六进制颜色码，请你输出其反色的十六进制颜色码。

提示：颜色的 RGB 值与十六进制码之间可以相互转换（参考样例解释 #2）
输入格式

一行，输入长度为 777 的字符串，表示原色的十六进制颜色码。
输出格式

一行，输出长度为 777 的字符串，表示反色的十六进制颜色码。
输入输出样例
输入 #1

#FFFFFF

输出 #1

#000000

输入 #2

#EBA932

输出 #2

#1456CD

说明/提示

【样例解释 #1】

转换后原色的 RGB 值为 (255,255,255)(255,255,255)(255,255,255)，反色的 RGB 值为 (0,0,0)(0,0,0)(0,0,0)，对应十六进
码 #000000。

【样例解释 #2】

转换后原色的 RGB 值为 (235,169,50)(235,169,50)(235,169,50)，反色的 RGB 值为 (20,86,205)(20,86,205)(20,8
,205)，对应十六进制码 #1456CD。

为避免理解偏差，此处特别解释 #EBA932 转换后 B 值为 505050 的原因：提取字符串的第六、七位，拼成的十六进制数为 (32)16(32)_
16}(32)16?，则有 (32)16=3×161+2×160=50(32)_{16} = 3 \times 16^1 + 2 \times 16^
 = 50(32)16?=3×161+2×160=50。


【数据规模与约定】

本题共有 10 个测试点，每通过一个测试点可获得 10 points。

对于 10%10\%10% 的数据，为样例 #1。

对于另外 30%30\%30% 的数据，输入与输出字符串均不包含大写字母。

对于所有的数据，保证给定字符串为合法十六进制颜色码。

code:
int check(char n){
    if(n=='0') return 0+1;    if(n=='1') return 1+1;
    if(n=='2') return 2+1;    if(n=='3') return 3+1;
    if(n=='4') return 4+1;    if(n=='5') return 5+1;    
    if(n=='6') return 6+1;    if(n=='7') return 7+1;
    if(n=='8') return 8+1;    if(n=='9') return 9+1;
    if(n=='A') return 10+1;    if(n=='B') return 11+1;
    if(n=='C') return 12+1;    if(n=='D') return 13+1;
    if(n=='E') return 14+1;    if(n=='F') return 15+1;
    return 0;
}
int main(){
    char ch[10],tmp[17]={0,'F','E','D','C','B','A','9','8','7','6','5','4','3','2','1','0'};
    cin>>ch;
    cout<<"#";
    for(int i=1;i<=6;i++){
        int a=check(ch[i]);
        cout<<tmp[a];
    }
    return 0;
}

*/

/*
P7157 「dWoi R1」Physics Problem

题目背景

面对白板上的物理题，王马陷入了沉思 ……
题目描述

有 nnn 个状态，编号为 111 到 nnn。这 nnn 个状态之间有 kkk 种转换关系，第 iii 个转换关系描述为：第 uiu_iui? 个状态和第 viv_ivi? 个状态可以进行转换。当两
状态之间没有直接的转换关系但有间接的转换关系时，那么这两个状态之间有升降华关系。


求有多少个升降华关系。

王马不会做很难的物理题，所以保证一个状态一定可以通过直接或间接的转换为另一个任意状态。
输入格式

第一行两个整数 n,kn,kn,k 代表状态数和转换关系数。
接下来 kkk 行每行两个整数 ui,viu_i,v_iui?,vi? 代表这两个状态之间有转换关系。
 输出格式

一行一个整数代表有多少个升降华关系。
输入输出样例
输入 #1

3 2
1 2
2 3

输出 #1

1

说明/提示
样例 1 解释

一共有 333 个状态，编号为 1,2,31,2,31,2,3，第 111 个状态和第 222 个状态之间有转换关系，第 222 个状态和第 333 个状态之间有
换关系，第 111 个状态和第 333 个状态之间没有直接的转换关系，但可以用第 222 个状态做桥梁进行转换，所以第 111 个状态和第 333 个状态之间有升降华关系。只有这一个升降华关系，输出 1
1。

 数据规模与约定

本题采用捆绑测试。

    Subtask 1（5 pts）：n≤2n \le 2n≤2。
    Subtask 2（10 p
s）：k=n?1k=n-1k=n?1，ui+1=viu_i+1=v_iui?+1=vi?。 Subtask 3（10 p
s）：k=n?1k=n-1k=n?1，ui=1u_i=1ui?=1。 Subtask 4（25 p
s）：n,k≤1000n,k \le 1000n,k≤1000。 Subtask 5（50 pts）：无特殊限制。

对于 100%100\%100% 的数据，1≤n,k≤1071 \le n,k \le 10^71≤n,k≤107，1≤ui,vi≤n1 \le u_i,v_i \le n1≤ui?,vi?≤n。


保证 ui≠viu_i \ne v_iui?=vi? 且不存在 i≠j∧(ui=uj∧vi=vj)i \ne j ∧(u_i =u_j∧v_i=v_j)i=j∧(ui?=uj?∧
i?=vj?) 和 i≠j∧(ui=vj∧uj=vi)i \ne j∧(u_i=v_j∧u_j=v_i)i=j∧(ui?=vj?∧uj?=vi?)。


这句话也可以理解为无重边无自环。
提示

注意，对于下面这种情况（a - b 代表 aaa 能与 bbb 互相转换）：

1 - 2
2 - 3
1 - 3

第 111 个状态和第 333 个状态算有直接转换关系，即转换关系取“最短路”。
附件下载
yangli.in 1.18MB
yangli.out 10B

code:
int main () {
	long long n, k;
	cin>>n>>k;
	cout<<n*(n-1)/2-k);
	return 0;
}

*/

/*
P7174 [COCI2014-2015#4]CESTA

题目描述

Mirko 发现了一个正整数 nnn，由于 Mirko 喜欢数字 303030，他想知道用 nnn 的每位数字所组成的数中 303030 的最大倍数。



写一个计算这个数字的程序（如果不存在，则输出 -1）。
输入格式

一个数 nnn。
输出格式

仅一行，即题中所求。
输入输出样例
输入 #1

30

输出 #1

30

输入 #2

102

输出 #2

210

输入 #3

2931

输出 #3

-1

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，nnn 的位数不超过 10510^5105。
说明

题目译自 COCI2014-2015 CONTEST #4 T1 CESTA。

code:
int main () {
    char n;
    int a[10]={0};
    while(cin>>n){
    a[n-'0']++;
    }
    if(a[0]==0) cout<<-1;
    else {
        unsigned long long p=0;
        for(int i=0;i<10;i++)
            for(int j=0;j<a[i];j++)
                p+=i;
        if(p%3!=0)cout<<-1;
        else {
        for(int i=9;0<=i;i--)
            for(int j=0;j<a[i];j++)
                cout<<i;
        }
    }
    return 0;
}

*/

/*
P7189 [COCI2007-2008#6] PARKING

题目描述

Luka 毕业了，他找到了驾驶卡车的工作。

一天晚上，他将 333 辆卡车停在一个停车场，收费方式如下：

    停放一辆卡车时，司机每分钟给每辆车支付 aaa 元。
    停放两辆卡车时，司机每分钟给每辆车支付 bbb 元。
    停放三辆卡车时，司机每分钟给每辆车支付 ccc 元。

给定 a,b,ca, b, ca,b,c，以及 Luka 的三辆卡车的停车时间，请确定 Luka 要交多少钱。
输入格式

第一行，a,b,ca, b, ca,b,c，含义见题目描述。

接下来三行，每行 222 个数，表示第 iii 辆车的停车开始时间 beginibegin_ibegini? 和结束时间 endiend_iendi?，第 endiend_iendi? 分钟不收费。


输出格式

第一行，一个正整数，表示 Luka 要交的钱。
输入输出样例
输入 #1

5 3 1
1 6
3 5
2 8

输出 #1

33

输入 #2

10 8 6
15 30
25 50
70 80

输出 #2

480

说明/提示
数据规模与约定

对于 100%100\%100% 的数据，1≤c≤b≤a≤1001 \le c \le b \le a \le 1001≤c≤b≤a≤100。
说明

    本题满分 202020 分。
    本题自动开启 O2 优化开关。
    题目译自 COCI2007-2008 CONTEST #6 T1 PARKING，译者 @tearing。

code:
int main(){
    int x,y,z;cin>>x>>y>>z;
    int a[3][2];
    for(int i=0;i<3;i++)
        for(int j=0;j<2;j++)
            cin>>a[i][j];
    int t=a[0][1],p,sum=0;
    if(a[1][1]>t)t=a[1][1];
    if(a[2][1]>t)t=a[2][1];
    for(int i=0;i<t;i++){
    p=0;
    if(a[0][0]<=i && i<a[0][1])p++;
    if(a[1][0]<=i && i<a[1][1])p++;
    if(a[2][0]<=i && i<a[2][1])p++;
    if(p==3)sum+=z*3;
    else if(p==2)sum+=y*2;
    else if(p==1)sum+=x;
    }
    cout<<sum;
    return 0;
}

*/

/*
P7199 [COCI2019-2020#1] Trol

题目描述

Stjepan
最近在萨格勒布大学获得了数学学士学位。他的父母自然而然地为他感到骄傲，并决定给他所有不超过 2602^{60}260 的正整数作为礼物。为了保证它们的安全，他迅速地将所有数存入了一个序列 AAA，使得 Ai=iA_i=iAi?=i。




一个妒忌他的朋友 Marin 决定做一个恶作剧：不断地把 AAA 中的每个元素替换为其所有数位之和，直到最终只剩下一位数。


例如，第 197197197 个元素的初始值为 197197197。Marin 先将这个值变为 1+9+7=171+9+7=171+9+7=17，然后再一次改变了它，使其变为
1+7=81+7=81+7=8。

Stjepan 对此极为震惊，并请求 Marin 把序列变回初始状态。不幸的是，在他正确回答 QQQ 个询问之前，Marin 并不会如此。对于每一个询问，Stjepan 需要回答 AAA 序列中第 lll 项至第 r
r 项元素的总和。


来帮 Stjepan 回答这些询问吧！
输入格式

第一行包含一个整数 QQQ，表示询问次数。

接下来的 QQQ 行，每行包含两个正整数 li,ril_i,r_ili?,ri?，表示 Marin 第 iii 次询问的区间范围。
 输出格式

输出 QQQ 个询问的答案。答案之间应当用换行符两两分开，并且应当符合询问的顺序。
输入输出样例
输入 #1

1
1 5

输出 #1

15

输入 #2

2
9 13
44 45

输出 #2

19
17

输入 #3

1
1998 2018

输出 #3

102

说明/提示
数据规模及约定

对于 20%20\%20% 的数据，所有询问满足 1≤li≤ri≤91 \le l_i \le r_i \le 91≤li?≤ri?≤9。


对于 60%60\%60% 的数据，所有询问满足 ri?li≤1000r_i-l_i \le 1000ri??li?≤1000。


对于 100%100\%100% 的数据，1≤Q≤1001 \le Q \le 1001≤Q≤100，所有询问满足 1≤li≤ri≤2601 \le l_i \le r_i \le 
^{60}1≤li?≤ri?≤260。 说明

本题分值按 COCI 原题设置，满分 505050。

题目译自 COCI2019-2020 CONTEST #1 T1 Trol 。

code:
int main() {
	int n;
	cin>>n;
	while(n--) {
		long long l, r;
		cin>>l>>r;
		long long times=(r-l+1)/9;
		long long sum=times*45; 
		for(long long i=l+times*9;i<=r;i++)	sum+=(i-1)%9+1;	
		cout<<sum<<endl;
	}
	return 0;
}

*/

/*
P7222 [RC-04] 信息学竞赛

题目描述

小 R 今天学习了余角有关的数学知识，请你帮帮他计算一个角的余角吧！

一个角的余角的计算公式如下：

∠B=90°?∠A\angle B=90\degree -\angle A
∠B=90°?∠A

其中 A 是给出的角，B 是你要计算的角。
输入格式

一行一个整数 xxx，表示 ∠A=x°\angle A=x\degree∠A=x°。
输出格式

一行一个整数 yyy，表示 ∠B=y°\angle B=y\degree∠B=y°。你需要严格按照公式计算。
输入输出样例
输入 #1

100

输出 #1

-10

说明/提示

对于 100%100\%100% 的数据，xxx 在 C++ 语言的 int 范围内。即，x∈[?231,231?1
x\in[-2^{31},2^{31}-1]x∈[?231,231?1]。

code:
int main(){
    long long x;
    cin>>x;
    cout<<90-x;
    return 0;
}

*/

/*
P7226 [COCI2015-2016#3] POT

题目描述

老师给同学们发了一封电子邮件，任务如下。

    写一个程序，给你 nnn 个数，输出 XXX。

    X=num1p1+num2p2+?+numnpnX = num_1^{p_1} + num_2^{p_2} + \cdots + num_n^{p_n}
    X=num1p1??+num2p2??+?+numnpn??

    num1num_1num1?，num2num_2num2?，?\cdots?，numnnum_nnumn? 都是整数，p1p_1p1?，p
 p_2p2?，?\cdots?，pnp_npn? 都是一位数。



但是出现了一些玄学错误，使得 XXX 变成了：

X=q1+q2+...+qnX = q_1 + q_2 +... + q_n
X=q1?+q2?+...+qn?

注：qi=numi×10+piq_i = num_i \times 10 + p_iqi?=numi?×10+pi?。

例如，原来的 XXX 为 212+125321^2+125^3212+1253，但现在变成了 212+1253212+1253212+1253。请帮
 老师编写一个程序，输出原来 XXX 的值。 输入格式

第一行，一个正整数 nnn。

接下来 nnn 行，每行一个整数 pip_ipi?。
输出格式

仅一行一个整数，XXX 的值。
输入输出样例
输入 #1

2
212
1253

输出 #1

1953566

输入 #2

5
23
17
43
52
22

输出 #2

102

输入 #3

3
213
102
45

输出 #3

10385

说明/提示
数据规模及约定

对于 100%100\%100% 的数据，1≤n≤101 \le n \le 101≤n≤10，10≤pi≤9.999×10310 \le p_i \le 9.999 \times 10 ^ 310≤
 i?≤9.999×103，1≤X≤1091 \leq X \leq 10 ^ 91≤X≤109。
 说明

翻译自 COCI 2015-2016 #3 A POT，满分 50。

code:
int main(){
    int n;cin>>n;
    long long t=0;
    for(int i=0;i<n;i++){
    int k;cin>>k;
    t+=pow(k/10,k%10);
    }
    cout<<t;
    return 0;
}

*/

/*
P7257 [COCI2009-2010#3] FILIP

题目描述

给你两个十进制正整数 a,ba, ba,b，输出将这两个数翻转后的较大数。

「翻转」在本题中的定义 详见 提示 / 说明 部分。
输入格式

第一行，两个十进制正整数 a,ba, ba,b。
输出格式

第一行，aaa 和 bbb 翻转后的较大数。
输入输出样例
输入 #1

734 893

输出 #1

437

输入 #2

221 231

输出 #2

132

输入 #3

839 237

输出 #3

938

说明/提示
「翻转」在本题中的定义

设原数有 fff 位，最高位为 a1a_1a1?，第二位为 a2a_2a2?，……，第 fff 位为 afa_faf?。



那么该数的翻转同样有 fff 位，最高位为为 afa_faf?，第二位为 af?1a_{f - 1}af?1?，……，第 fff 位为 a1a_1a1?。
 数据规模及约定

对于 100%100\%100% 的数据，100≤a,b≤999100 \le a, b \le 999100≤a,b≤999，a,ba, ba,b 不含 000 或不为 000。
 说明

翻译自 COCI 2009-2010 #3 T1 FILIP，满分 30，每个测试点 3 分，共 10 个测试点。

code:
int main(){
    int n,m;cin>>n>>m;
    n=n%10*100+n%100/10*10+n/100;
    m=m%10*100+m%100/10*10+m/100;
    cout<<max(n,m);
    return 0;
}

*/

/*
P7262 Get Your Wish

题目背景

Get Your Wish

    So, tell me how it felt when you walked on water

    Did you get your wish?

题目描述

Porter 在浅水上完成了他的 MV，但他很快发现了事情不对：他的话筒进水了。

Porter 的话筒内部的关键电子元件可以被看作一个 n×mn\times mn×m 的二维平面。我们用一张 n×mn\times mn×m 的字符画来表示 Por
 er
的话筒内部状况，其中有三种不同的字符：


    .：表示空位

    x：表示关键电子原件

    o：表示水滴

水滴会沿着重力方向一直流动，直到流出边界或者流到电子原件上。当水滴流到任意一个电子原件上时，Porter 的话筒就会坏掉。Porter 慌忙把话筒转过来，改变了话筒内部的重力方向。重力方向用四种字符之一表示：^v<>，分别对应上下左右。





Porter 想知道，在这种重力方向下，他的话筒过一会儿会不会 GG。
输入格式

第一行两个正整数和一个字符，分别代表 nnn、mmm 和重力方向。

接下来 nnn 行，每行 mmm 个字符，分别对应代表该点状态。
输出格式

输出一行一个字符串。GG 代表 Porter 的话筒会坏掉，OK 代表不会。
输入输出样例
输入 #1

3 3 v
.o.
...
xxx

输出 #1

GG

输入 #2

3 3 >
...
o.x
...

输出 #2

GG

输入 #3

3 3 ^
.o.
...
xxx

输出 #3

OK

说明/提示
样例解释

样例一：第一行第二列的水滴向下流到了最后一行第二列的电子原件上，因此话筒坏掉了。

样例二：第二行第一列的水滴向右流到了第二行最后一列的电子原件上，因此话筒坏掉了。

样例三：第一行第二列的水滴直接向上流出话筒，因此 Porter 的话筒不会坏掉。
数据范围

对于全部数据，保证 1≤n,m≤1001\le n,m\le 1001≤n,m≤100，且输入数据合法。

Subtask 1 (10 pts)：话筒中没有 x（即电子原件）。

Subtask 2 (10 pts)：话筒中没有 o（即水滴）。

Subtask 3 (30 pts)：保证重力方向总是 v（向下）。

Subtask 4 (50 pts)：无特殊限制。

code:
int main(){
    int n,m;char k;//^v<>
    cin>>n>>m>>k;
    char a[n][m];
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
            cin>>a[i][j];
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++){
            if(a[i][j]=='o'){
            if(k=='^')
                for(int p=i;p>0;p--)
                    if(a[p][j]=='x'){
                    cout<<"GG";
                    return 0;
                    }
            if(k=='v')
                for(int p=i;p<n;p++)
                    if(a[p][j]=='x'){
                    cout<<"GG";
                    return 0;
                    }
            if(k=='<')
                for(int p=j;p>0;p--)
                    if(a[i][p]=='x'){
                    cout<<"GG";
                    return 0;
                    }
            if(k=='>')
                for(int p=j;p<m;p++)
                    if(a[i][p]=='x'){
                    cout<<"GG";
                    return 0;
                    }
            }
        }
        cout<<"OK";
    return 0;
}

*/

/*
P7285 「EZEC-5」修改数组

题目描述

给定一个长度为 nnn、元素由 000 或 111 组成的数组。

现在可以选择若干（可以为 0）个值为 000 的元素，将其修改为 111。

记：

    xxx 为数组中最长连续 111 子段的长度（规定，若所有数均为 000，则 xxx 为 000）；
 yyy 为修改的元素的个数。

求要怎么修改才能使 x?yx-yx?y 最大，并构造一个方案（输出修改后的数组）。
输入格式

本题含有多组数据。

第一行一个整数 TTT 表示数据组数。

接下来 2×T2\times T2×T 行，每 222 行表示一组数据。

在一组数据中，第一行一个整数 nnn，表示数组的长度；

第二行 nnn 个整数（0 或 1），表示给定的数组。
输出格式

共 2×T2\times T2×T 行，每 222 行表示一组数据。

在一组数据中，第一行输出一个整数表示 x?yx-yx?y 的最大值；

第二行 nnn 个整数（0 或 1）表示修改以后的数组。如有多个方案，任意输出一种即可。
输入输出样例
输入 #1

1
1
1

输出 #1

1
1

输入 #2

2
3
1 0 1
5
0 1 0 1 0

输出 #2

2
1 1 1
2
0 1 1 1 1

说明/提示

本题采用捆绑测试。

对于所有数据，保证 T≤10,1≤n≤105T\le10,1\le n\le 10^5T≤10,1≤n≤105，数组元素 ∈{0,1}\in \{0,1\}∈{0,1}。


    Subtask 1(70 points)：保证 1≤n≤101\le n\le 101≤n≤10；
    Subtask 2(30 points)：无特殊限制。


code:
int main(){
    int n,cnt,m,x;
	cin>>m;
	for(int j=0;j<m;j++){
		cnt=0;
		cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		if(x==1) cnt++;
	}
    if(j!=0)cout<<endl;
	cout<<cnt<<endl;
	for(int i=1;i<=n;i++)cout<<"1 ";
	}
    return 0;
}

*/

/*
P7337 『MdOI R4』Fun

题目背景

去 NOIP 考场时有两个优良传统：打狼和喝快乐水。这两项活动都能给同学们带来快乐。
题目描述

VG 的学校有 nnn 个人要去考 NOIP。

每个人有一个交通方式，第 iii 个人的交通方式为 tit_iti?，ti=1t_i=1ti?=1 表示这个人坐学校大巴，ti=0t_i=0ti?=0 表示这个人自己去考场。





每个人有一个颓废值，第 iii 个人的颓废值为 qiq_iqi?，qi=1q_i=1qi?=1 表示这个人愿意打狼，qi=0q_i=0qi?=0 表示这个人不愿意打狼。



每个人去考场时会买一瓶快乐水，但如果坐大巴且愿意打狼的人数（即满足 ti=1t_i=1ti?=1 且 qi=1q_i=1qi?=1 的 iii 个数）kkk 不小于 mmm，则这 kkk 个人只需要

 mmm 瓶快乐水。


现在，VG 统计出了所
人的交通方式和颓废值，他请你帮他求出最终所有人买快乐水的总瓶数。
输入格式

第一行三个整数 n,m,typen,m,typen,m,type。其中 typetypetype 表示特殊限制编号，具体意义见数据范围。

可能可以帮助你获得部分分，但正解不依赖于此。

第二行 nnn 个整数，第 iii 个整数为 tit_iti?。

第三行 nnn 个整数，第 iii 个整数为 qiq_iqi?。
输出格式

一行一个整数，表示所有人最终买的快乐水总瓶数。
输入输出样例
输入 #1

3 1 3
1 0 1
0 1 1

输出 #1

3

输入 #2

3 1 3
1 1 1
0 1 1

输出 #2

2

说明/提示

【样例解释 #1】

三个人的情况如下：

    第 111 个人乘坐大巴但不打狼；

    第 222 个人打狼但不乘坐大巴；

    第 333 个人乘坐大巴而且打狼。

所以，只有 111 个人既乘车又打狼，满足不小于 mmm 的条件，故对于这 111 个人需要购买 mmm 瓶快乐水，剩下 222 个人购买 222 瓶快乐水，总共须购买 333 瓶快乐水。





【数据规模与约定】

本题不采用捆绑测试
测试点编号 	n,mn,mn,m 	typetypetype 	tit_iti? 	qiq_iqi?
111 	≤30\le 30≤30 	=0=0=0 	=0=0=0 	=0=0=0
222 	≤70\le 70≤70 	=0=0=0 	=0=0=0 	=0=0=0
333 	≤30\le 30≤30 	=1=1=1 	=1=1=1 	=1=1=1
444 	≤70\le 70≤70 	=1=1=1 	=1=1=1 	=1=1=1
555 	n=mn=mn=m 	=2=2=2 	无特殊限制 	无特殊限制
666 	n=mn=mn=m 	=2=2=2 	无特殊限制 	无特殊限制
777 	n=mn=mn=m 	=2=2=2 	无特殊限制 	无特殊限制
888 	无特殊限制 	=3=3=3 	无特殊限制 	无特殊限制
999 	无特殊限制 	=3=3=3 	无特殊限制 	无特殊限制
101010 	无特殊限制 	=3=3=3 	无特殊限制 	无特殊限制

对于 100%100\%100% 的数据，1≤m≤n≤1001 \le m \le n \le 1001≤m≤n≤100，ti,q
∈{0,1}t_i,q_i \in \{0,1\}ti?,qi?∈{0,1}，type∈{
,1,2,3}type \in \{0,1,2,3\}type∈{0,1,2,3}。

code:
int main(){
    int n,m,type,tt=0;
    cin>>n>>m>>type;
    bool t[n],p[n];
    for(int i=0;i<n;i++)cin>>t[i];
    for(int i=0;i<n;i++)cin>>p[i];
    for(int i=0;i<n;i++){
    if(t[i] && p[i])tt++;
    }
    if(tt>m)cout<<n+m-tt;
    else cout<<n;
    return 0;
}

*/

/*
P7398 [COCI2020-2021#5] ?ifra

题目描述

给定一个长度不超过 100100100 的只包含小写字母和 0?90 \sim 90?9 字符的字符串（字符串中的字母可视为分隔符）。求字符串中包含多少个不同的数字。


输入格式

一行只包含小写字母和 0?90 \sim 90?9 字符的字符串，保证每个数字最多有 333 位。
输出格式

输出字符串中不同数字的数量。
输入输出样例
输入 #1

abc123abc2a3a1

输出 #1

4

输入 #2

borna123vitez

输出 #2

1

输入 #3

as23dkrf23smk1asd23sam9

输出 #3

3

说明/提示
数据规模与约定

对于 50%50\%50% 的数据，所有出现的数字都互不相同。

对于 100%100\%100% 的数据，字符串的长度在 111 到 100100100 之间。
说明

本题分值按 COCI 原题设置，满分 505050。

题目译自 COCI2020-2021 CONTEST #5 T1 ?ifra。

code:
bool a[1000];
int main(){
    string c;cin>>c;
    int t=0,p=0;
    for(int i=0;i<(c.length());i++){
        if('0'<=c[i] && c[i]<='9'){
            t=t*10+c[i]-'0';
            p=1;
        }
        else if(p){
            p=false;
            a[t]=1;
            t=0;
        }
    }
    if(p==1)a[t]=1;
    t=0;
    for(int i=0;i<=1000;i++)if(a[i])t++;
    cout<<t;
    return 0;
}

*/









